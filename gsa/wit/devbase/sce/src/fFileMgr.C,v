head	1.21;
access;
symbols
	sce_5_01_20080919:1.9
	latest_sce_4_20_20060523:1.6.0.6
	sce_4_20_20060523:1.6
	latest_sce4_20_OSL:1.6.0.4
	sce_4_20_OSL:1.6
	sce_4_20_20051222:1.6
	sce_4_10_30050426:1.6
	sce_4_05_20040511:1.6
	sce_4_00_20040201:1.6
	nextGenBranch:1.6.0.2
	nextGenRoot:1.6
	sce_3_30_20030627:1.6
	EndRw-branch:1.4.0.2
	Root-of-EndRw:1.4
	EndWitRw-branch:1.3.0.4
	Root-of-EndWitRw:1.3
	RwToStl-branch:1.3.0.2
	Root-of-RwToStl:1.3
	latest_sce_3_10_20010924:1.2.0.4
	sce_3_10_20010924:1.2
	latest_sce_3_00_20010601:1.2.0.2
	sce_3_00_20010601:1.2
	latest_sce_2_31_20010308:1.1.1.1.0.4
	sce_2_31_20010308:1.1.1.1
	latest_sce_2_31_20001003:1.1.1.1.0.2
	sce_2_31_20001003:1.1.1.1
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2011.04.06.21.49.03;	author ervolina;	state Exp;
branches;
next	1.20;
deltatype	text;
permissions	644;
commitid	19bc4d9cdf5560a1;
kopt	kv;
filename	@fFileMgr.C@;

1.20
date	2011.03.25.21.04.00;	author ervolina;	state Exp;
branches;
next	1.19;
deltatype	text;
permissions	644;
commitid	18f84d8d033615fb;
kopt	kv;
filename	@fFileMgr.C@;

1.19
date	2011.03.22.17.20.23;	author ervolina;	state Exp;
branches;
next	1.18;
deltatype	text;
permissions	644;
commitid	19944d88d9d47ee4;
kopt	kv;
filename	@fFileMgr.C@;

1.18
date	2011.03.17.17.58.44;	author ervolina;	state Exp;
branches;
next	1.17;
deltatype	text;
permissions	644;
commitid	25bc4d824b6d15ef;
kopt	kv;
filename	@fFileMgr.C@;

1.17
date	2010.04.20.14.26.55;	author ervolina;	state Exp;
branches;
next	1.16;
deltatype	text;

1.16
date	2010.04.07.16.18.26;	author ervolina;	state Exp;
branches;
next	1.15;
deltatype	text;

1.15
date	2010.03.29.11.54.38;	author ervolina;	state Exp;
branches;
next	1.14;
deltatype	text;

1.14
date	2010.03.26.19.48.24;	author ervolina;	state Exp;
branches;
next	1.13;
deltatype	text;

1.13
date	2010.03.16.17.56.22;	author ervolina;	state Exp;
branches;
next	1.12;
deltatype	text;

1.12
date	2010.03.13.18.53.04;	author ervolina;	state Exp;
branches;
next	1.11;
deltatype	text;

1.11
date	2009.12.08.13.58.34;	author ervolina;	state Exp;
branches;
next	1.10;
deltatype	text;

1.10
date	2009.01.28.14.22.30;	author ervolina;	state Exp;
branches;
next	1.9;
deltatype	text;

1.9
date	2008.06.03.19.22.11;	author ervolina;	state Exp;
branches;
next	1.8;
deltatype	text;

1.8
date	2008.04.24.14.04.41;	author ervolina;	state Exp;
branches;
next	1.7;
deltatype	text;

1.7
date	2008.03.20.14.52.46;	author ervolina;	state Exp;
branches;
next	1.6;
deltatype	text;

1.6
date	2003.06.26.23.09.37;	author ervolina;	state Exp;
branches;
next	1.5;
deltatype	text;

1.5
date	2003.01.15.19.36.55;	author rwToStl;	state Exp;
branches;
next	1.4;
deltatype	text;

1.4
date	2002.11.26.14.25.29;	author fasano;	state Exp;
branches
	1.4.2.1;
next	1.3;
deltatype	text;

1.3
date	2002.06.18.21.10.27;	author ervolina;	state Exp;
branches;
next	1.2;
deltatype	text;

1.2
date	2001.03.19.20.34.06;	author ervolina;	state Exp;
branches;
next	1.1;
deltatype	text;

1.1
date	2000.02.25.18.36.50;	author wit;	state Exp;
branches
	1.1.1.1;
next	;
deltatype	text;

1.1.1.1
date	2000.02.25.18.36.50;	author wit;	state Exp;
branches
	1.1.1.1.4.1;
next	;
deltatype	text;

1.1.1.1.4.1
date	2001.03.21.16.06.27;	author scelib;	state Exp;
branches;
next	;
deltatype	text;

1.4.2.1
date	2003.01.08.17.43.14;	author rwToStl;	state Exp;
branches;
next	1.4.2.2;
deltatype	text;

1.4.2.2
date	2003.01.09.13.14.33;	author rwToStl;	state Exp;
branches;
next	1.4.2.3;
deltatype	text;

1.4.2.3
date	2003.01.14.19.06.03;	author rwToStl;	state Exp;
branches;
next	;
deltatype	text;


desc
@@


1.21
log
@fixed formatting error in printing iPegCrit
@
text
@\
// RW2STL - inserted:
#include <string>
#include <ostream>
#include <scenario/src/RWToSTLHelpers.h>
// End of RW2STL - inserted includes.

#include <stdlib.h>
#include <iostream>
#include <fstream>
#include <mcl/src/mcl.h>

#include <sce/src/fFileMgr.h>


// =============================
// =============================
//           SCE 6.1
// =============================
// =============================

// SCE5
//             WRITE Stuff First
//  -------------------------------------------------------------------------------------
// **** writeDemandRecord
// Print to either multi_attribute_demand_class OR Dated_Demands format ... automatically
//  -------------------------------------------------------------------------------------
void 
LgFrSceFlatFileMgr::writeDemandRecord(
    std::ofstream & theStream,   // output stream (already opened)
    LgFrMultiPlantHelper & mpHelper,
    LgFrCalendar & theCal,
    const std::string & partname,
    const std::string & pdf,
    const std::string & demandName,
    int    vLength,         // lenght of the vector (nPeriods?)
    const float * theVector,      // the vector itself
    bool printIfZero,
    int precision,          // number of digits to the right of the decimal
    int totalSpace)         // total length of the 'formatted' field
{

  std::string leadingString;


  mpHelper.populateLeadingString(partname, pdf, demandName, leadingString);

  writeFloatVecToStream(theCal, theStream, vLength, printIfZero, leadingString, theVector);
}




// SCE 6.1
//  -------------------------------------------------------------------------------------
// **** writeDemandRecordINDP
// Print to either multi_attribute_demand_class OR Dated_Demands format ... automatically
//  -------------------------------------------------------------------------------------
void 
LgFrSceFlatFileMgr::writeDemandRecordINDP(
    std::ofstream & theStream,   // output stream (already opened)
    LgFrMultiPlantHelper & mpHelper,
    LgFrCalendar & theCal,
    const std::string & partname,
    const std::string & pdf,
    const std::string & demandName,
    int    vLength,         // lenght of the vector (nPeriods?)
    const float * theVector,      // the vector itself
    bool printIfZero,
    int precision,          // number of digits to the right of the decimal
    int totalSpace)         // total length of the 'formatted' field
{

  std::string leadingString;

  // 6.1 enables muti-attribute and dated 
  //        which requestDate do we pull and write???
  //          if D2O on INDP?
  //          then the original requestDate is part of the multi-attribute Key and the following will get it
  //          else if D2O on INDP is false, the we should just use the commit date ...
  mpHelper.populateLeadingStringINDP(partname, pdf, demandName, leadingString);
  if (useDatedDemands_)
    writeFloatVecToStreamDoubleDated(theCal, theStream, vLength, printIfZero, leadingString, theVector);
  else
    writeFloatVecToStream(theCal, theStream, vLength, printIfZero, leadingString, theVector);

}

// SCE 6.1
//  -------------------------------------------------------------------------------------
// **** writeGpdDemandRecord
// Print to either multi_attribute_demand_class OR Dated_Demands format ... automatically
//  -------------------------------------------------------------------------------------
void 
LgFrSceFlatFileMgr::writeGpdDemandRecord(
    std::ofstream & theStream,    // output stream (already opened)
    LgFrMultiPlantHelper & mpHelper,
    LgFrCalendar & theCal,
    const std::string & partname,
    const std::string & demandName,
    int    vLength,               // length of the vector (nPeriods?)
    const float * theVector,      // the vector itself
    bool printIfZero,
    int precision,                // number of digits to the right of the decimal
    int totalSpace)               // total length of the 'formatted' field
{

  std::string leadingString;

  mpHelper.populateLeadingStringGPD(partname, demandName, leadingString);

  writeFloatVecToStream(theCal, theStream, vLength, printIfZero, leadingString, theVector);
}



//  ---------------------------------------------------------------------
//  Utility to print a float vector to an output stream
//  --------------------------------------------------------------------- 
void 
LgFrSceFlatFileMgr::writeCsvFloatVector(
    std::ofstream & theStream,   // output stream (already opened)
    int    vLength,         // lenght of the vector (nPeriods?)
    const float * theVector,      // the vector itself
    int precision,          // number of digits to the right of the decimal
    int totalSpace)         // total length of the 'formatted' field
{
   int t = 0;
   for (t=0; t<vLength; t++) {
     if ((theVector[t] < 0.0001) && (theVector[t] > -0.0001))
       theStream << "," << (float) 0.0;
     else
       theStream << "," << theVector[t];
   }
   theStream << "\n";
}

//  ---------------------------------------------------------------------
//  SCE 6.1 
//  Print a FloatVec to Stream as either Dated or Vectored
//  Use this as a replacement for 	  writeCsvFloatVector();
//  --------------------------------------------------------------------- 
void 
LgFrSceFlatFileMgr::writeFloatVecToStream(
					 const LgFrCalendar & theCal,
					 std::ofstream & theStream,    // output stream (already opened)
					 int    vLength,               // length of the vector (usually nPeriods)
					 const int    printIfZero,     // printRecordIfZero: for vectored will cause a vector of zeros to print
					                               //                    for dated will cause a zero record to write
					 std::string & leadingString,  // leading string 
					 const float * theVector)      // the vector itself
{
  int t;
  if (useDatedDemands_)   {
    t = 0;
    for (t=0; t<vLength; t++) {
      if (printIfZero || ((theVector[t] >  0.0001) ||  (theVector[t] < -0.0001)))
	theStream << leadingString << "," << theCal.yyyymmdd(theCal.periodStart(t)) << "," << theVector[t] << "\n";
    }
    
  }

  // here is the case of  vectored output
  else {
    bool doWePrintThisRecord = (printIfZero ? true : false);
    int t = 0; 
    
    // loop through once to see if there is a non-zero
    if (! doWePrintThisRecord) {
      for (t=0; t<vLength; t++) {
	if ((theVector[t] > 0.0001) || (theVector[t] < -0.0001)) {
	  doWePrintThisRecord = true;
	  break;
	}
      }
    }
     
    if (doWePrintThisRecord) {
      theStream << leadingString;
      for (t=0; t<vLength; t++) {
	float theVal = theVector[t];
	if ((theVal < 0.0001) && (theVal > -0.0001)) {
	  theVal = 0.0;
	}
	theStream << "," << theVal;
      }
      theStream << "\n";
    }
  }
}


//  ---------------------------------------------------------------------
//  Print a FloatVec to Stream as in Dated mode only.   This method prints the commit date twice in order
//  to fit the datamodel for INDP type dmeands when D2O logic is off.   In this case we don't know the request date and fake it
//  by printing the commit date
//  --------------------------------------------------------------------- 
void 
LgFrSceFlatFileMgr::writeFloatVecToStreamDoubleDated(
					 const LgFrCalendar & theCal,
					 std::ofstream & theStream,    // output stream (already opened)
					 int    vLength,               // length of the vector (usually nPeriods)
					 const int    printIfZero,     // printRecordIfZero: for vectored will cause a vector of zeros to print
					                               //                    for dated will cause a zero record to write
					 std::string & leadingString,  // leading string 
					 const float * theVector)      // the vector itself
{
  int t;

  t = 0;
  for (t=0; t<vLength; t++) {
    if (printIfZero || ((theVector[t] >  0.0001) ||  (theVector[t] < -0.0001)))
      theStream << 
	leadingString << "," << 
	theCal.yyyymmdd(theCal.periodStart(t)) << "," << 
	theCal.yyyymmdd(theCal.periodStart(t)) << "," << 
	theVector[t] << "\n";
  }
  

}



// SCE 6.1 
// parse out the demandType (TINP, INDP) 
// used by processDemandFile()
int 
LgFrSceFlatFileMgr::demandType(const std::string & demandName)
{
  
  // multi_attribute_demand
  assert (useMultiAttributeDemand_);

  SCETokenizer next(demandName);
  std::string token;

  int tokCnt=0;
  for (tokCnt=0; tokCnt<demandTypeKeyFieldNum_; tokCnt++) {
    token =  next(multiAttributeDemandSeparator_.c_str());
    
    if (token.empty()) {
      return DEMAND_TYPE_ERROR;
    }
  }
  if (token == "INDP")
    return DEMAND_TYPE_INDP;
  if (token == "TINP")
    return DEMAND_TYPE_TINP;
  
  return DEMAND_TYPE_ERROR;
}




// =============================================
//    Read Stuff Second 
// =============================================


// ----------------------------------------------------------------
// DATED_DEMANDS
// returns -1 if record is rejected (illegal date, illegal floatValue, or floatValue out of range)
// returns 0 if  record is out of range and ignored, 
// returns 1 if  record is in range and positive
//
//  **** pastDueDemands and pastFutureDemands ****
//         for now we assume 
//               ====> past_due_demand are INCLUDED in Period 0  (these are dates that fall before period 0)
//               ====> PAST_FUTURE_DEMANDS are IGNORED   (these are dates that fall beyond the last period)
//         FINISH_ME: create a param to enable different global assumptions on how
//                    the logic of maybe pass in a pastDueDemands param?
int  
LgFrSceFlatFileMgr::readDatedDemandFloatRecord(
					       float & theVal,
					       // int & thePeriod,
					       std::string  & requestDate,
					       const bool Mandatory,
					       const float lowerLimit,
					       const float upperLimit,
					       SCETokenizer & next,
					       const std::string & fileName,   
					       const std::string & dataLine,
					       const long & lineNo,
					       const LgFrMultiPlantHelper & mpHelper,
					       const LgFrCalendar & theCal)
{
  char dataDelim[] = " \",\n"; 
  int nPeriods = theCal.nPeriods();

  double d;
  
  std::string token;
  
  // read the date
  //  if the line is blank then return -1 (invalid datedDemand, reject)
  if ((requestDate = next(dataDelim)).empty())   
    return -1;
  
  // check the date, if it is invalid then return -1 (invalid datedDemand, reject)
  LgFrDatetime theDate(parseDateString(requestDate, theCal));
  if (! theDate.isValid())  {
    (*sceErrFacility_)("InvalidDate",MclArgList() << "start date" << fileName << (int) lineNo << dataLine);
    return -1;
  }
  
  // Now get the float
  token = next(dataDelim);
  if (token.empty())   {
    if (Mandatory)  {
      (*sceErrFacility_)("MissingData",MclArgList() << "float" << fileName << (int) lineNo << dataLine);
    }
    return -1;
  }
  
  // convert the  token into a float
  if (! sce::fromString( token, d))  {
    (*sceErrFacility_)("InvalidDataType",MclArgList() << "float" << fileName << (int) lineNo << dataLine);
  }
  
  theVal = (float) d;
  

  if (theVal < lowerLimit) {
    (*sceErrFacility_)("OutOfRangeFloatWithBound",MclArgList() << fileName << (int) lineNo << dataLine << theVal << "Lower limit" << lowerLimit << "");
  }
  if (theVal > upperLimit) {
    (*sceErrFacility_)("OutOfRangeFloatWithBound",MclArgList() << fileName << (int) lineNo << dataLine << theVal << "Upper limit" << upperLimit << "");
  }
  
  // If you get here then everything is OK
  return 1;
}



// Multi-Attribute Demand Classes.   
//    try this ... can go either way
//    demandName = flatFileManager.nextDemandGeoOrMultiAttributeQuotedString(next, result, fileName, dataLine, lineNo, MANDATORY);

//  --------------------------------------------------------------------- 
// This method is a test of the potential for SCE to deal directly with
// used by ==>  
//             processDemandFile
//             process61TopLevelToOptionalFeatureFile
//             processIndependentDemandFile (with ifdef MULTI_ATTRIBUTE_DEMAND_CLASS)
//             
std::string
LgFrSceFlatFileMgr::nextQuotedDemandString(
    SCETokenizer & next,
    int & result,
    const std::string & fileName,
    const std::string & dataLine,
    long lineNo,
    const int doYouNeedIt)
{


  result = 0;

  // multi_attribute_demand
  if (useMultiAttributeDemand_) {

    std::string finalToken = "";

    int tokCnt=0;
    for (tokCnt=0; tokCnt<numDemandAttributes_; tokCnt++) {

      // get the first token, including junk like spaces and tabs
      std::string token = next(",\n");
      
      token = sce::extractQuotedPart( token );
      
      if (doYouNeedIt == MANDATORY && token.empty()) {
	(*sceErrFacility_)("MissingData",MclArgList() 
			   << "quoted string in MultiAttributeDemand" 
			   << fileName 
			   << (int) lineNo 
			   << dataLine);
	// this will exit
      }
      
      if ( token.empty())    {
	if (doYouNeedIt == OPTIONAL_WITH_MESSAGE)
	  (*sceErrFacility_)("MissingDataWarning",MclArgList() 
			     << "quoted string in MultiAttributeDemand" 
			     << fileName 
			     << (int) lineNo 
			     << dataLine);
	result = -1;
      }
      
      if (tokCnt > 0)
	finalToken += multiAttributeDemandSeparator_ + token;
      else 
	finalToken += token;
    }
    return finalToken;
  }



  // single attribute demand
  else {
    // get the next token, including junk like quotes, spaces, and tabs
    std::string token = next(",\n");
    
    token = sce::extractQuotedPart( token );
    
    if (doYouNeedIt == MANDATORY && token.empty()) {
      (*sceErrFacility_)("MissingData",MclArgList() 
			 << "quoted string" 
			 << fileName 
			 << (int) lineNo 
			 << dataLine);
      // this will exit
    }
    
    if ( token.empty())    {
      if (doYouNeedIt == OPTIONAL_WITH_MESSAGE)
	(*sceErrFacility_)("MissingDataWarning",MclArgList() 
			   << "quoted string" 
			   << fileName 
			   << (int) lineNo 
			   << dataLine);
      result = -1;
    }
    return token;
  }

}



// reads:
//   part, pdf, 
// used by:
//    processCapacitySupplyFile61()
int  
LgFrSceFlatFileMgr::readPartPdfAndCheckExistence(
    WitRun * const theWitRun,  
    const int errorAction,  
    std::string & pdf_PartName,    // pdf_PartName to be returned
    std::ifstream & inFile,             // An open stream
    const std::string & fileName,  // For error messaging
    std::string & dataLine,
    long & lineNo,
    const LgFrMultiPlantHelper & mpHelper)
{
    std::string pdf;
    std::string mfgPartName;
    int result = 0;

    std::getline( inFile, dataLine );
    lineNo++;
    dataLine = sce::strip( dataLine );
    if ((dataLine[0] == '*') || dataLine.empty())
	return -2;

    SCETokenizer next(dataLine);
    if ( containsIllegalCharacters( dataLine )) {
      (*sceErrFacility_)("IllegalCharacter",MclArgList() << fileName << (int)lineNo << dataLine);
      return 1;
    }

    // get the partname, pdf, and pdf_partname
    mfgPartName = nextQuotedString(next, result, fileName, dataLine, lineNo, MANDATORY);
    pdf = nextQuotedString(next, result, fileName, dataLine, lineNo, MANDATORY);
    pdf_PartName = mpHelper.pdfPartname(mfgPartName, pdf);
    if (! mpHelper.isPartValid(theWitRun, mfgPartName, pdf, fileName, dataLine, lineNo, OPTIONAL_WITH_MESSAGE))
      return 1;
    return 0;
}


// reads:
//   part, pdf, floatQty, startDate, endDate
// used by:
//    processCycleTimeFile()
//    processCycleTimeFile() the old way with ifdef VARIABLE_PERIODS
//    processYieldFile
int  
LgFrSceFlatFileMgr::readCsvPartFloatDatedRecord(
    WitRun * const theWitRun,   // WIT environment    
    const int nPeriods,         // Number of periods  
    std::string & pdf_PartName,   // pdf_PartName to be returned
    const LgFrCalendar & theCal,
    float & theVal,
    int & start,
    int & end,
    std::ifstream & inFile,             // An open stream
    const std::string & fileName,  // For error messaging
    std::string & dataLine,
    long & lineNo,
    const LgFrMultiPlantHelper & mpHelper)
{

    std::string pdf;
    std::string mfgPartName;
    int result = 0;

    std::getline( inFile, dataLine );
    lineNo++;
    dataLine = sce::strip( dataLine );
    if ((dataLine[0] == '*') || dataLine.empty())
	return -2;
    SCETokenizer next(dataLine);
    if ( containsIllegalCharacters( dataLine )) {
      (*sceErrFacility_)("IllegalCharacter",MclArgList() << fileName << (int)lineNo << dataLine);
    }

    // get the partname, pdf, and pdf_partname
    mfgPartName = nextQuotedString(next, result, fileName, dataLine, lineNo, MANDATORY);
    pdf = nextQuotedString(next, result, fileName, dataLine, lineNo, MANDATORY);
    pdf_PartName = mpHelper.pdfPartname(mfgPartName, pdf);
    
    if (! mpHelper.isPartValid(theWitRun, mfgPartName, pdf, fileName, dataLine, lineNo, OPTIONAL_WITH_MESSAGE))
      return 1;
    
    
    result = nextFloat(theVal, next, fileName, dataLine, lineNo, true, -FLT_MAX);
    
    
    if (result >= 0)
      result = nextStartEndDates(start, end, next, fileName, lineNo, dataLine, theCal);

    // if dates were messed up, then skip the record
    if (result == 1)
	return 1;

    return 0;
}



// =============================
// =============================
//     END new      SCE 6.1
// =============================
// =============================




// ----------------------------------------------------------------
void
LgFrSceFlatFileMgr::setErrFacility(MclFacility * existingFacility)
{
  // in effect, borrowing an existing message facility
  sceErrFacility_ = existingFacility;
}

MclFacility *
LgFrSceFlatFileMgr::getErrFacility()
{
  return sceErrFacility_;
}









// ----------------------------------------------------------------
int  
LgFrSceFlatFileMgr::readCsvOperationFloatDatedRecord(
    WitRun * const theWitRun,   // WIT environment    
    const int nPeriods,         // Number of periods  
    std::string & pdf_OperationName,   // pdf_PartName to be returned
    const LgFrCalendar & theCal,
    float & theVal,
    int & start,
    int & end,
    std::ifstream & inFile,             // An open stream
    const std::string & fileName,  // For error messaging
    std::string & dataLine,
    long & lineNo,
    const LgFrMultiPlantHelper & mpHelper)
{

    std::string pdf;
    std::string operationName;
    int result = 0;

    std::getline( inFile, dataLine );
    lineNo++;

//  skip blanks or comments *
    dataLine = sce::strip( dataLine );
    if ((dataLine[0] == '*') || dataLine.empty())
	return -2;

// check if the line contains any illegal characters
    if ( containsIllegalCharacters( dataLine )) {
      (*sceErrFacility_)("IllegalCharacter",MclArgList() << fileName << (int)lineNo <<dataLine);
    }


    SCETokenizer next(dataLine);

// get the pdf operation name
    operationName = nextQuotedString(next, result, fileName, dataLine, 
                                   lineNo, MANDATORY);
    pdf = nextQuotedString(next, result, fileName, dataLine, 
                           lineNo, MANDATORY);
    pdf_OperationName = mpHelper.pdfOperationName(operationName, pdf);
    
    if (! mpHelper.isOperationValid(theWitRun, 
			       pdf_OperationName, 
			       fileName, 
			       dataLine, 
			       lineNo, 
			       OPTIONAL_WITH_MESSAGE))
	return 1;


    result = nextFloat(theVal, next, fileName, dataLine, lineNo, true, -FLT_MAX);


    if (result >= 0)
	nextStartEndDates(start, end, next, fileName, lineNo, dataLine, theCal);

    // if dates were messed up, then skip the record
    if (result == 1)
	return 1;


    return 0;
}




// ----------------------------------------------------------------
int  
LgFrSceFlatFileMgr::readCsvOperationFloatRecord(
    WitRun * const theWitRun,   // WIT environment    
    const int nPeriods,         // Number of periods  
    std::string & pdf_OperationName,   // pdf_PartName to be returned
    const LgFrCalendar & theCal,
    float & theVal,
    std::ifstream & inFile,             // An open stream
    const std::string & fileName,  // For error messaging
    std::string & dataLine,
    long & lineNo,
    const LgFrMultiPlantHelper & mpHelper)
{

    std::string pdf;
    std::string operationName;
    int result = 0;

    std::getline( inFile, dataLine );
    lineNo++;

//  skip blanks or comments *
    dataLine = sce::strip( dataLine );
    if ((dataLine[0] == '*') || dataLine.empty())
	return -2;

// check if the line contains any illegal characters
    if ( containsIllegalCharacters( dataLine )) {
      (*sceErrFacility_)("IllegalCharacter",MclArgList() << fileName << (int)lineNo <<dataLine);
    }


    SCETokenizer next(dataLine);

// get the pdf operation name
    operationName = nextQuotedString(next, result, fileName, dataLine, 
                                   lineNo, MANDATORY);
    pdf = nextQuotedString(next, result, fileName, dataLine, 
                           lineNo, MANDATORY);
    pdf_OperationName = mpHelper.pdfOperationName(operationName, pdf);
    
    if (! mpHelper.isOperationValid(theWitRun, 
			       pdf_OperationName, 
			       fileName, 
			       dataLine, 
			       lineNo, 
			       OPTIONAL_WITH_MESSAGE))
	return 1;


    result = nextFloat(theVal, next, fileName, dataLine, lineNo, true, 0.0);



    return 0;
}






// ----------------------------------------------------------------
int  
LgFrSceFlatFileMgr::readCsvPart2FloatsDatedRecord(
    WitRun * const theWitRun,   // WIT environment    
    const int nPeriods,         // Number of periods  
    std::string & pdf_PartName,   // pdf_PartName to be returned
    const LgFrCalendar & theCal,
    float & theVal,
    float & theVal2,
    int & start,
    int & end,
    std::ifstream & inFile,             // An open stream
    const std::string & fileName,  // For error messaging
    std::string & dataLine,
    long & lineNo,
    const LgFrMultiPlantHelper & mpHelper)
{
 
    std::string pdf;
    std::string mfgPartName;
    int result = 0;
    int result2 = 0;
    std::getline( inFile, dataLine );
    lineNo++;



    
//  skip blanks or comments *
    dataLine = sce::strip( dataLine );
    if ((dataLine[0] == '*') || dataLine.empty())
	return -2;

    SCETokenizer next(dataLine);

// check if the line contains any illegal characters
    if ( containsIllegalCharacters( dataLine )) {
      (*sceErrFacility_)("IllegalCharacter",MclArgList() << fileName << (int)lineNo << dataLine);
    }
    
// get the pdf partname

    mfgPartName = nextQuotedString(next, result, fileName, dataLine, 
				   lineNo, MANDATORY);
    pdf = nextQuotedString(next, result, fileName, dataLine, 
			   lineNo, MANDATORY);
    pdf_PartName = mpHelper.pdfPartname(mfgPartName, pdf);
    
    
    
    
    if (! mpHelper.isPartValid(theWitRun, 
			       mfgPartName, 
			       pdf,
			       fileName, 
			       dataLine, 
			       lineNo, 
			       OPTIONAL_WITH_MESSAGE))
      return 1;
    
    result = nextFloat(theVal, next, fileName, dataLine, lineNo, true, -FLT_MAX);
    result2 = nextFloat(theVal2, next, fileName, dataLine, lineNo, true, -FLT_MAX);

    if (result >= 0 && result2 >=0)
	nextStartEndDates(start, end, next, fileName, lineNo, dataLine, theCal);

    // if dates were messed up, then skip the record
    if (result == 1 || result2 ==1)
	return 1;


    return 0;
}


// ----------------------------------------------------------------
int  
LgFrSceFlatFileMgr::readCsvOperation2FloatsDatedRecord(
    WitRun * const theWitRun,   // WIT environment    
    const int nPeriods,         // Number of periods  
    std::string & pdf_OperationName,   // pdf_OperationName to be returned
    const LgFrCalendar & theCal,
    float & theVal,
    float & theVal2,
    int & start,
    int & end,
    std::ifstream & inFile,             // An open stream
    const std::string & fileName,  // For error messaging
    std::string & dataLine,
    long & lineNo,
    const LgFrMultiPlantHelper & mpHelper)
{

    std::string pdf;
    std::string operationName;
    int result = 0;
    int result2 = 0;
    std::getline( inFile, dataLine );
    lineNo++;

//  skip blanks or comments *
    dataLine = sce::strip( dataLine );
    if ((dataLine[0] == '*') || dataLine.empty())
	return -2;

    SCETokenizer next(dataLine);

// check if the line contains any illegal characters
    if ( containsIllegalCharacters( dataLine )) {
      (*sceErrFacility_)("IllegalCharacter",MclArgList() << fileName << (int)lineNo << dataLine);
    }


// get the pdf operation name
    operationName = nextQuotedString(next, result, fileName, dataLine, 
                                   lineNo, MANDATORY);
    pdf = nextQuotedString(next, result, fileName, dataLine, 
                           lineNo, MANDATORY);
    pdf_OperationName = mpHelper.pdfOperationName(operationName, pdf);



    
    if (! mpHelper.isOperationValid(theWitRun, 
			       pdf_OperationName, 
			       fileName, 
			       dataLine, 
			       lineNo, 
			       OPTIONAL_WITH_MESSAGE))
	return 1;


    result = nextFloat(theVal, next, fileName, dataLine, lineNo, true, -FLT_MAX);
    result2 = nextFloat(theVal2, next, fileName, dataLine, lineNo, true, -FLT_MAX);

    if (result >= 0 && result2 >=0)
	nextStartEndDates(start, end, next, fileName, lineNo, dataLine, theCal);

    // if dates were messed up, then skip the record
    if (result == 1 || result2 ==1)
	return 1;


    return 0;
}


// ----------------------------------------------------------------
int  
LgFrSceFlatFileMgr::readCsvPartFloatVector(
    WitRun * const theWitRun,            // WIT environment    
    const int nPeriods,                  // Number of periods  
    std::string & pdf_PartName,            // pdf_PartName to be returned
    float *  floatVec,                   // floatVector to be returned
    std::ifstream & inFile,                    // An open stream
    const std::string & fileName,          // for messaging
    std::string& dataLine,
    long & lineNo,                       // for messaging
    const LgFrMultiPlantHelper & mpHelper,
    const int doYouNeedIt,               // Use one of MANDATORY, 
                                         // PURELY_OPTIONAL
                                         // or OPTIONAL_WITH_MESSAGE
    const float lowerLimit,              // data lower limits
    const float upperLimit)              // data upper limits
{
  int t = 0;
 int result;

 std::getline( inFile, dataLine );
 lineNo ++;

 dataLine = sce::strip( dataLine );

//  skip blanks or comments *
 if ((dataLine[0] == '*') || dataLine.empty())
     return -2;
     
 SCETokenizer next(dataLine);

// check if the line contains any illegal characters
    if ( containsIllegalCharacters( dataLine )) {
      (*sceErrFacility_)("IllegalCharacter",MclArgList() << fileName << (int)lineNo << dataLine);
    }

 
 // get the partname
 std::string mfgPartName =  nextQuotedString(next, result, fileName, 
					   dataLine, lineNo, OPTIONAL_WITH_MESSAGE);
 if (result < 0)
     return -1;


// get the pdf
 std::string pdf(nextQuotedString(next, result, fileName, dataLine, 
				lineNo, MANDATORY));

 pdf_PartName = mpHelper.pdfPartname(mfgPartName, pdf);
 
// test to see that its a valid partName
 if (! mpHelper.isPartValid( theWitRun, mfgPartName, pdf, fileName, 
			     dataLine, lineNo, doYouNeedIt))
     return 0;

// read the float values
 for (t = 0; t<nPeriods; t++) {
     if (-1 == nextFloat(floatVec[t], next, fileName, dataLine, lineNo,
			 false, lowerLimit, upperLimit))
	 break;
 }
 
 return t;

}


// ----------------------------------------------------------------
int  
LgFrSceFlatFileMgr::readCsvOperationFloatVector(
    WitRun * const theWitRun,            // WIT environment    
    const int nPeriods,                  // Number of periods  
    std::string & pdf_OperationName,       // pdf_OperationName to be returned
    float *  floatVec,                   // floatVector to be returned
    std::ifstream & inFile,                    // An open stream
    const std::string & fileName,          // for messaging
    std::string& dataLine,
    long & lineNo,                       // for messaging
    const LgFrMultiPlantHelper & mpHelper,
    const int doYouNeedIt,               // Use one of MANDATORY, 
                                         // PURELY_OPTIONAL
                                         // or OPTIONAL_WITH_MESSAGE
    const float lowerLimit,              // data lower limits
    const float upperLimit)              // data upper limits
{

 int t = 0;
 int result;

 std::getline( inFile, dataLine );
 lineNo ++;

 dataLine = sce::strip( dataLine );

//  skip blanks or comments *
 if ((dataLine[0] == '*') || dataLine.empty())
     return -2;
     
 SCETokenizer next(dataLine);

// check if the line contains any illegal characters
    if ( containsIllegalCharacters( dataLine )) {
      (*sceErrFacility_)("IllegalCharacter",MclArgList() << fileName << (int)lineNo << dataLine);
    }

 
 // get the operation name
 std::string operationName =  nextQuotedString(next, result, fileName, 
					   dataLine, lineNo, OPTIONAL_WITH_MESSAGE);
 if (result < 0)
     return -1;


// get the pdf
 std::string pdf(nextQuotedString(next, result, fileName, dataLine, 
				lineNo, MANDATORY));

 pdf_OperationName = mpHelper.pdfOperationName(operationName, pdf);

 
// test to see that its a valid partName
 if (! mpHelper.isOperationValid( theWitRun, pdf_OperationName, fileName, 
			     dataLine, lineNo, doYouNeedIt))
     return 0;

// read the float values
 for (t = 0; t<nPeriods; t++) {
     if (-1 == nextFloat(floatVec[t], next, fileName, dataLine, lineNo,
			 false, -FLT_MAX))
	 break;
 }
 
 return t;

}

//  -----------------------------------------------------------------
// This method tokenizes based on four characters delimiters:
// a space, double quote, comma, and end-of-line.
//
int 
LgFrSceFlatFileMgr::nextFloat(
    float & theValue,
    SCETokenizer & next,
    const std::string & fileName,
    const std::string & dataLine,
    const long & lineNo,
    const bool Mandatory,
    const float lowerLimit,
    const float upperLimit)
{
  // the four char delimiters
  char dataDelim[] = " \",\n"; 
  double d;
  
  std::string token = next(dataDelim);
  if (token.empty())   {
    if (Mandatory)  {
      (*sceErrFacility_)("MissingData",MclArgList() << "float" << fileName << (int) lineNo << dataLine);
    }
    return -1;
  }
  
  // convert the  token into a float
  if (! sce::fromString( token, d))  {
    (*sceErrFacility_)("InvalidDataType",MclArgList() << "float" << fileName << (int) lineNo << dataLine);
  }
  
  theValue = (float) d;
  
  // Check to see if value is in range
  if (theValue < lowerLimit) {
    (*sceErrFacility_)("OutOfRangeFloatWithBound",MclArgList() << fileName << (int) lineNo << dataLine << 
		       theValue << "Lower limit" << lowerLimit << "");
  }
  if (theValue > upperLimit) {
    (*sceErrFacility_)("OutOfRangeFloatWithBound",MclArgList() << fileName << (int) lineNo << dataLine 
		       << theValue << "Upper limit" << upperLimit << "");
  }
  
  // If you get here then everything is OK
  return 0;
  
}


//  --------------------------------------------------------------
int 
LgFrSceFlatFileMgr::nextInt(
    int & theValue,
    SCETokenizer & next,
    const std::string & fileName,
    const std::string & dataLine,
    const long & lineNo,
    const bool Mandatory,
    const int lowerLimit,
    const int upperLimit)
{
  // four char delimiters
  char dataDelim[] = " \",\n"; 
  long lng;
  
  std::string token = next(dataDelim);
  if (token.empty())   {
    if (Mandatory)  {
      (*sceErrFacility_)("MissingData",MclArgList() 
			 << "int" 
			 << fileName 
			 << (int) lineNo
			 << dataLine);
    }
    return -1;
  }
  
  // convert the  token into an int
  if (!sce::fromString( token, (token, lng)))  {
    (*sceErrFacility_)("InvalidDataType",MclArgList() 
		       << "integer" 
		       << fileName 
		       << (int) lineNo 
		       << dataLine);
  }
  
  theValue = (int) lng;
  
  // Check to see if value is in range
  if (theValue < lowerLimit) {
    (*sceErrFacility_)("OutOfRangeIntWithBound",MclArgList() 
		       << fileName 
		       << (int) lineNo 
		       << dataLine 
		       << theValue 
		       << "Lower limit" 
		       << lowerLimit 
		       << "");
  }
  if (theValue > upperLimit) {
    (*sceErrFacility_)("OutOfRangeIntWithBound",MclArgList() 
		       << fileName 
		       << (int) lineNo 
		       << dataLine 
		       << theValue 
		       << "Upper limit" 
		       << upperLimit 
		       << "");
  }
  
  // If you get here then everything is OK
  return 0;
  
}




//  ---------------------------------------------------------------------
//  Utility to determine if a floatVec is non-zero
//  --------------------------------------------------------------------- 

bool
LgFrSceFlatFileMgr::isFloatVecNonZero(
    const float * theVector,      // the vector itself
    const int vLength)   // output stream (already opened)
{
  int t = 0; // Pulled out of the for below by RW2STL
  for (t=0; t<vLength; t++) {
    if (theVector[t] < -0.0001 || theVector[t] > 0.0001)
      return true;
  }
   return false;
}




//  -------------------------------------------------------------

// nextStartEndDates: 
//    return codes:
//        1 if record is rejected
//       -1 if record not populated and OK  (defaults are used)
//        0 if record populated and OK
// ---------------------------------------------------------
int 
LgFrSceFlatFileMgr::nextStartEndDates(
    int & start,
    int & end,
    SCETokenizer & next,
    const std::string & fileName,
    long & lineNo,
    const std::string & dataLine,
    const LgFrCalendar & theCal)
{


    char dataDelim[] = " \",\n"; 

    int nPeriods = theCal.nPeriods();
    std::string token;

    start = 0;
    end = nPeriods - 1;

// read the start and end dates and make sure they're ok

//  if the line is blank then defaults are assumed.
    if ((token = next(dataDelim)).empty())   
	return -1;

    LgFrDatetime startDate(parseDateString(token, theCal));
    if (! startDate.isValid())  { (*sceErrFacility_)("InvalidDate",MclArgList() << "start date" 
						     << fileName << (int) lineNo << dataLine);
      return 1;
    }
    start = theCal.earlyEffectivePeriod(startDate);
    
    if ((token = next(dataDelim)).empty())   
	return -1;

    LgFrDatetime endDate(parseDateString(token, theCal));
    if (! endDate.isValid())  {
      (*sceErrFacility_)("InvalidDate",MclArgList() << "late effectivity date" << fileName 
			 << (int) lineNo << dataLine);
      return 1;
    }
    end = theCal.lateEffectivePeriod(endDate);

    if (startDate > endDate) {
      (*sceErrFacility_)("BadDate",MclArgList() << fileName << (int) lineNo << dataLine);
      return 1;
    }

    if (start > end) {
      (*sceErrFacility_)("CollapsedEffectiveInterval",MclArgList() << fileName << (int) lineNo << dataLine);
      return 1;
    }

    return 0;
}

#if 0

//  -------------------------------------------------------------

// nextStartEndDates: 
//    return codes:
//        1 if record is rejected
//       -1 if record not populated and OK  (defaults are used)
//        0 if record populated and OK
// ---------------------------------------------------------
int 
LgFrSceFlatFileMgr::nextStartEndDates(
    int & start,
    int & end,
    SCETokenizer & next,
    const std::string & fileName,
    long & lineNo,
    const std::string & dataLine,
    const LgFrCalendar & theCal)
{


    char dataDelim[] = " \",\n"; 

    int nPeriods = theCal.nPeriods();
    std::string token;

    start = 0;
    end = nPeriods - 1;

// read the start and end dates and make sure they're ok

//  if the line is blank then defaults are assumed.
    if ((token = next(dataDelim)).empty())   
	return -1;

    LgFrDatetime startDate(parseDateString(token, theCal));
    if (! startDate.isValid())  {
      (*sceErrFacility_)("InvalidDate",MclArgList() 
			 << "start date" 
			 << fileName 
			 << (int) lineNo 
			 << dataLine);
      return 1;
    }
    start = theCal.earlyEffectivePeriod(startDate);
    
    if ((token = next(dataDelim)).empty())   
	return -1;

    LgFrDatetime endDate(parseDateString(token, theCal));
    if (! endDate.isValid())  {
      (*sceErrFacility_)("InvalidDate",MclArgList() 
			 << "late effectivity date" 
			 << fileName 
			 << (int) lineNo 
			 << dataLine);
      return 1;
    }
    end = theCal.lateEffectivePeriod(endDate);

    if (startDate > endDate) {
      (*sceErrFacility_)("BadDate",MclArgList() 
			 << fileName 
			 << (int) lineNo 
			 << dataLine);
      return 1;
    }

    return 0;
}
#endif


//  ---------------------------------------------------------------------
//  Utility to print a float vector to an output stream
//  --------------------------------------------------------------------- 
void 
LgFrSceFlatFileMgr::writeFloatVector(
    std::ofstream & theStream,   // output stream (already opened)
    int    vLength,         // lenght of the vector (nPeriods?)
    float * theVector,      // the vector itself
    int precision,          // number of digits to the right of the decimal
    int totalSpace)         // total length of the 'formatted' field
{
   std::string blankVector(totalSpace, ' ');

   int t = 0; // Pulled out of the for below by RW2STL
   for (t=0; t<vLength; t++) 
   {
      std::string sNum(sce::stringFrom(theVector[t], precision));
      int blankSpace = totalSpace - sNum.length();
      sNum.insert(0, blankVector.c_str(), blankSpace);
      theStream << sNum;
   }
   theStream << "\n";
}

//  ---------------------------------------------------------------------
//  Utility to print a Wit Boolean vector to an output stream
//  --------------------------------------------------------------------- 
void 
LgFrSceFlatFileMgr::writeCsvBoolVector(
    std::ofstream & theStream,   // output stream (already opened)
    int    vLength,         // lenght of the vector (nPeriods?)
    const witBoolean * theVector)      // the vector itself
{
   int t = 0; // Pulled out of the for below by RW2STL
   for (t=0; t<vLength; t++) 
     theStream << "," << theVector[t];

   theStream << "\n";
}



//  -------------------------------------------------------------------------------------
// **** writePartPdfRecord  Vector or Dated_Demands ... Or  multi_attribute_demand_class  ... automatically!!
//  -------------------------------------------------------------------------------------
int
LgFrSceFlatFileMgr::writePartPdfRecord(
    LgFrCalendar & theCal,
    std::string & partname, 
    std::string & pdf, 
    const float *  theVector,
    std::ofstream & theStream,   // output stream (already opened)
    int nPeriods, 
    int printIfZero)
{

  std::string leadingString = "\"" 
    + partname + "\",\"" 
    + pdf + "\"";

  writeFloatVecToStream(theCal, theStream, nPeriods, printIfZero, leadingString, theVector); 

  return 0;
}




//  -------------------------------------------------------------------------------------
// **** writeDbDump Vector or Dated_Demands ... Or  multi_attribute_demand_class  ... automatically!!
//  -------------------------------------------------------------------------------------
int
LgFrSceFlatFileMgr::writeDbDumpRecord(
    LgFrCalendar & theCal,
    std::string & partname, 
    std::string & pdf, 
    const char * attributeKeyword,
    const float *  theVector,
    std::ofstream & theStream,   // output stream (already opened)
    int nPeriods, 
    int printIfZero)
{

  std::string leadingString = "\"" 
    + partname + "\",\"" 
    + pdf + "\",\""
    + attributeKeyword + "\"";


  writeFloatVecToStream(theCal, theStream, nPeriods, printIfZero, leadingString, theVector); 
  return 0;
}






//  -------------------------------------------------------------------------------------
// **** writePegCritlistRecord
// Print to either multi_attribute_demand_class OR Dated_Demands format ... automatically
//  -------------------------------------------------------------------------------------
void 
LgFrSceFlatFileMgr::writePegCritListRecord(
    std::ofstream & theStream,   // output stream (already opened)
    LgFrMultiPlantHelper & mpHelper,
    LgFrCalendar & theCal,
    const std::string & partname,
    const std::string & sourceLoc,
    const std::string & demandName,
    const std::string & critpartname,
    const std::string & critpdf,
    int    demandPd, 
    int    critPd, 
    int    theRank)      // the vector itself
{

  std::string leadingString;


  mpHelper.populateLeadingString(partname,
				 sourceLoc,
				 demandName,
				 leadingString);

  leadingString += ",\"" 
    + critpartname + "\",\""
    + critpdf      + "\"";

    
  if (useDatedDemands_)  {
    // convert pds to dates
    std::string demandDate = theCal.yyyymmdd(theCal.periodStart(demandPd));
    std::string critDate = theCal.yyyymmdd(theCal.periodStart(critPd));
    theStream << leadingString << ","  << demandDate << "," << critDate << "," << theRank << "\n";
  }
  else {
    theStream << leadingString << "," << demandPd << "," << critPd << "," << theRank << "\n";
  }
  
  
}




//  -------------------------------------------------------------------------------------
// **** writeGpdPegRecord
// Print to either multi_attribute_demand_class OR Dated_Demands format ... automatically
//  -------------------------------------------------------------------------------------
void 
LgFrSceFlatFileMgr::writeGpdPegRecord(LgFrCalendar & theCal,
				      LgFrMultiPlantHelper & mpHelper,
				      const std::string & plannerPart, 
				      const std::string & geo, 
				      const std::string & peggedPart,
				      const std::string & peggedPdf, 
				      const float * theVector,
				      std::ofstream & theStream,   // output stream (already opened)
				      int nPeriods,
				      int printIfZero)
		   
{
  std::string leadingString;

  // start off the leading string with the GPD Keys
  mpHelper.populateLeadingStringGPD(plannerPart, geo, leadingString);

  leadingString += ",\"" 
      + peggedPart + "\",\""
      + peggedPdf + "\"";

  writeFloatVecToStream(theCal, theStream, nPeriods, printIfZero, leadingString, theVector);
}


//  -------------------------------------------------------------------------------------
// **** writeIndpPegRecord
// Print to either multi_attribute_demand_class OR Dated_Demands format ... automatically
//  -------------------------------------------------------------------------------------
void 
LgFrSceFlatFileMgr::writeIndpPegRecord(LgFrCalendar & theCal,
				      LgFrMultiPlantHelper & mpHelper,
				      const std::string & demandedPart, 
				      const std::string & demandedPdf, 
				      const std::string & demandName, 
				      const std::string & peggedPart,
				      const std::string & peggedPdf, 
				      const float * theVector,
				      std::ofstream & theStream,   // output stream (already opened)
				      int nPeriods,
				      int printIfZero)
{
  std::string leadingString;

  // Finish_me: Need to close on the design point for D2O logic for INDP demands
  // if D2O on INDP?
  //          then the original requestDate is part of the multi-attribute Key and the following will get it
  // else if D2O on INDP is false, the we should just use the commit date ...

  bool D2O_on_INDP = false;

  mpHelper.populateLeadingStringINDP(demandedPart, demandedPdf, demandName, leadingString);

  if (D2O_on_INDP) {
    int t;
    float pegQty;
    
    t = 0;
    for (t=0; t<nPeriods; t++) {
      pegQty = theVector[t];
      if (printIfZero || (pegQty >  0.0001) ||  (pegQty < -0.0001))    {
	theStream << 
	  leadingString << "," << 
	  theCal.yyyymmdd(theCal.periodStart(t)) << ",\"" << 
	  peggedPart << "\",\"" <<
	  peggedPdf << "\"," <<
	  theCal.yyyymmdd(theCal.periodStart(t)) << "," << 
	  pegQty << "\n";
      }
    }
  }

  else {
    leadingString += ",\"" 
      + peggedPart + "\",\""
      + peggedPdf + "\"";
    writeFloatVecToStream(theCal, theStream, nPeriods, printIfZero, leadingString, theVector);
  }
}


//  -------------------------------------------------------------------------------------
// **** writeIndpInterplantPegRecord
// Print to either multi_attribute_demand_class OR Dated_Demands format ... automatically
//  -------------------------------------------------------------------------------------
void 
LgFrSceFlatFileMgr::writeIndpInterplantPegRecord(LgFrCalendar & theCal,
						LgFrMultiPlantHelper & mpHelper,
						 const std::string & demandedPart, 
						 const std::string & demandedPdf, 
						 const std::string & demandName, 
						 const std::string & pn1,
						 const std::string & pdf1, 
						 const std::string & pn2,
						 const std::string & pdf2, 
						 const float * theVector,
						 std::ofstream & theStream, 
						 int nPeriods,
						 int printIfZero)
{
  
  std::string leadingString;
  
  // Finish_me: Need to close on the design point for D2O logic for INDP demands
  // if D2O on INDP?
  //          then the original requestDate is part of the multi-attribute Key and the following will get it
  // else if D2O on INDP is false, the we should just use the commit date ...

  bool D2O_on_INDP = false;

  mpHelper.populateLeadingStringINDP(demandedPart, demandedPdf, demandName, leadingString);
  
  if (D2O_on_INDP) {
    int t;
    float pegQty;

    t = 0;
    for (t=0; t<nPeriods; t++) {
      pegQty = theVector[t];
      if (printIfZero || (pegQty >  0.0001) ||  (pegQty < -0.0001))    {
	theStream << 
	  leadingString << "," << 
	  theCal.yyyymmdd(theCal.periodStart(t)) << ",\"" << 
	  pn1 <<  "\",\"" <<
	  pdf1  << "\",\"" << 
	  pn2 << "\",\"" <<
	  pdf2 << "\"," << 
	  theCal.yyyymmdd(theCal.periodStart(t)) << "," << 
	  pegQty << "\n";
      }
    }
  }
  else {
    leadingString += ",\"" 
      + pn1  + "\",\""
      + pdf1 + "\",\""
      + pn2  + "\",\""
      + pdf2 + "\"";
    
    writeFloatVecToStream(theCal, theStream, nPeriods, printIfZero, leadingString, theVector);
  }
    
}
  
  
  

//  -------------------------------------------------------------------------------------
// **** writeGpdInterplantPegRecord
// Print to either multi_attribute_demand_class OR Dated_Demands format ... automatically
//  -------------------------------------------------------------------------------------
void 
LgFrSceFlatFileMgr::writeGpdInterplantPegRecord(LgFrCalendar & theCal,
						LgFrMultiPlantHelper & mpHelper,
						const std::string & plannerPart, 
						const std::string & geo, 
						const std::string & peggedOrderingPart,
						const std::string & peggedOrderingPdf, 
						const std::string & peggedSupplyingPart,
						const std::string & peggedSupplyingPdf, 
						const float * theVector,
						std::ofstream & theStream,   // output stream (already opened)
						int nPeriods,
						int printIfZero)
{

  std::string leadingString;


  mpHelper.populateLeadingStringGPD(plannerPart, geo, leadingString);



  leadingString += ",\"" 
    + peggedOrderingPart  + "\",\"" 
    + peggedOrderingPdf   + "\",\""
    + peggedSupplyingPart + "\",\"" 
    + peggedSupplyingPdf  + "\""; 
  
  writeFloatVecToStream(theCal, theStream, nPeriods, printIfZero, leadingString, theVector);
}






//  --------------------------------------------------------------------- 
// This method tokenizes based on the comma and end-of-line characters.
// It then strips off everything preceeding the first " and everything following
// the last ", and the result is returned.

std::string
LgFrSceFlatFileMgr::nextQuotedString(
    SCETokenizer & next,
    int & result,
    const std::string & fileName,
    const std::string & dataLine,
    long lineNo,
    const int doYouNeedIt)
{

  result = 0;

  // get the first token, including junk like spaces and tabs
  std::string token = next(",\n");
  
  token = sce::extractQuotedPart( token );

  if (doYouNeedIt == MANDATORY && token.empty()) {
    (*sceErrFacility_)("MissingData",MclArgList() << "quoted string" << fileName << (int) lineNo << dataLine);
    // this will exit
  }

  if ( token.empty())    {
    if (doYouNeedIt == OPTIONAL_WITH_MESSAGE)
      (*sceErrFacility_)("MissingDataWarning",MclArgList() << "quoted string" << fileName << (int) lineNo << dataLine);
    result = -1;
  }
    

  return token;
}








// append an given illegal character to the set
void
LgFrSceFlatFileMgr::appendToTheSetOfIllegalCharacters( const std::string newIllegalChar )
{
  setOfIllegalCharacters_.push_back( newIllegalChar );
}

// return the number entries (counting duplicates)
// in the set of illegal characters
int
LgFrSceFlatFileMgr::sizeOfTheSetOfIllegalCharacters ()
{
  return setOfIllegalCharacters_.size();
}


// screen a string for any illegal characters
// 1 = an illegal character was found (contains = true)
// 0 = no illegal characters were found (contains = false)
int
LgFrSceFlatFileMgr::containsIllegalCharacters (const std::string theString)
{
  int nIllegalChars = setOfIllegalCharacters_.size();
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nIllegalChars; i++) {
    // if there's an illegal char embedded in theString, bail out
      if ( theString.find_first_of( setOfIllegalCharacters_[i] ) != std::string::npos)
      return 1;
  }
  // if you make it here, there were no illegal chars embedded in theString
  return 0;

}


// set methods for private member data (don't need gets for these as they can come from SetOfParameters)
void
LgFrSceFlatFileMgr::useDatedDemands(bool useDatedDemands)  {
  useDatedDemands_ = useDatedDemands;
}

void
LgFrSceFlatFileMgr::useMultiAttributeDemand(bool useMultiAttributeDemand)  {
  useMultiAttributeDemand_ = useMultiAttributeDemand;
}

void 
LgFrSceFlatFileMgr::numDemandAttributes(int numDemandAttributes)  {
  numDemandAttributes_ = numDemandAttributes;
}

void 
LgFrSceFlatFileMgr::demandTypeKeyFieldNum(int demandTypeKeyFieldNum)  {
  demandTypeKeyFieldNum_ = demandTypeKeyFieldNum;
}



void 
LgFrSceFlatFileMgr::multiAttributeDemandSeparator(const std::string & multiAttributeDemandSeparator)  {
  multiAttributeDemandSeparator_ = multiAttributeDemandSeparator;
}




void
LgFrSceFlatFileMgr::setGlobalCalendarFormat(const std::string & calendarFormat)
{
    globalCalendarFormat_ = calendarFormat;
    sce::toUpper(globalCalendarFormat_);
}

std::string 
LgFrSceFlatFileMgr::getGlobalCalendarFormat()
{
    return globalCalendarFormat_;
}

LgFrDatetime
LgFrSceFlatFileMgr::parseDateString(
    const std::string & dateString, 
    const LgFrCalendar & theCal)
{
  // date strings come in 3 flavors
  // U = mm/dd/yyyy
  // E = dd/mm/yyyy
  // G = yyyymmdd with no slashes. The default.
  // and can equal PAST or FUTURE
  //

                            
  // Note: this routine will recognize PAST and FUTURE as valid dates
  // regardless of the calendarFormat.
  // NOTE: Sorry for hardcoding these dates, but its not easy to get a 
  // default for PAST and FUTURE otherwise.  In fact, its impossible
  // to get the max legal LgFrDatetime without knowing how its implemented!
  if ( ! sce::compareStringsCaseIns( dateString, "PAST" )) {
    std::string pastDate("19701225");
    return theCal.yyyymmdd(pastDate);
  }

  if ( ! sce::compareStringsCaseIns( dateString, "FUTURE" )) {
    std::string futureDate("20361231");
    return theCal.yyyymmdd(futureDate);
  }

  // Ensure that 
  //    (a) the date is of length 8 (FINISH_ME: multi-byte issues for future??)
  //    (b) the string consists only of numerals
  //    (b) date is no earlier than Jan 1, 1970 (SCE's self imposed lower limit)
  //    (c) date is no later  than Dec 31, 2036 (SCE's self imposed upper limit)
  // If any of these are violated, then we create a KNOWN bad date (our worst 
  // fears are that a bad date somehow turns good in RW's eyes)
  bool allDigits = true;
  for( size_t i = 0; i < dateString.size(); i++ )
      if( !isdigit( dateString[i] ) )
      {
          allDigits = false;
          break;
      }
  if (( dateString.length() != 8 ) 
      || (!allDigits)
      || (dateString < "19700101")) {
    std::string badDate("99999999");
    return theCal.yyyymmdd(badDate);
  }

  // If the date is greater than 20361231, then make it future date (valid)
  if (dateString > "20361231") {
    std::string futureDate("20361231");
    return theCal.yyyymmdd(futureDate);
  }

   
  if (globalCalendarFormat_ != "G")  {
    LgFrDatetime theDate(dateString.c_str());
    return theDate;
  }
    
  return theCal.yyyymmdd(dateString);

}

// method to return the i/o log manager
LgFrSceIOLogMgr&
LgFrSceFlatFileMgr::sceIOLogManager()
{
  return sceIOLogMgr_;
}


// Destructor 
LgFrSceFlatFileMgr::~LgFrSceFlatFileMgr()
{
}


// Assignment operator.
LgFrSceFlatFileMgr&
LgFrSceFlatFileMgr::operator=(
   const LgFrSceFlatFileMgr& rhs)
{
   if (this != &rhs) {           // Check for assignment to self
     setOfIllegalCharacters_ = rhs.setOfIllegalCharacters_;
     useMultiAttributeDemand_ = rhs.useMultiAttributeDemand_;
     numDemandAttributes_ = rhs.numDemandAttributes_;
     demandTypeKeyFieldNum_ = rhs.demandTypeKeyFieldNum_;
     multiAttributeDemandSeparator_ = rhs.multiAttributeDemandSeparator_;
     sceIOLogMgr_ = rhs.sceIOLogMgr_;
     sceErrFacility_ = rhs.sceErrFacility_;
   }

   return *this;
} 


//  copy constructor
LgFrSceFlatFileMgr::LgFrSceFlatFileMgr(
				       const LgFrSceFlatFileMgr& source )
: setOfIllegalCharacters_ (source.setOfIllegalCharacters_),
  globalCalendarFormat_(source.globalCalendarFormat_),
  useMultiAttributeDemand_(source.useMultiAttributeDemand_),
  numDemandAttributes_(source.numDemandAttributes_),
  demandTypeKeyFieldNum_(source.demandTypeKeyFieldNum_),
  multiAttributeDemandSeparator_(source.multiAttributeDemandSeparator_),
  sceIOLogMgr_(source.sceIOLogMgr_),
  sceErrFacility_(source.sceErrFacility_)
{
}

// Default constructor
LgFrSceFlatFileMgr::LgFrSceFlatFileMgr()
: setOfIllegalCharacters_ (0),
  globalCalendarFormat_("G"),
  useMultiAttributeDemand_(0),
  numDemandAttributes_(1),
  demandTypeKeyFieldNum_(1),
  multiAttributeDemandSeparator_("%"),
  sceIOLogMgr_(),
  sceErrFacility_(0)
{
}

#if 0

#ifdef NDEBUG
#undef NDEBUG
#endif

void
LgFrSceFlatFileMgr::test()
{


  

} 
#endif
@


1.20
log
@fixed some formatting errors in indpInterplantPegging
@
text
@d1390 1
a1390 1
    + critpdf      + "\",";
@


1.19
log
@fixed compatability issues between version 5 and 6
@
text
@d1548 3
a1550 3
      + pn1 + "\",\""
      + pdf1 + "\""
      + pn2 + "\",\""
d1588 2
a1589 2
    + peggedOrderingPart + "\",\"" 
    + peggedOrderingPdf  + "\",\""
d1591 1
a1591 1
    + peggedSupplyingPdf + "\""; 
@


1.18
log
@fix for backward compat to sce5
@
text
@a1435 2


a1438 4




d1458 1
a1458 1
  // which requestDate do we pull and write???
a1460 1
  mpHelper.populateLeadingStringINDP(demandedPart, demandedPdf, demandName, leadingString);
d1463 3
a1465 2
  int t;
  float pegQty;
d1467 16
a1482 12
  t = 0;
  for (t=0; t<nPeriods; t++) {
    pegQty = theVector[t];
    if (printIfZero || (pegQty >  0.0001) ||  (pegQty < -0.0001))    {
      theStream << 
	leadingString << "," << 
	theCal.yyyymmdd(theCal.periodStart(t)) << ",\"" << 
	peggedPart << "\",\"" <<
	peggedPdf << "\"," <<
	theCal.yyyymmdd(theCal.periodStart(t)) << "," << 
	pegQty << "\n";
      
a1484 1
  
d1486 6
d1503 10
a1512 10
						const std::string & sourceLoc, 
						const std::string & demandId, 
						const std::string & pn1,
						const std::string & pdf1, 
						const std::string & pn2,
						const std::string & pdf2, 
						const float * theVector,
						std::ofstream & theStream, 
						int nPeriods,
						int printIfZero)
d1514 1
a1514 1

d1516 2
a1517 2

  // which requestDate do we pull and write???
a1519 1
  mpHelper.populateLeadingStringINDP(demandedPart, sourceLoc, demandId, leadingString);
d1522 1
a1522 2
  int t;
  float pegQty;
d1524 20
a1543 13
  t = 0;
  for (t=0; t<nPeriods; t++) {
    pegQty = theVector[t];
    if (printIfZero || (pegQty >  0.0001) ||  (pegQty < -0.0001))    {
      theStream << 
	leadingString << "," << 
	theCal.yyyymmdd(theCal.periodStart(t)) << ",\"" << 
	pn1 <<  "\",\"" <<
	pdf1  << "\",\"" << 
	pn2 << "\",\"" <<
	pdf2 << "\"," << 
	theCal.yyyymmdd(theCal.periodStart(t)) << "," << 
	pegQty << "\n";
d1546 10
d1557 3
a1559 3



@


1.17
log
@convert capacity datamodel to dated intervals
@
text
@d22 1
a22 2

// SCE 6.1
d56 1
a56 1
// **** writeDemandRecord
d76 3
a78 2
  // which requestDate do we pull and write???
  // if D2O on INDP?
d80 1
d82 5
a86 2
  // else if D2O on INDP is false, the we should just use the commit date ...
  writeFloatVecToStreamDoubleDated(theCal, theStream, vLength, printIfZero, leadingString, theVector);
d91 1
a91 1
// **** writeDemandRecord
a153 1

@


1.16
log
@mfo is folded into featratio file
@
text
@d301 1
a301 5
    (*sceErrFacility_)("InvalidDate",MclArgList() 
		       << "start date" 
		       << fileName 
		       << (int) lineNo 
		       << dataLine);
a304 1

d309 1
a309 5
      (*sceErrFacility_)("MissingData",MclArgList() 
			 << "float" 
			 << fileName 
			 << (int) lineNo
			 << dataLine);
d316 1
a316 5
    (*sceErrFacility_)("InvalidDataType",MclArgList() 
		       << "float" 
		       << fileName 
		       << (int) lineNo 
		       << dataLine);
d321 1
a321 1
  // Check to see if value is in range
d323 1
a323 8
    (*sceErrFacility_)("OutOfRangeFloatWithBound",MclArgList() 
		       << fileName 
		       << (int) lineNo 
		       << dataLine 
		       << theVal
		       << "Lower limit" 
		       << lowerLimit 
		       << "");
d326 1
a326 8
    (*sceErrFacility_)("OutOfRangeFloatWithBound",MclArgList() 
		       << fileName 
		       << (int) lineNo 
		       << dataLine 
		       << theVal 
		       << "Upper limit" 
		       << upperLimit 
		       << "");
d431 43
a501 2

//  skip blanks or comments *
a504 1

a505 2

// check if the line contains any illegal characters
d515 1
a515 3
    if (! mpHelper.isPartValid(theWitRun, 
			       mfgPartName, 
			       pdf, fileName, dataLine, lineNo, OPTIONAL_WITH_MESSAGE))
d1156 2
a1157 6
    if (! startDate.isValid())  {
      (*sceErrFacility_)("InvalidDate",MclArgList() 
			 << "start date" 
			 << fileName 
			 << (int) lineNo 
			 << dataLine);
d1167 2
a1168 5
      (*sceErrFacility_)("InvalidDate",MclArgList() 
			 << "late effectivity date" 
			 << fileName 
			 << (int) lineNo 
			 << dataLine);
d1174 1
a1174 4
      (*sceErrFacility_)("BadDate",MclArgList() 
			 << fileName 
			 << (int) lineNo 
			 << dataLine);
d1179 1
a1179 4
      (*sceErrFacility_)("CollapsedEffectiveInterval",MclArgList() 
			 << fileName 
			 << (int) lineNo 
			 << dataLine);
a1598 1

a1600 1
  
d1603 1
a1603 5
    (*sceErrFacility_)("MissingData",MclArgList() 
		       << "quoted string" 
		       << fileName 
		       << (int) lineNo 
		       << dataLine);
d1609 1
a1609 5
      (*sceErrFacility_)("MissingDataWarning",MclArgList() 
			 << "quoted string" 
			 << fileName 
			 << (int) lineNo 
			 << dataLine);
@


1.15
log
@fixed array bounds checks
@
text
@d995 1
a995 5
      (*sceErrFacility_)("MissingData",MclArgList() 
			 << "float" 
			 << fileName 
			 << (int) lineNo
			 << dataLine);
d1002 1
a1002 5
    (*sceErrFacility_)("InvalidDataType",MclArgList() 
		       << "float" 
		       << fileName 
		       << (int) lineNo 
		       << dataLine);
d1009 2
a1010 8
    (*sceErrFacility_)("OutOfRangeFloatWithBound",MclArgList() 
		       << fileName 
		       << (int) lineNo 
		       << dataLine 
		       << theValue 
		       << "Lower limit" 
		       << lowerLimit 
		       << "");
d1013 2
a1014 8
    (*sceErrFacility_)("OutOfRangeFloatWithBound",MclArgList() 
		       << fileName 
		       << (int) lineNo 
		       << dataLine 
		       << theValue 
		       << "Upper limit" 
		       << upperLimit 
		       << "");
@


1.14
log
@more dated fixes
@
text
@d24 1
a112 30

// parse out the demandType (TINP, INDP) 
int 
LgFrSceFlatFileMgr::demandType(const std::string & demandName)
{
  
  // multi_attribute_demand
  assert (useMultiAttributeDemand_);

  SCETokenizer next(demandName);
  std::string token;

  int tokCnt=0;
  for (tokCnt=0; tokCnt<demandTypeKeyFieldNum_; tokCnt++) {
    token =  next(multiAttributeDemandSeparator_.c_str());
    
    if (token.empty()) {
      return DEMAND_TYPE_ERROR;
    }
  }
  if (token == "INDP")
    return DEMAND_TYPE_INDP;
  if (token == "TINP")
    return DEMAND_TYPE_TINP;
  
  return DEMAND_TYPE_ERROR;
}



d220 39
a360 5
// =============================
// =============================
//     END new      SCE 6.1
// =============================
// =============================
d362 28
d391 2
d394 31
a425 7
// ----------------------------------------------------------------
void
LgFrSceFlatFileMgr::setErrFacility(MclFacility * existingFacility)
{
  // in effect, borrowing an existing message facility
  sceErrFacility_ = existingFacility;
}
a426 5
MclFacility *
LgFrSceFlatFileMgr::getErrFacility()
{
  return sceErrFacility_;
}
d428 27
d456 1
d458 6
d499 3
a501 7
    
// get the pdf partname

    mfgPartName = nextQuotedString(next, result, fileName, dataLine, 
				   lineNo, MANDATORY);
    pdf = nextQuotedString(next, result, fileName, dataLine, 
			   lineNo, MANDATORY);
d506 1
a506 5
			       pdf,
			       fileName, 
			       dataLine, 
			       lineNo, 
			       OPTIONAL_WITH_MESSAGE))
d520 10
d531 15
a545 1
    return 0;
d554 2
a1651 96
// Multi-Attribute Demand Classes.   
//    try this ... can go either way
//    demandName = flatFileManager.nextDemandGeoOrMultiAttributeQuotedString(next, result, fileName, dataLine, lineNo, MANDATORY);

//  --------------------------------------------------------------------- 
// This method is a test of the potential for SCE to deal directly with
// used by ==>  
//             processDemandFile
//             process61TopLevelToOptionalFeatureFile
//             processIndependentDemandFile (with ifdef MULTI_ATTRIBUTE_DEMAND_CLASS)
//             
std::string
LgFrSceFlatFileMgr::nextQuotedDemandString(
    SCETokenizer & next,
    int & result,
    const std::string & fileName,
    const std::string & dataLine,
    long lineNo,
    const int doYouNeedIt)
{


  result = 0;

  // multi_attribute_demand
  if (useMultiAttributeDemand_) {

    std::string finalToken = "";

    int tokCnt=0;
    for (tokCnt=0; tokCnt<numDemandAttributes_; tokCnt++) {

      // get the first token, including junk like spaces and tabs
      std::string token = next(",\n");
      
      token = sce::extractQuotedPart( token );
      
      if (doYouNeedIt == MANDATORY && token.empty()) {
	(*sceErrFacility_)("MissingData",MclArgList() 
			   << "quoted string in MultiAttributeDemand" 
			   << fileName 
			   << (int) lineNo 
			   << dataLine);
	// this will exit
      }
      
      if ( token.empty())    {
	if (doYouNeedIt == OPTIONAL_WITH_MESSAGE)
	  (*sceErrFacility_)("MissingDataWarning",MclArgList() 
			     << "quoted string in MultiAttributeDemand" 
			     << fileName 
			     << (int) lineNo 
			     << dataLine);
	result = -1;
      }
      
      if (tokCnt > 0)
	finalToken += multiAttributeDemandSeparator_ + token;
      else 
	finalToken += token;
    }
    return finalToken;
  }



  // single attribute demand
  else {
    // get the next token, including junk like quotes, spaces, and tabs
    std::string token = next(",\n");
    
    token = sce::extractQuotedPart( token );
    
    if (doYouNeedIt == MANDATORY && token.empty()) {
      (*sceErrFacility_)("MissingData",MclArgList() 
			 << "quoted string" 
			 << fileName 
			 << (int) lineNo 
			 << dataLine);
      // this will exit
    }
    
    if ( token.empty())    {
      if (doYouNeedIt == OPTIONAL_WITH_MESSAGE)
	(*sceErrFacility_)("MissingDataWarning",MclArgList() 
			   << "quoted string" 
			   << fileName 
			   << (int) lineNo 
			   << dataLine);
      result = -1;
    }
    return token;
  }

}

@


1.13
log
@pegging and sub enablement for 6.1
@
text
@d1552 5
@


1.12
log
@6.1 prep commit ... many things in here
@
text
@d16 95
d164 1
d166 1
a248 88




// ----------------------------------------------------------------
void
LgFrSceFlatFileMgr::setErrFacility(MclFacility * existingFacility)
{
  // in effect, borrowing an existing message facility
  sceErrFacility_ = existingFacility;
}

MclFacility *
LgFrSceFlatFileMgr::getErrFacility()
{
  return sceErrFacility_;
}



int  
LgFrSceFlatFileMgr::readCsvPartFloatDatedRecord(
    WitRun * const theWitRun,   // WIT environment    
    const int nPeriods,         // Number of periods  
    std::string & pdf_PartName,   // pdf_PartName to be returned
    const LgFrCalendar & theCal,
    float & theVal,
    int & start,
    int & end,
    std::ifstream & inFile,             // An open stream
    const std::string & fileName,  // For error messaging
    std::string & dataLine,
    long & lineNo,
    const LgFrMultiPlantHelper & mpHelper)
{

    std::string pdf;
    std::string mfgPartName;
    int result = 0;

    std::getline( inFile, dataLine );
    lineNo++;

//  skip blanks or comments *
    dataLine = sce::strip( dataLine );
    if ((dataLine[0] == '*') || dataLine.empty())
	return -2;

    SCETokenizer next(dataLine);

// check if the line contains any illegal characters
    if ( containsIllegalCharacters( dataLine )) {
      (*sceErrFacility_)("IllegalCharacter",MclArgList() << fileName << (int)lineNo << dataLine);
    }

    
// get the pdf partname

    mfgPartName = nextQuotedString(next, result, fileName, dataLine, 
				   lineNo, MANDATORY);
    pdf = nextQuotedString(next, result, fileName, dataLine, 
			   lineNo, MANDATORY);
    pdf_PartName = mpHelper.pdfPartname(mfgPartName, pdf);
    
    if (! mpHelper.isPartValid(theWitRun, 
			       mfgPartName, 
			       pdf,
			       fileName, 
			       dataLine, 
			       lineNo, 
			       OPTIONAL_WITH_MESSAGE))
      return 1;
    
    
    result = nextFloat(theVal, next, fileName, dataLine, lineNo, true, -FLT_MAX);
    
    
    if (result >= 0)
      result = nextStartEndDates(start, end, next, fileName, lineNo, dataLine, theCal);

    // if dates were messed up, then skip the record
    if (result == 1)
	return 1;


    return 0;
}

d351 95
a1273 88
// SCE 6.1
//  -------------------------------------------------------------------------------------
// **** writeDemandRecord
// Print to either multi_attribute_demand_class OR Dated_Demands format ... automatically
//  -------------------------------------------------------------------------------------
void 
LgFrSceFlatFileMgr::writeDemandRecord(
    std::ofstream & theStream,   // output stream (already opened)
    LgFrMultiPlantHelper & mpHelper,
    LgFrCalendar & theCal,
    const std::string & partname,
    const std::string & pdf,
    const std::string & demandName,
    int    vLength,         // lenght of the vector (nPeriods?)
    const float * theVector,      // the vector itself
    bool printIfZero,
    int precision,          // number of digits to the right of the decimal
    int totalSpace)         // total length of the 'formatted' field
{

  std::string leadingString;


  mpHelper.populateLeadingString(partname, pdf, demandName, leadingString);

  writeFloatVecToStream(theCal, theStream, vLength, printIfZero, leadingString, theVector);
}




// SCE 6.1
//  -------------------------------------------------------------------------------------
// **** writeDemandRecord
// Print to either multi_attribute_demand_class OR Dated_Demands format ... automatically
//  -------------------------------------------------------------------------------------
void 
LgFrSceFlatFileMgr::writeDemandRecordINDP(
    std::ofstream & theStream,   // output stream (already opened)
    LgFrMultiPlantHelper & mpHelper,
    LgFrCalendar & theCal,
    const std::string & partname,
    const std::string & pdf,
    const std::string & demandName,
    int    vLength,         // lenght of the vector (nPeriods?)
    const float * theVector,      // the vector itself
    bool printIfZero,
    int precision,          // number of digits to the right of the decimal
    int totalSpace)         // total length of the 'formatted' field
{

  std::string leadingString;

  // which requestDate do we pull and write???
  // if D2O on INDP?
  //          then the original requestDate is part of the multi-attribute Key and the following will get it
  mpHelper.populateLeadingStringINDP(partname, pdf, demandName, leadingString);
  // else if D2O on INDP is false, the we should just use the commit date ...
  writeFloatVecToStreamDoubleDated(theCal, theStream, vLength, printIfZero, leadingString, theVector);
}

// SCE 6.1
//  -------------------------------------------------------------------------------------
// **** writeDemandRecord
// Print to either multi_attribute_demand_class OR Dated_Demands format ... automatically
//  -------------------------------------------------------------------------------------
void 
LgFrSceFlatFileMgr::writeGpdDemandRecord(
    std::ofstream & theStream,    // output stream (already opened)
    LgFrMultiPlantHelper & mpHelper,
    LgFrCalendar & theCal,
    const std::string & partname,
    const std::string & demandName,
    int    vLength,               // length of the vector (nPeriods?)
    const float * theVector,      // the vector itself
    bool printIfZero,
    int precision,                // number of digits to the right of the decimal
    int totalSpace)               // total length of the 'formatted' field
{

  std::string leadingString;

  mpHelper.populateLeadingStringGPD(partname, demandName, leadingString);

  writeFloatVecToStream(theCal, theStream, vLength, printIfZero, leadingString, theVector);
}


d1312 1
a1312 1
    theStream << leadingString << demandDate << "," << critDate << "," << theRank << "\n";
d1315 1
a1315 1
    theStream << leadingString << demandPd << "," << critPd << "," << theRank << "\n";
@


1.11
log
@more fixes for 6.1
@
text
@d1 1
a1 1

d15 141
d255 2
a256 1
					       int & thePeriod,
d276 1
a276 1
  if ((token = next(dataDelim)).empty())   
d280 1
a280 1
  LgFrDatetime theDate(parseDateString(token, theCal));
a289 5
  // see what period it falls in
  // NOTE: this method uses period() ... which adhere's to strict calendar inclusive dates
  // NOTE: you can also use roundedPeriod() 
  thePeriod = theCal.period(theDate);  
  
d1134 1
a1134 24
  // dated demands
  if (useDatedDemands_)  {
    // loop though the time vector and figure out which to print
    int t = 0; 
    for (t=0; t<nPeriods; t++) {
      bool doWePrintThisElement = false;
      float theVal = theVector[t];
      if ((theVal < 0.0001) && (theVal > -0.0001)) {
	if (printIfZero) { 
	  doWePrintThisElement = true;
	  theVal = 0.0;
	}
      }
      else // it's a non-zero value
	doWePrintThisElement = true;

      if (doWePrintThisElement) {
	// get the date for this period
	std::string theDate = theCal.yyyymmdd(theCal.periodStart(t));
	// and print the sucker
	theStream  << leadingString << "," << theDate << "," << theVal << "\n";
      }
    }
  }
a1135 11
  // vectored demands
  else {
    if ((printIfZero) || (this->isFloatVecNonZero(theVector, nPeriods))) {
      theStream  << leadingString;
      this->writeCsvFloatVector(theStream, nPeriods, theVector, 0, 15);
      return 1;
    }
    
    return 0;
  }
  // finish_me
a1161 24
  // dated demands
  if (useDatedDemands_)  {
    // loop though the time vector and figure out which to print
    int t = 0; 
    for (t=0; t<nPeriods; t++) {
      bool doWePrintThisElement = false;
      float theVal = theVector[t];
      if ((theVal < 0.0001) && (theVal > -0.0001)) {
	if (printIfZero) { 
	  doWePrintThisElement = true;
	  theVal = 0.0;
	}
      }
      else // it's a non-zero value
	doWePrintThisElement = true;

      if (doWePrintThisElement) {
	// get the date for this period
	std::string theDate = theCal.yyyymmdd(theCal.periodStart(t));
	// and print the sucker
	theStream  << leadingString << "," << theDate << "," << theVal << "\n";
      }
    }
  }
d1163 1
a1163 11
  // vectored demands
  else {
    if ((printIfZero) || (this->isFloatVecNonZero(theVector, nPeriods))) {
      theStream  << leadingString;
      this->writeCsvFloatVector(theStream, nPeriods, theVector, 0, 15);
      return 1;
    }
    
    return 0;
  }
  // finish_me
d1169 2
d1172 1
a1172 1
// **** writeDemandVector
a1191 34
  if (useMultiAttributeDemand_) {
    std::string customerLoc;
    std::string demandClass;
    std::string demandLevel;
    std::string partClass;
    
    mpHelper.uncompressedDemandNames(demandName,
				     customerLoc,
				     demandClass,
				     demandLevel,
				     partClass);
    
    leadingString = "\"" 
      + partname + "\",\"" 
      + pdf + "\",\"" 
      + customerLoc + "\",\"" 
      + demandClass + "\",\"" 
      + demandLevel + "\",\"" 
      + partClass + "\"";
    
    if (useDatedDemands_)  {
      // loop though the time vector and figure out which to print
      int t = 0; 
      for (t=0; t<vLength; t++) {
	bool doWePrintThisElement = false;
	float theVal = theVector[t];
	if ((theVal < 0.0001) && (theVal > -0.0001)) {
	  if (printIfZero) { 
	    doWePrintThisElement = true;
	    theVal = 0.0;
	  }
	}
	else // it's a non-zero value
	    doWePrintThisElement = true;
d1193 58
a1250 9
	if (doWePrintThisElement) {
	  // get the date for this period
	  std::string theDate = theCal.yyyymmdd(theCal.periodStart(t));
	  
	  // print it
	  theStream << leadingString << theDate << "," << theVal << "\n";
	}
      }
    }
d1252 1
a1252 42
    // here is the case of multiAttribute Demands and vectored output
    else {
      float theVal;
      // first check for zero's and determine if we print the record
      bool doWePrintThisRecord = (printIfZero ? true : false);
      int t = 0; 
      for (t=0; t<vLength; t++) {
	theVal = theVector[t];
	if ((theVal > 0.0001) || (theVal < -0.0001)) {
	  doWePrintThisRecord = true;
	  break;
	}
      }
      if (doWePrintThisRecord) {
	theStream << leadingString;
	for (t=0; t<vLength; t++) {
	  theVal = theVector[t];
	  if ((theVal < 0.0001) && (theVal > -0.0001)) {
	    theVal = 0.0;
	  }
	  theStream << "," << theVal;
	}
	theStream << "\n";
      }
    }
  }
  
  
  else {
    theStream << "\"" << partname << "\",\"" 
	      << pdf << "\",\"" 
	      << demandName << "\"";
    
    int t = 0; 
    for (t=0; t<vLength; t++) {
      if ((theVector[t] < 0.0001) && (theVector[t] > -0.0001))
	theStream << "," << (float) 0.0;
      else
	theStream << "," << theVector[t];
    }
    theStream << "\n";
  }
d1254 1
d1257 3
a1280 30
  if (useMultiAttributeDemand_) {
    std::string customerLoc;
    std::string demandClass;
    std::string demandLevel;
    std::string partClass;
    
    mpHelper.uncompressedDemandNames(demandName,
				     customerLoc,
				     demandClass,
				     demandLevel,
				     partClass);
    
    leadingString = "\"" 
      + partname     + "\",\"" 
      + sourceLoc    + "\",\"" 
      + customerLoc  + "\",\"" 
      + demandClass  + "\",\"" 
      + demandLevel  + "\",\"" 
      + partClass    + "\",\""
      + critpartname + "\",\""
      + critpdf      + "\",";
  }
  
  else   {
    leadingString = "\"" 
      + partname     + "\",\"" 
      + sourceLoc    + "\",\"" 
      + demandName   + "\",\""
      + critpartname + "\",\""
      + critpdf      + "\",";
d1282 8
a1289 2
  }
  
d1325 1
d1327 2
a1328 1
  std::string leadingString;
d1330 1
a1330 21
  if (useMultiAttributeDemand_) {
    std::string sourceLoc;
    std::string customerLoc;
    std::string demandClass;
    std::string demandLevel;
    std::string partClass;
    
    mpHelper.uncompressedDemandNamesWithPdf(geo,
					    sourceLoc,
					    customerLoc,
					    demandClass,
					    demandLevel,
					    partClass);
    
    leadingString = "\"" 
      + plannerPart + "\",\"" 
      + sourceLoc + "\",\"" 
      + customerLoc + "\",\"" 
      + demandClass + "\",\"" 
      + demandLevel + "\",\"" 
      + partClass + "\",\""
a1332 15
    
    if (useDatedDemands_)  {
      // loop though the time vector and figure out which to print
      int t = 0; 
      for (t=0; t<nPeriods; t++) {
	bool doWePrintThisElement = false;
	float theVal = theVector[t];
	if ((theVal < 0.0001) && (theVal > -0.0001)) {
	  if (printIfZero) { 
	    doWePrintThisElement = true;
	    theVal = 0.0;
	  }
	}
	else // it's a non-zero value
	    doWePrintThisElement = true;
d1334 1
a1334 37
	if (doWePrintThisElement) {
	  // get the date for this period
	  std::string theDate = theCal.yyyymmdd(theCal.periodStart(t));
	  
	  // print it
	  theStream << leadingString << "," << theDate << "," << theVal << "\n";
	}
      }
    }

    // here is the case of multiAttribute Demands and vectored output
    else {
      float theVal;
      // first check for zero's and determine if we print the record
      bool doWePrintThisRecord = (printIfZero ? true : false);
      int t = 0; 
      for (t=0; t<nPeriods; t++) {
	theVal = theVector[t];
	if ((theVal > 0.0001) || (theVal < -0.0001)) {
	  doWePrintThisRecord = true;
	  break;
	}
      }
      if (doWePrintThisRecord) {
	theStream << leadingString;
	for (t=0; t<nPeriods; t++) {
	  theVal = theVector[t];
	  if ((theVal < 0.0001) && (theVal > -0.0001)) {
	    theVal = 0.0;
	  }
	  theStream << "," << theVal;
	}
	theStream << "\n";
      }
    }
  }
  
a1335 17
  // this is old case of single attribute demand and vectored data
  else {
    theStream << "\"" 
	      << plannerPart << "\",\"" 
	      << geo << "\",\"" 
	      << peggedPart << "\",\"" 
	      << peggedPdf  << "\""; 
    
    int t = 0; 
    for (t=0; t<nPeriods; t++) {
      if ((theVector[t] < 0.0001) && (theVector[t] > -0.0001))
	theStream << "," << (float) 0.0;
      else
	theStream << "," << theVector[t];
    }
    theStream << "\n";
  }
d1353 1
a1353 1
				      const std::string & demandId, 
a1360 1

d1363 21
a1383 71
  if (useMultiAttributeDemand_) {
    std::string customerLoc;
    std::string demandClass;
    std::string demandLevel;
    std::string partClass;
    
    mpHelper.uncompressedDemandNames(demandId,
				     customerLoc,
				     demandClass,
				     demandLevel,
				     partClass);
    
    leadingString = "\"" 
      + demandedPart + "\",\"" 
      + demandedPdf + "\",\"" 
      + customerLoc + "\",\"" 
      + demandClass + "\",\"" 
      + demandLevel + "\",\"" 
      + partClass + "\",\""
      + peggedPart + "\",\""
      + peggedPdf + "\"";
    
    if (useDatedDemands_)  {
      // loop though the time vector and figure out which to print
      int t = 0; 
      for (t=0; t<nPeriods; t++) {
	bool doWePrintThisElement = false;
	float theVal = theVector[t];
	if ((theVal < 0.0001) && (theVal > -0.0001)) {
	  if (printIfZero) { 
	    doWePrintThisElement = true;
	    theVal = 0.0;
	  }
	}
	else // it's a non-zero value
	    doWePrintThisElement = true;

	if (doWePrintThisElement) {
	  // get the date for this period
	  std::string theDate = theCal.yyyymmdd(theCal.periodStart(t));
	  
	  // print it
	  theStream << leadingString << "," << theDate << "," << theVal << "\n";
	}
      }
    }

    // here is the case of multiAttribute Demands and vectored output
    else {
      float theVal;
      // first check for zero's and determine if we print the record
      bool doWePrintThisRecord = (printIfZero ? true : false);
      int t = 0; 
      for (t=0; t<nPeriods; t++) {
	theVal = theVector[t];
	if ((theVal > 0.0001) || (theVal < -0.0001)) {
	  doWePrintThisRecord = true;
	  break;
	}
      }
      if (doWePrintThisRecord) {
	theStream << leadingString;
	for (t=0; t<nPeriods; t++) {
	  theVal = theVector[t];
	  if ((theVal < 0.0001) && (theVal > -0.0001)) {
	    theVal = 0.0;
	  }
	  theStream << "," << theVal;
	}
	theStream << "\n";
      }
a1387 19
  // this is old case of single attribute demand and vectored data
  else {
    theStream << "\"" 
	      << demandedPart << "\",\"" 
	      << demandedPdf << "\",\"" 
	      << demandId << "\",\"" 
	      << peggedPart << "\",\"" 
	      << peggedPdf  << "\""; 
    
    int t = 0; 
    for (t=0; t<nPeriods; t++) {
      if ((theVector[t] < 0.0001) && (theVector[t] > -0.0001))
	theStream << "," << (float) 0.0;
      else
	theStream << "," << theVector[t];
    }
    theStream << "\n";
  }

d1413 22
a1434 73
  if (useMultiAttributeDemand_) {
    std::string customerLoc;
    std::string demandClass;
    std::string demandLevel;
    std::string partClass;
    
    mpHelper.uncompressedDemandNames(demandId,
				     customerLoc,
				     demandClass,
				     demandLevel,
				     partClass);

    leadingString = "\"" 
      + demandedPart + "\",\"" 
      + sourceLoc + "\",\"" 
      + customerLoc + "\",\"" 
      + demandClass + "\",\"" 
      + demandLevel + "\",\"" 
      + partClass + "\",\""
      + pn1 + "\",\""
      + pdf1 + "\",\""
      + pn2 + "\",\""
      + pdf2 + "\"";
    
    if (useDatedDemands_)  {
      // loop though the time vector and figure out which to print
      int t = 0; 
      for (t=0; t<nPeriods; t++) {
	bool doWePrintThisElement = false;
	float theVal = theVector[t];
	if ((theVal < 0.0001) && (theVal > -0.0001)) {
	  if (printIfZero) { 
	    doWePrintThisElement = true;
	    theVal = 0.0;
	  }
	}
	else // it's a non-zero value
	    doWePrintThisElement = true;

	if (doWePrintThisElement) {
	  // get the date for this period
	  std::string theDate = theCal.yyyymmdd(theCal.periodStart(t));
	  
	  // print it
	  theStream << leadingString << "," << theDate << "," << theVal << "\n";
	}
      }
    }

    // here is the case of multiAttribute Demands and vectored output
    else {
      float theVal;
      // first check for zero's and determine if we print the record
      bool doWePrintThisRecord = (printIfZero ? true : false);
      int t = 0; 
      for (t=0; t<nPeriods; t++) {
	theVal = theVector[t];
	if ((theVal > 0.0001) || (theVal < -0.0001)) {
	  doWePrintThisRecord = true;
	  break;
	}
      }
      if (doWePrintThisRecord) {
	theStream << leadingString;
	for (t=0; t<nPeriods; t++) {
	  theVal = theVector[t];
	  if ((theVal < 0.0001) && (theVal > -0.0001)) {
	    theVal = 0.0;
	  }
	  theStream << "," << theVal;
	}
	theStream << "\n";
      }
a1436 25
  

  // this is old case of single attribute demand and vectored data
  else {
    theStream << "\"" 
	      << demandedPart << "\",\"" 
	      << sourceLoc << "\",\"" 
	      << demandId << "\",\"" 
	      << pn1 << "\",\"" 
	      << pdf1  << "\",\""
	      << pn2 << "\",\"" 
	      << pdf2 << "\""; 
    
    int t = 0; 
    for (t=0; t<nPeriods; t++) {
      if ((theVector[t] < 0.0001) && (theVector[t] > -0.0001))
	theStream << "," << (float) 0.0;
      else
	theStream << "," << theVector[t];
    }
    theStream << "\n";
  }



a1462 40
  if (useMultiAttributeDemand_) {
    std::string sourceLoc;
    std::string customerLoc;
    std::string demandClass;
    std::string demandLevel;
    std::string partClass;
    
    mpHelper.uncompressedDemandNamesWithPdf(geo,
					    sourceLoc,
					    customerLoc,
					    demandClass,
					    demandLevel,
					    partClass);
    
    leadingString = "\"" 
      + plannerPart + "\",\"" 
      + sourceLoc + "\",\"" 
      + customerLoc + "\",\"" 
      + demandClass + "\",\"" 
      + demandLevel + "\",\"" 
      + partClass + "\",\""
      + peggedOrderingPart + "\",\""
      + peggedOrderingPdf + "\",\""
      + peggedSupplyingPart + "\",\""
      + peggedSupplyingPdf + "\"";
    
    if (useDatedDemands_)  {
      // loop though the time vector and figure out which to print
      int t = 0; 
      for (t=0; t<nPeriods; t++) {
	bool doWePrintThisElement = false;
	float theVal = theVector[t];
	if ((theVal < 0.0001) && (theVal > -0.0001)) {
	  if (printIfZero) { 
	    doWePrintThisElement = true;
	    theVal = 0.0;
	  }
	}
	else // it's a non-zero value
	    doWePrintThisElement = true;
d1464 1
a1464 9
	if (doWePrintThisElement) {
	  // get the date for this period
	  std::string theDate = theCal.yyyymmdd(theCal.periodStart(t));
	  
	  // print it
	  theStream << leadingString << "," << theDate << "," << theVal << "\n";
	}
      }
    }
a1465 27
    // here is the case of multiAttribute Demands and vectored output
    else {
      float theVal;
      // first check for zero's and determine if we print the record
      bool doWePrintThisRecord = (printIfZero ? true : false);
      int t = 0; 
      for (t=0; t<nPeriods; t++) {
	theVal = theVector[t];
	if ((theVal > 0.0001) || (theVal < -0.0001)) {
	  doWePrintThisRecord = true;
	  break;
	}
      }
      if (doWePrintThisRecord) {
	theStream << leadingString;
	for (t=0; t<nPeriods; t++) {
	  theVal = theVector[t];
	  if ((theVal < 0.0001) && (theVal > -0.0001)) {
	    theVal = 0.0;
	  }
	  theStream << "," << theVal;
	}
	theStream << "\n";
      }
    }
  }
  
a1466 19
  // this is old case of single attribute demand and vectored data
  else {
    theStream << "\"" 
	      << plannerPart << "\",\"" 
	      << geo << "\",\"" 
	      << peggedOrderingPart << "\",\"" 
	      << peggedOrderingPdf  << "\",\""
	      << peggedSupplyingPart << "\",\"" 
	      << peggedSupplyingPdf << "\""; 
    
    int t = 0; 
    for (t=0; t<nPeriods; t++) {
      if ((theVector[t] < 0.0001) && (theVector[t] > -0.0001))
	theStream << "," << (float) 0.0;
      else
	theStream << "," << theVector[t];
    }
    theStream << "\n";
  }
d1468 7
a1479 21
//  ---------------------------------------------------------------------
//  Utility to print a float vector to an output stream
//  --------------------------------------------------------------------- 
void 
LgFrSceFlatFileMgr::writeCsvFloatVector(
    std::ofstream & theStream,   // output stream (already opened)
    int    vLength,         // lenght of the vector (nPeriods?)
    const float * theVector,      // the vector itself
    int precision,          // number of digits to the right of the decimal
    int totalSpace)         // total length of the 'formatted' field
{
   int t = 0;
   for (t=0; t<vLength; t++) {
     if ((theVector[t] < 0.0001) && (theVector[t] > -0.0001))
       theStream << "," << (float) 0.0;
     else
       theStream << "," << theVector[t];
   }
   theStream << "\n";
}

a1535 2


d1679 7
d1794 1
d1811 1
d1824 1
@


1.10
log
@some SCE 6 enhancements for 1/23 Beta release
@
text
@d44 1
a44 2
    const LgFrMultiPlantHelper & mpHelper,
    const int fileFormatType)
d68 17
a84 28
    if (fileFormatType == SCE_EPPS_FILE_FORMAT) {
	pdf_PartName = nextQuotedString(next, result, fileName, dataLine, 
					lineNo, MANDATORY);
	if (! mpHelper.isPartValid(theWitRun, 
				   pdf_PartName, 
				   fileName, 
				   dataLine, 
				   lineNo, 
				   OPTIONAL_WITH_MESSAGE))
	  return 1;
    }
    else {
	mfgPartName = nextQuotedString(next, result, fileName, dataLine, 
				       lineNo, MANDATORY);
	pdf = nextQuotedString(next, result, fileName, dataLine, 
			       lineNo, MANDATORY);
	pdf_PartName = mpHelper.pdfPartname(mfgPartName, pdf);

	if (! mpHelper.isPartValid(theWitRun, 
				   mfgPartName, 
				   pdf,
				   fileName, 
				   dataLine, 
				   lineNo, 
				   OPTIONAL_WITH_MESSAGE))
	  return 1;
	
    }
d86 2
a87 2


d357 1
a357 2
    const LgFrMultiPlantHelper & mpHelper,
    const int fileFormatType)
a382 19
    if (fileFormatType == SCE_EPPS_FILE_FORMAT) {
	pdf_PartName = nextQuotedString(next, result, fileName, dataLine, 
					lineNo, MANDATORY);
	if (! mpHelper.isPartValid(theWitRun, 
				   pdf_PartName, 
				   fileName, 
				   dataLine, 
				   lineNo, 
				   OPTIONAL_WITH_MESSAGE))
	  return 1;
    }
    else {
	mfgPartName = nextQuotedString(next, result, fileName, dataLine, 
				       lineNo, MANDATORY);
	pdf = nextQuotedString(next, result, fileName, dataLine, 
			       lineNo, MANDATORY);
	pdf_PartName = mpHelper.pdfPartname(mfgPartName, pdf);


d384 17
a401 10
	if (! mpHelper.isPartValid(theWitRun, 
				   mfgPartName, 
				   pdf,
				   fileName, 
				   dataLine, 
				   lineNo, 
				   OPTIONAL_WITH_MESSAGE))
	  return 1;

    }
@


1.9
log
@int return value
@
text
@d1004 59
d1123 2
d1164 1
a1164 1
      + partClass + "\",";
d1236 68
d1546 128
@


1.8
log
@sce5 beta with prioriity manager, multiattribute demand, and dated records
@
text
@d1060 2
@


1.7
log
@Dated demands and multiAttributeDemand for indep DemandsVol and commits,
also for partDB
@
text
@d1177 360
@


1.6
log
@minor updates for SCE
@
text
@d112 110
d720 1
d1003 177
d1191 1
a1191 3
   std::string blankVector(' ', totalSpace);

   int t = 0; // Pulled out of the for below by RW2STL
a1192 4
//      std::string sNum(sce::stringFrom(theVector[t], precision));
//     int blankSpace = totalSpace - sNum.length();
//      sNum.prepend(blankVector, blankSpace);
//      theStream << sNum << ",";
d1202 1
d1223 1
d1225 1
a1225 3
/*  RWCRegexp stripIt("\".*\"");

  token = token(stripIt);
a1226 3
  // now pull off the quotes 
  token = sce::strip(token,  '\"'); */
  
d1251 3
d1257 1
a1257 1
// Multi-Attribute Demand Classes.   
d1260 1
a1260 1
LgFrSceFlatFileMgr::nextQuotedCustomerString(
d1269 1
d1272 2
a1273 1
  int numCustomerAttr = 4;
d1275 1
d1277 2
a1278 1
  std::string finalToken = "";
d1280 37
a1316 3
  int tokCnt=0;
  for (tokCnt=0; tokCnt<numCustomerAttr; tokCnt++) {
    // get the first token, including junk like spaces and tabs
d1318 1
a1318 1

d1320 1
a1320 1
  
d1329 1
a1329 1

d1333 1
a1333 1
			   << "Customer Attributes in Quoted String" 
d1339 1
a1339 5

    if (tokCnt > 0)
      finalToken += "%" + token;
    else 
      finalToken += token;
a1340 1
    
a1341 1
  return finalToken;
d1384 25
d1508 3
d1521 8
a1528 5
   const LgFrSceFlatFileMgr& source )
  : setOfIllegalCharacters_ (source.setOfIllegalCharacters_),
    globalCalendarFormat_(source.globalCalendarFormat_),
    sceIOLogMgr_(source.sceIOLogMgr_),
    sceErrFacility_(source.sceErrFacility_)
d1534 7
a1540 4
  : setOfIllegalCharacters_ (0),
    globalCalendarFormat_("G"),
    sceIOLogMgr_(),
    sceErrFacility_(0)
@


1.5
log
@commiting to main branch witutil, scenario, and sce code which removes RW
@
text
@d972 64
@


1.4
log
@Added include of mcl/src/mcl.h near top of include list to avoid
compile time problems on AIX which did not occur on Windows.

added
  implement(RWGVector, float)
  implement(RWGVector, int)
to ipSce.C to avoid unresolved symbols at link time
@
text
@d2 6
d9 2
a10 2
#include <iostream.h>
#include <fstream.h>
a11 3
#include <rw/ctoken.h>
#include <rw/regexp.h>
#include <rw/locale.h>
d35 1
a35 1
    RWCString & pdf_PartName,   // pdf_PartName to be returned
d40 3
a42 3
    istream & inFile,             // An open stream
    const RWCString & fileName,  // For error messaging
    RWCString & dataLine,
d48 2
a49 2
    RWCString pdf;
    RWCString mfgPartName;
d52 1
a52 1
    dataLine.readToDelim(inFile);
d56 2
a57 2
    dataLine = dataLine.strip(RWCString::both);
    if ((dataLine.index("*") == 0) || dataLine.isNull())
d60 1
a60 1
    RWCTokenizer next(dataLine);
d97 1
a97 1
    result = nextFloat(theVal, next, fileName, dataLine, lineNo, TRUE, -FLT_MAX);
d116 1
a116 1
    RWCString & pdf_OperationName,   // pdf_PartName to be returned
d121 3
a123 3
    istream & inFile,             // An open stream
    const RWCString & fileName,  // For error messaging
    RWCString & dataLine,
d128 2
a129 2
    RWCString pdf;
    RWCString operationName;
d132 1
a132 1
    dataLine.readToDelim(inFile);
d136 2
a137 2
    dataLine = dataLine.strip(RWCString::both);
    if ((dataLine.index("*") == 0) || dataLine.isNull())
d146 1
a146 1
    RWCTokenizer next(dataLine);
d164 1
a164 1
    result = nextFloat(theVal, next, fileName, dataLine, lineNo, TRUE, -FLT_MAX);
d186 1
a186 1
    RWCString & pdf_OperationName,   // pdf_PartName to be returned
d189 3
a191 3
    istream & inFile,             // An open stream
    const RWCString & fileName,  // For error messaging
    RWCString & dataLine,
d196 2
a197 2
    RWCString pdf;
    RWCString operationName;
d200 1
a200 1
    dataLine.readToDelim(inFile);
d204 2
a205 2
    dataLine = dataLine.strip(RWCString::both);
    if ((dataLine.index("*") == 0) || dataLine.isNull())
d214 1
a214 1
    RWCTokenizer next(dataLine);
d232 1
a232 1
    result = nextFloat(theVal, next, fileName, dataLine, lineNo, TRUE, 0.0);
d249 1
a249 1
    RWCString & pdf_PartName,   // pdf_PartName to be returned
d255 3
a257 3
    istream & inFile,             // An open stream
    const RWCString & fileName,  // For error messaging
    RWCString & dataLine,
d263 2
a264 2
    RWCString pdf;
    RWCString mfgPartName;
d267 1
a267 1
    dataLine.readToDelim(inFile);
d274 2
a275 2
    dataLine = dataLine.strip(RWCString::both);
    if ((dataLine.index("*") == 0) || dataLine.isNull())
d278 1
a278 1
    RWCTokenizer next(dataLine);
d317 2
a318 2
    result = nextFloat(theVal, next, fileName, dataLine, lineNo, TRUE, -FLT_MAX);
    result2 = nextFloat(theVal2, next, fileName, dataLine, lineNo, TRUE, -FLT_MAX);
d337 1
a337 1
    RWCString & pdf_OperationName,   // pdf_OperationName to be returned
d343 3
a345 3
    istream & inFile,             // An open stream
    const RWCString & fileName,  // For error messaging
    RWCString & dataLine,
d350 2
a351 2
    RWCString pdf;
    RWCString operationName;
d354 1
a354 1
    dataLine.readToDelim(inFile);
d358 2
a359 2
    dataLine = dataLine.strip(RWCString::both);
    if ((dataLine.index("*") == 0) || dataLine.isNull())
d362 1
a362 1
    RWCTokenizer next(dataLine);
d389 2
a390 2
    result = nextFloat(theVal, next, fileName, dataLine, lineNo, TRUE, -FLT_MAX);
    result2 = nextFloat(theVal2, next, fileName, dataLine, lineNo, TRUE, -FLT_MAX);
d409 1
a409 1
    RWCString & pdf_PartName,            // pdf_PartName to be returned
d411 3
a413 3
    istream & inFile,                    // An open stream
    const RWCString & fileName,          // for messaging
    RWCString& dataLine,
d425 1
a425 1
 dataLine.readToDelim(inFile);
d428 1
a428 1
 dataLine = dataLine.strip(RWCString::both);
d431 1
a431 1
 if ((dataLine.index("*") == 0) || dataLine.isNull())
d434 1
a434 1
 RWCTokenizer next(dataLine);
d443 1
a443 1
 RWCString mfgPartName =  nextQuotedString(next, result, fileName, 
d450 1
a450 1
 RWCString pdf(nextQuotedString(next, result, fileName, dataLine, 
d463 1
a463 1
			 FALSE, lowerLimit, upperLimit))
d477 1
a477 1
    RWCString & pdf_OperationName,       // pdf_OperationName to be returned
d479 3
a481 3
    istream & inFile,                    // An open stream
    const RWCString & fileName,          // for messaging
    RWCString& dataLine,
d494 1
a494 1
 dataLine.readToDelim(inFile);
d497 1
a497 1
 dataLine = dataLine.strip(RWCString::both);
d500 1
a500 1
 if ((dataLine.index("*") == 0) || dataLine.isNull())
d503 1
a503 1
 RWCTokenizer next(dataLine);
d512 1
a512 1
 RWCString operationName =  nextQuotedString(next, result, fileName, 
d519 1
a519 1
 RWCString pdf(nextQuotedString(next, result, fileName, dataLine, 
d533 1
a533 1
			 FALSE, -FLT_MAX))
d548 3
a550 3
    RWCTokenizer & next,
    const RWCString & fileName,
    const RWCString & dataLine,
d552 1
a552 1
    const RWBoolean Mandatory,
d560 2
a561 2
  RWCString token = next(dataDelim);
  if (token.isNull())   {
d573 1
a573 1
  if (! RWLocale::global().stringToNum(token, &d))  {
d614 3
a616 3
    RWCTokenizer & next,
    const RWCString & fileName,
    const RWCString & dataLine,
d618 1
a618 1
    const RWBoolean Mandatory,
d626 2
a627 2
  RWCString token = next(dataDelim);
  if (token.isNull())   {
d639 1
a639 1
  if (! RWLocale::global().stringToNum(token, &lng))  {
d683 1
a683 1
RWBoolean
d688 2
a689 1
  for (int t=0; t<vLength; t++) {
d691 1
a691 1
      return TRUE;
d693 1
a693 1
   return FALSE;
d711 2
a712 2
    RWCTokenizer & next,
    const RWCString & fileName,
d714 1
a714 1
    const RWCString & dataLine,
d722 1
a722 1
    RWCString token;
d730 1
a730 1
    if ((token = next(dataDelim)).isNull())   
d733 1
a733 1
    RWDate startDate(parseDateString(token, theCal));
d744 1
a744 1
    if ((token = next(dataDelim)).isNull())   
d747 1
a747 1
    RWDate endDate(parseDateString(token, theCal));
d791 2
a792 2
    RWCTokenizer & next,
    const RWCString & fileName,
d794 1
a794 1
    const RWCString & dataLine,
d802 1
a802 1
    RWCString token;
d810 1
a810 1
    if ((token = next(dataDelim)).isNull())   
d813 1
a813 1
    RWDate startDate(parseDateString(token, theCal));
d824 1
a824 1
    if ((token = next(dataDelim)).isNull())   
d827 1
a827 1
    RWDate endDate(parseDateString(token, theCal));
d856 1
a856 1
    ofstream & theStream,   // output stream (already opened)
d862 1
a862 1
   RWCString blankVector(' ', totalSpace);
d864 4
a867 2
   for (int t=0; t<vLength; t++) {
      RWCString sNum(RWLocale::global().asString(theVector[t], precision));
d869 1
a869 1
      sNum.prepend(blankVector, blankSpace);
d880 1
a880 1
    ofstream & theStream,   // output stream (already opened)
d884 2
a885 1
   for (int t=0; t<vLength; t++) 
d897 1
a897 1
    ofstream & theStream,   // output stream (already opened)
d903 1
a903 1
   RWCString blankVector(' ', totalSpace);
d905 3
a907 2
   for (int t=0; t<vLength; t++) {
//      RWCString sNum(RWLocale::global().asString(theVector[t], precision));
d925 1
a925 1
RWCString
d927 1
a927 1
    RWCTokenizer & next,
d929 2
a930 2
    const RWCString & fileName,
    const RWCString & dataLine,
d938 1
a938 1
    RWCString token = next(",\n");
d940 2
a941 2
  // now use a regexp to strip off the leading and trailing junk
  RWCRegexp stripIt("\".*\"");
d946 1
a946 1
  token = token.strip(RWCString::both, '\"');
d948 1
a948 1
  if (doYouNeedIt == MANDATORY && token.isNull()) {
d957 1
a957 1
  if ( token.isNull())    {
d974 1
a974 1
LgFrSceFlatFileMgr::appendToTheSetOfIllegalCharacters( const RWCString newIllegalChar )
d976 1
a976 1
  setOfIllegalCharacters_.insert( newIllegalChar );
d984 1
a984 1
  return setOfIllegalCharacters_.entries();
d989 2
a990 2
// 1 = an illegal character was found (contains = TRUE)
// 0 = no illegal characters were found (contains = FALSE)
d992 1
a992 1
LgFrSceFlatFileMgr::containsIllegalCharacters (const RWCString theString)
d994 3
a996 2
  int nIllegalChars = setOfIllegalCharacters_.entries();
  for (int i=0; i<nIllegalChars; i++) {
d998 1
a998 1
    if ( theString.index( setOfIllegalCharacters_[i] ) != RW_NPOS)
d1007 1
a1007 1
LgFrSceFlatFileMgr::setGlobalCalendarFormat(const RWCString & calendarFormat)
d1009 2
a1010 1
    globalCalendarFormat_ = toUpper(calendarFormat);
d1013 1
a1013 1
RWCString 
d1019 1
a1019 1
RWDate
d1021 1
a1021 1
    const RWCString & dateString, 
d1036 3
a1038 3
  // to get the max legal RWDate without knowing how its implemented!
  if ( ! dateString.compareTo("PAST", RWCString::ignoreCase)) {
    RWCString pastDate("19010101");
d1042 2
a1043 2
  if ( ! dateString.compareTo("FUTURE", RWCString::ignoreCase)) {
    RWCString futureDate("20361231");
d1050 1
a1050 1
  //    (b) date is no earlier than Jan 1, 1901 (SCE's self imposed lower limit)
d1054 7
a1060 1
  RWCRegexp regExp("[^0123456789]");
d1062 3
a1064 3
      || (! dateString(regExp).isNull())
      || (dateString < "19010101")) {
    RWCString badDate("99999999");
d1070 1
a1070 1
    RWCString futureDate("20361231");
d1076 1
a1076 1
    RWDate theDate(dateString);
d1081 1
d1125 1
a1125 1
  : setOfIllegalCharacters_ (NULL),
d1128 1
a1128 1
    sceErrFacility_(NULL)
@


1.4.2.1
log
@Roguewave is gone
@
text
@a1 6
// RW2STL - inserted:
#include <string>
#include <ostream.h>
#include <scenario/src/RWToSTLHelpers.h>
// End of RW2STL - inserted includes.

d4 1
a4 1
#include <fstream>
d6 3
d32 1
a32 1
    std::string & pdf_PartName,   // pdf_PartName to be returned
d37 3
a39 3
    std::ifstream & inFile,             // An open stream
    const std::string & fileName,  // For error messaging
    std::string & dataLine,
d45 2
a46 2
    std::string pdf;
    std::string mfgPartName;
d49 1
a49 1
    std::getline( inFile, dataLine );
d53 2
a54 2
    dataLine = sce::strip( dataLine );
    if ((dataLine[0] == '*') || dataLine.empty())
d57 1
a57 1
    SCETokenizer next(dataLine);
d94 1
a94 1
    result = nextFloat(theVal, next, fileName, dataLine, lineNo, true, -FLT_MAX);
d113 1
a113 1
    std::string & pdf_OperationName,   // pdf_PartName to be returned
d118 3
a120 3
    std::ifstream & inFile,             // An open stream
    const std::string & fileName,  // For error messaging
    std::string & dataLine,
d125 2
a126 2
    std::string pdf;
    std::string operationName;
d129 1
a129 1
    std::getline( inFile, dataLine );
d133 2
a134 2
    dataLine = sce::strip( dataLine );
    if ((dataLine[0] == '*') || dataLine.empty())
d143 1
a143 1
    SCETokenizer next(dataLine);
d161 1
a161 1
    result = nextFloat(theVal, next, fileName, dataLine, lineNo, true, -FLT_MAX);
d183 1
a183 1
    std::string & pdf_OperationName,   // pdf_PartName to be returned
d186 3
a188 3
    std::ifstream & inFile,             // An open stream
    const std::string & fileName,  // For error messaging
    std::string & dataLine,
d193 2
a194 2
    std::string pdf;
    std::string operationName;
d197 1
a197 1
    std::getline( inFile, dataLine );
d201 2
a202 2
    dataLine = sce::strip( dataLine );
    if ((dataLine[0] == '*') || dataLine.empty())
d211 1
a211 1
    SCETokenizer next(dataLine);
d229 1
a229 1
    result = nextFloat(theVal, next, fileName, dataLine, lineNo, true, 0.0);
d246 1
a246 1
    std::string & pdf_PartName,   // pdf_PartName to be returned
d252 3
a254 3
    std::ifstream & inFile,             // An open stream
    const std::string & fileName,  // For error messaging
    std::string & dataLine,
d260 2
a261 2
    std::string pdf;
    std::string mfgPartName;
d264 1
a264 1
    std::getline( inFile, dataLine );
d271 2
a272 2
    dataLine = sce::strip( dataLine );
    if ((dataLine[0] == '*') || dataLine.empty())
d275 1
a275 1
    SCETokenizer next(dataLine);
d314 2
a315 2
    result = nextFloat(theVal, next, fileName, dataLine, lineNo, true, -FLT_MAX);
    result2 = nextFloat(theVal2, next, fileName, dataLine, lineNo, true, -FLT_MAX);
d334 1
a334 1
    std::string & pdf_OperationName,   // pdf_OperationName to be returned
d340 3
a342 3
    std::ifstream & inFile,             // An open stream
    const std::string & fileName,  // For error messaging
    std::string & dataLine,
d347 2
a348 2
    std::string pdf;
    std::string operationName;
d351 1
a351 1
    std::getline( inFile, dataLine );
d355 2
a356 2
    dataLine = sce::strip( dataLine );
    if ((dataLine[0] == '*') || dataLine.empty())
d359 1
a359 1
    SCETokenizer next(dataLine);
d386 2
a387 2
    result = nextFloat(theVal, next, fileName, dataLine, lineNo, true, -FLT_MAX);
    result2 = nextFloat(theVal2, next, fileName, dataLine, lineNo, true, -FLT_MAX);
d406 1
a406 1
    std::string & pdf_PartName,            // pdf_PartName to be returned
d408 3
a410 3
    std::ifstream & inFile,                    // An open stream
    const std::string & fileName,          // for messaging
    std::string& dataLine,
d422 1
a422 1
 std::getline( inFile, dataLine );
d425 1
a425 1
 dataLine = sce::strip( dataLine );
d428 1
a428 1
 if ((dataLine[0] == '*') || dataLine.empty())
d431 1
a431 1
 SCETokenizer next(dataLine);
d440 1
a440 1
 std::string mfgPartName =  nextQuotedString(next, result, fileName, 
d447 1
a447 1
 std::string pdf(nextQuotedString(next, result, fileName, dataLine, 
d460 1
a460 1
			 false, lowerLimit, upperLimit))
d474 1
a474 1
    std::string & pdf_OperationName,       // pdf_OperationName to be returned
d476 3
a478 3
    std::ifstream & inFile,                    // An open stream
    const std::string & fileName,          // for messaging
    std::string& dataLine,
d491 1
a491 1
 std::getline( inFile, dataLine );
d494 1
a494 1
 dataLine = sce::strip( dataLine );
d497 1
a497 1
 if ((dataLine[0] == '*') || dataLine.empty())
d500 1
a500 1
 SCETokenizer next(dataLine);
d509 1
a509 1
 std::string operationName =  nextQuotedString(next, result, fileName, 
d516 1
a516 1
 std::string pdf(nextQuotedString(next, result, fileName, dataLine, 
d530 1
a530 1
			 false, -FLT_MAX))
d545 3
a547 3
    SCETokenizer & next,
    const std::string & fileName,
    const std::string & dataLine,
d549 1
a549 1
    const bool Mandatory,
d557 2
a558 2
  std::string token = next(dataDelim);
  if (token.empty())   {
d570 1
a570 1
  if (! sce::fromString( token, d))  {
d611 3
a613 3
    SCETokenizer & next,
    const std::string & fileName,
    const std::string & dataLine,
d615 1
a615 1
    const bool Mandatory,
d623 2
a624 2
  std::string token = next(dataDelim);
  if (token.empty())   {
d636 1
a636 1
  if (!sce::fromString( token, (token, lng)))  {
d680 1
a680 1
bool
d685 1
a685 2
  int t = 0; // Pulled out of the for below by RW2STL
  for (t=0; t<vLength; t++) {
d687 1
a687 1
      return true;
d689 1
a689 1
   return false;
d707 2
a708 2
    SCETokenizer & next,
    const std::string & fileName,
d710 1
a710 1
    const std::string & dataLine,
d718 1
a718 1
    std::string token;
d726 1
a726 1
    if ((token = next(dataDelim)).empty())   
d729 1
a729 1
    SCEDate startDate(parseDateString(token, theCal));
d740 1
a740 1
    if ((token = next(dataDelim)).empty())   
d743 1
a743 1
    SCEDate endDate(parseDateString(token, theCal));
d787 2
a788 2
    SCETokenizer & next,
    const std::string & fileName,
d790 1
a790 1
    const std::string & dataLine,
d798 1
a798 1
    std::string token;
d806 1
a806 1
    if ((token = next(dataDelim)).empty())   
d809 1
a809 1
    SCEDate startDate(parseDateString(token, theCal));
d820 1
a820 1
    if ((token = next(dataDelim)).empty())   
d823 1
a823 1
    SCEDate endDate(parseDateString(token, theCal));
d852 1
a852 1
    std::ofstream & theStream,   // output stream (already opened)
d858 1
a858 1
   std::string blankVector(totalSpace, ' ');
d860 2
a861 4
   int t = 0; // Pulled out of the for below by RW2STL
   for (t=0; t<vLength; t++) 
   {
      std::string sNum(sce::stringFrom(theVector[t], precision));
d863 1
a863 1
      sNum.insert(0, blankVector.c_str(), blankSpace);
d874 1
a874 1
    std::ofstream & theStream,   // output stream (already opened)
d878 1
a878 2
   int t = 0; // Pulled out of the for below by RW2STL
   for (t=0; t<vLength; t++) 
d890 1
a890 1
    std::ofstream & theStream,   // output stream (already opened)
d896 1
a896 1
   std::string blankVector(' ', totalSpace);
d898 2
a899 3
   int t = 0; // Pulled out of the for below by RW2STL
   for (t=0; t<vLength; t++) {
//      std::string sNum(sce::stringFrom(theVector[t], precision));
d917 1
a917 1
std::string
d919 1
a919 1
    SCETokenizer & next,
d921 2
a922 2
    const std::string & fileName,
    const std::string & dataLine,
d930 1
a930 1
  std::string token = next(",\n");
d932 2
a933 2
  token = sce::extractQuotedPart( token );
/*  RWCRegexp stripIt("\".*\"");
d938 1
a938 1
  token = sce::strip(token,  '\"'); */
d940 1
a940 1
  if (doYouNeedIt == MANDATORY && token.empty()) {
d949 1
a949 1
  if ( token.empty())    {
d966 1
a966 1
LgFrSceFlatFileMgr::appendToTheSetOfIllegalCharacters( const std::string newIllegalChar )
d968 1
a968 1
  setOfIllegalCharacters_.push_back( newIllegalChar );
d976 1
a976 1
  return setOfIllegalCharacters_.size();
d981 2
a982 2
// 1 = an illegal character was found (contains = true)
// 0 = no illegal characters were found (contains = false)
d984 1
a984 1
LgFrSceFlatFileMgr::containsIllegalCharacters (const std::string theString)
d986 2
a987 3
  int nIllegalChars = setOfIllegalCharacters_.size();
  int i = 0; // Pulled out of the for below by RW2STL
  for (i=0; i<nIllegalChars; i++) {
d989 1
a989 1
      if ( theString.find_first_of( setOfIllegalCharacters_[i] ) != std::string::npos)
d998 1
a998 1
LgFrSceFlatFileMgr::setGlobalCalendarFormat(const std::string & calendarFormat)
d1000 1
a1000 2
    globalCalendarFormat_ = calendarFormat;
    sce::toUpper(globalCalendarFormat_);
d1003 1
a1003 1
std::string 
d1009 1
a1009 1
SCEDate
d1011 1
a1011 1
    const std::string & dateString, 
d1026 3
a1028 3
  // to get the max legal SCEDate without knowing how its implemented!
  if ( ! sce::compareStringsCaseIns( dateString, "PAST" )) {
    std::string pastDate("19700101");
d1032 2
a1033 2
  if ( ! sce::compareStringsCaseIns( dateString, "FUTURE" )) {
    std::string futureDate("20361231");
d1040 1
a1040 1
  //    (b) date is no earlier than Jan 1, 1970 (SCE's self imposed lower limit)
d1044 1
a1044 7
  bool allDigits = true;
  for( size_t i = 0; i < dateString.size(); i++ )
      if( !isdigit( dateString[i] ) )
      {
          allDigits = false;
          break;
      }
d1046 3
a1048 3
      || (!allDigits)
      || (dateString < "19700101")) {
    std::string badDate("99999999");
d1054 1
a1054 1
    std::string futureDate("20361231");
d1060 1
a1060 1
    SCEDate theDate(dateString.c_str());
a1064 1

d1108 1
a1108 1
  : setOfIllegalCharacters_ (0),
d1111 1
a1111 1
    sceErrFacility_(0)
@


1.4.2.2
log
@Went all the way to std::cout
@
text
@d4 1
a4 1
#include <ostream>
d9 1
a9 1
#include <iostream>
@


1.4.2.3
log
@New LgFrDatetime class
@
text
@d733 1
a733 1
    LgFrDatetime startDate(parseDateString(token, theCal));
d747 1
a747 1
    LgFrDatetime endDate(parseDateString(token, theCal));
d813 1
a813 1
    LgFrDatetime startDate(parseDateString(token, theCal));
d827 1
a827 1
    LgFrDatetime endDate(parseDateString(token, theCal));
d1019 1
a1019 1
LgFrDatetime
d1036 1
a1036 1
  // to get the max legal LgFrDatetime without knowing how its implemented!
d1038 1
a1038 1
    std::string pastDate("19701225");
d1076 1
a1076 1
    LgFrDatetime theDate(dateString.c_str());
@


1.3
log
@pegging now picks up negative usage rates and minor message
@
text
@d5 1
@


1.2
log
@modified date parsing to accept any date > 20361231.
@
text
@d562 1
d625 5
a629 1
      (*sceErrFacility_)("MissingData",MclArgList() << "int" << fileName << dataLine);
@


1.1
log
@Initial revision
@
text
@d1041 1
a1041 2
      || (dateString < "19010101") 
      || (dateString > "20361231")) {
d1045 7
@


1.1.1.1
log
@Import sce
@
text
@@


1.1.1.1.4.1
log
@Updated date parsing so that and numeric date greater than 20361231 is
accepted as 20361231.
@
text
@d1041 2
a1042 1
      || (dateString < "19010101")) {
a1045 7

  // If the date is greater than 20361231, then make it future date (valid)
  if (dateString > "20361231") {
    RWCString futureDate("20361231");
    return theCal.yyyymmdd(futureDate);
  }

@


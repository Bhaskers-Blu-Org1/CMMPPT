head	1.39;
access;
symbols
	sce_5_01_20080919:1.34
	latest_sce_4_20_20060523:1.27.0.4
	sce_4_20_20060523:1.27
	latest_sce4_20_OSL:1.27.0.2
	sce_4_20_OSL:1.27
	sce_4_20_20051222:1.27
	sce_4_10_30050426:1.25
	sce_4_05_20040511:1.22
	sce_4_00_20040201:1.19
	nextGenBranch:1.14.0.2
	nextGenRoot:1.14
	sce_3_30_20030627:1.14
	EndRw-branch:1.11.0.2
	Root-of-EndRw:1.11
	EndWitRw-branch:1.10.0.4
	Root-of-EndWitRw:1.10
	RwToStl-branch:1.10.0.2
	Root-of-RwToStl:1.10
	latest_sce_3_10_20010924:1.4.0.2
	sce_3_10_20010924:1.4
	latest_sce_3_00_20010601:1.1.0.2
	sce_3_00_20010601:1.1;
locks; strict;
comment	@ * @;


1.39
date	2010.12.15.23.53.22;	author ervolina;	state Exp;
branches;
next	1.38;

1.38
date	2010.04.12.21.27.02;	author ervolina;	state Exp;
branches;
next	1.37;

1.37
date	2010.04.07.21.38.17;	author ervolina;	state Exp;
branches;
next	1.36;

1.36
date	2010.03.26.19.48.23;	author ervolina;	state Exp;
branches;
next	1.35;

1.35
date	2009.09.09.15.41.56;	author ervolina;	state Exp;
branches;
next	1.34;

1.34
date	2008.06.23.19.07.11;	author ervolina;	state Exp;
branches;
next	1.33;

1.33
date	2008.06.05.19.04.33;	author ervolina;	state Exp;
branches;
next	1.32;

1.32
date	2008.06.04.16.26.10;	author ervolina;	state Exp;
branches;
next	1.31;

1.31
date	2008.06.04.16.08.22;	author ervolina;	state Exp;
branches;
next	1.30;

1.30
date	2008.03.14.20.19.39;	author ervolina;	state Exp;
branches;
next	1.29;

1.29
date	2007.03.21.18.03.28;	author ervolina;	state Exp;
branches;
next	1.28;

1.28
date	2006.08.10.17.59.49;	author ervolina;	state Exp;
branches;
next	1.27;

1.27
date	2005.11.02.18.40.00;	author ervolina;	state Exp;
branches;
next	1.26;

1.26
date	2005.08.10.22.44.52;	author ervolina;	state Exp;
branches;
next	1.25;

1.25
date	2005.05.05.20.22.11;	author ervolina;	state Exp;
branches;
next	1.24;

1.24
date	2005.02.15.20.45.00;	author ervolina;	state Exp;
branches;
next	1.23;

1.23
date	2004.10.08.13.03.43;	author ervolina;	state Exp;
branches;
next	1.22;

1.22
date	2004.05.06.20.55.05;	author ervolina;	state Exp;
branches;
next	1.21;

1.21
date	2004.05.06.15.47.36;	author ervolina;	state Exp;
branches;
next	1.20;

1.20
date	2004.05.04.22.58.24;	author ervolina;	state Exp;
branches;
next	1.19;

1.19
date	2004.01.22.02.47.47;	author ervolina;	state Exp;
branches;
next	1.18;

1.18
date	2004.01.12.02.17.29;	author ervolina;	state Exp;
branches;
next	1.17;

1.17
date	2004.01.12.01.51.32;	author ervolina;	state Exp;
branches;
next	1.16;

1.16
date	2004.01.11.17.12.41;	author ervolina;	state Exp;
branches;
next	1.15;

1.15
date	2004.01.10.17.56.10;	author ervolina;	state Exp;
branches;
next	1.14;

1.14
date	2003.07.03.15.50.41;	author ervolina;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.26.23.09.37;	author ervolina;	state Exp;
branches;
next	1.12;

1.12
date	2003.01.15.19.36.54;	author rwToStl;	state Exp;
branches;
next	1.11;

1.11
date	2002.11.26.14.25.28;	author fasano;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2001.12.21.20.10.30;	author ervolina;	state Exp;
branches;
next	1.9;

1.9
date	2001.12.18.17.01.51;	author ervolina;	state Exp;
branches;
next	1.8;

1.8
date	2001.12.03.13.38.49;	author ervolina;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.20.22.13.11;	author ervolina;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.19.16.06.24;	author ervolina;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.17.22.04.39;	author ervolina;	state Exp;
branches;
next	1.4;

1.4
date	2001.09.24.16.38.13;	author ervolina;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.28.15.46.13;	author ervolina;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.14.21.00.58;	author ervolina;	state Exp;
branches;
next	1.1;

1.1
date	2001.06.01.16.53.54;	author ervolina;	state Exp;
branches;
next	;

1.11.2.1
date	2003.01.08.17.43.13;	author rwToStl;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2003.01.09.13.14.35;	author rwToStl;	state Exp;
branches;
next	;


desc
@@


1.39
log
@6.2 latest commits to old repository
@
text
@// file: aEngMgr.C
// author:  tom

#include <string>
#include <iostream>
#include <scenario/src/RWToSTLHelpers.h>
#include <assert.h>
#include <mcl/src/mcl.h>
#include <scenario/src/machdep.h>
#include <sce/src/scenSceP.h> 
#include <scenario/src/calendar.h>
#include <scenario/src/timeVecs.h>
#include <sce/src/aEngMgr.h>
#include <sce/src/dmApData.h>
#include <sce/src/appData.h>
#include <sce/src/ipSce.h>
#include <sce/src/allocLet.h>
#include <sce/src/mPlantH.h>
#include <sce/src/sceParam.h>
#include <sce/src/sceCrtLs.h>
#include <sce/src/scenSce.h>
#include <sce/src/srtStrat.h>

#define AENGMGR_FLT_EPS  0.00001

// #define AENGMGR_DUMP_WIT_DATA_FILE
// #define DEBUG_SET_PURE_OPTIONS
// #define DEBUG_MANDATORY_MAX_ATP
// #define DEBUG_PURE_OPTION_MAX_ATP
// #define DEBUG_CUSTOMER_CHOICE_MAX_ATP



/********************************************************************************
// heurIncAlloc()
********************************************************************************/
void
LgFrSceAllocationEngineMgr::heurIncAlloc()
{
  int nPeriods;
  witGetNPeriods(theWitRun_, &nPeriods);

  LgFrSceSetOfParameters & setOfParameters =  sceScenSP_->setOfParameters();    

  std::string heurAllocBacklogPriority = setOfParameters.getString("heurAllocBacklogPriority");

  int useRolloverBacklogPolicy;
  if      (0 == sce::compareStringsCaseIns( heurAllocBacklogPriority, "memorylessRoll" )) 
    useRolloverBacklogPolicy = 1;
  else if (0 == sce::compareStringsCaseIns( heurAllocBacklogPriority, "immediate" )) 
    useRolloverBacklogPolicy = 0;
  else {
    useRolloverBacklogPolicy = 1;
    std::cerr << "Warning:  illegal value for parameter heurAllocBacklogPriority ==> "
	 << heurAllocBacklogPriority << "\n Using ==> memorylessRoll\n";
  }



  // we'll keep walking until we hit the last allocLet
  int aCount = 0;
  while (aPointer_ < listMax_) {
    LgFrSceAllocLet & myAllocLet = *(allocLetList_[aPointer_]);
    float qtyShip;
    // OK, do the allocation
    witIncHeurAlloc(theWitRun_,
                    myAllocLet.partName().c_str(),
                    myAllocLet.demandName().c_str(),
                    myAllocLet.shipPd(),
                    myAllocLet.qtyDemand(),
                    &qtyShip);

    // regardless of what happened, increment the allocation counter
    aCount++;

    // set the shipQty
    myAllocLet.qtyShip(qtyShip);

    // what is backlogQty
    float backlogQty = myAllocLet.qtyDemand() - qtyShip;

    // set the allocationFlag
    if (backlogQty < 0.001) {
      myAllocLet.allocated(1);
    }

    // Write to trace (if enabled)
    if (traceFlag_)       {

#if 0 
      // TEMPORARY DEBUG
      // get the part list
      int nParts;
      char ** partList;
      witGetParts(theWitRun_, &nParts, &partList);
      std::string p, g;
      int isPartGood;
      std::string p0 = partList[0];
      isPartGood = mpHelper_->isPartSpecialGeoPlannerDemandPart(theWitRun_, p0, p, g);
#endif
      outFile_ << myAllocLet.hrTraceString(theWitRun_, mpHelper_, aCount);
    }
    
    // if we DID fully commit myAllocLet then 
    // increment the allocation pointer and move on
    if (myAllocLet.allocated())  {
      aPointer_++;
    }

    // If we DID NOT  fully ship myAllocLet then ...
    else  {
      int newShipPd = myAllocLet.shipPd() + 1;

      // if we are at the end of the horizon then we are done with 
      // this allocLet and we just increment the pointer
      if (newShipPd == nPeriods) {
	myAllocLet.allocated(1);
        aPointer_++;    
      }

      // For Rollover do the following else {} 
      else if (useRolloverBacklogPolicy) {
	// **********************************************
	// *****  ROLLOVER VIA Pointers *****************
	// **********************************************
	// search through the list for an allocLet to Roll to
	int isThereAnAllocLetInNextShipPd = 0;

	// Check to see if nextShipPd == backlogDependentPtr's demandPd
	LgFrSceAllocLet * backlogDependentPtr =  myAllocLet.backlogDependent();
	if (backlogDependentPtr != 0) {
	  // ok, so there is a potential alloclet to roll this backlog to
	  // we just need to check if the periods are the same
	  int blogDepShipPd = backlogDependentPtr->shipPd();
	  // these asserts will fail if the user sets priority to be increasing over
	  // time for the part,demand pair.  This should be a FINISH_ME to check the 
	  // priority matrix up front.
	  assert(blogDepShipPd >= newShipPd);
	  assert(backlogDependentPtr->allocated() == 0);
	  if (blogDepShipPd == newShipPd) {
	    isThereAnAllocLetInNextShipPd = 1;
	    assert(backlogDependentPtr->qtyShip() < 0.0001);
	    float newDemandQty = backlogDependentPtr->qtyDemand() + backlogQty;
	    // update the demandQty on this rolled-to allocLet (add in the backlog)
	    backlogDependentPtr->qtyDemand(newDemandQty);
	    // mark this current allocLet as being done 
	    myAllocLet.allocated(1);
	    aPointer_++;
	  }
	}

	// If there is not an alloclet to roll to (in the exact period we want)
	// then we must change this alloclet to pickup the new priority according to 
	// the priority matrix.  We also update the shipPd,demandPD, and qty.
	if (! isThereAnAllocLetInNextShipPd) {
	  myAllocLet.shipPd(newShipPd);
	  myAllocLet.demandPd(newShipPd);
	  myAllocLet.qtyDemand(backlogQty);
	  myAllocLet.qtyShip(0.0);
	  int * priorityVec;
	  witGetDemandPriority(theWitRun_, 
			       myAllocLet.partName().c_str(), 
			       myAllocLet.demandName().c_str(), 
			       &priorityVec);
	  myAllocLet.priority(priorityVec[newShipPd]);
	  witFree(priorityVec);
	}


      }  // matches   ....    else if (useRolloverBacklogPolicy) {



      // do this if useRolloverBacklogPolicy == false
      else {
        // increment the shipPd (roll the demand)
        myAllocLet.shipPd(newShipPd);
        myAllocLet.qtyDemand(backlogQty);
        myAllocLet.qtyShip(0.0);
      }

      // Now sort the rest of the list
      if (listMax_ > aPointer_) {
	qsort((allocLetList_+aPointer_),            // starting from the aPointer_
	      listMax_ - aPointer_,                      // residual length
	      sizeof(LgFrSceAllocLet*), 
	      sortStrategy_->compareVoidFunc());        
      }
    }
  }
}



// **********************************************************************
// heurEqAlloc()
// **********************************************************************
void
LgFrSceAllocationEngineMgr::heurEqAlloc()
{
  char ** eqPartList;
  char ** eqDemandList;
  int   * eqShipPd;
  float * eqDemandQty;
  float * eqShipQty;
  
  int nPeriods;
  witGetNPeriods(theWitRun_, &nPeriods);

  LgFrSceSetOfParameters & setOfParameters =  sceScenSP_->setOfParameters();    

  std::string heurAllocBacklogPriority = setOfParameters.getString("heurAllocBacklogPriority");

  int useRolloverBacklogPolicy;
  if      (0 == sce::compareStringsCaseIns( heurAllocBacklogPriority, "memorylessRoll" )) 
    useRolloverBacklogPolicy = 1;
  else if (0 == sce::compareStringsCaseIns( heurAllocBacklogPriority, "immediate" )) 
    useRolloverBacklogPolicy = 0;
  else {
    useRolloverBacklogPolicy = 1;
    std::cerr << "Warning:  illegal value for parameter heurAllocBacklogPriority ==> "
	 << heurAllocBacklogPriority << "\n Using ==> memorylessRoll\n";
  }
  
  std::cout << "     ... Begin WIT allocations" << std::endl;


  // counters:
  // eCount:  number of api calls to witEqAlloc()
  // aCount:  number of allocLets fed to witEqAlloc()
  // aWithinEq: number of allocLets within current equitableGroup
  // aSuccessWithin: number of AllocLets that were fully "allocated" within current equitableGroup

  //
  // Keep picking off allocLets while the compare is equal

  int aCount = 0;
  int eCount = 0;

  while (aPointer_ < listMax_) {
    // intiialize local counters
    int aWithinEq = 0;
    int aSuccessWithin = 0;

    // get the first one, which will be the reference
    LgFrSceAllocLet & myAllocLet = *(allocLetList_[aPointer_]);
    eCount++;
    aWithinEq++;

    int finishedEquitGroup = 0;
    int isNextEquitable = 0;

    while (! finishedEquitGroup ) {    
      if ((aPointer_ + aWithinEq) < listMax_) {
        LgFrSceAllocLet & nextEquitAlloc = *(allocLetList_[aPointer_+ aWithinEq]);
	// Sorry for the complicated code ... the first conditional below, 
	// (ie, that demandPd's match) is only necessary when we are not using "rollover")
        if ( (useRolloverBacklogPolicy || 
	         (myAllocLet.demandPd() == nextEquitAlloc.demandPd())
	     )       
	     &&
               myAllocLet.shipPd()   == nextEquitAlloc.shipPd()         
	     &&
               myAllocLet.priority() == nextEquitAlloc.priority() 
	    ) {
          isNextEquitable = 1;
          aWithinEq++;
        }
        else {
          isNextEquitable = 0;
        }
      }
      else {
        isNextEquitable = 0;
      } 
      
      // if the next one is not equitable, then we have 
      // the 
      if (! isNextEquitable) {
        // since it's a non-equitable match, we have defined our equitableGroup
        eqShipPd      =  new int[aWithinEq];
        eqDemandQty   =  new float[aWithinEq];
        eqPartList    =  new char * [aWithinEq];
        eqDemandList  =  new char * [aWithinEq];
        



        int j = 0; 
        for(j=0; j<aWithinEq; j++) {
	  LgFrSceAllocLet & jthAllocLet = *(allocLetList_[aPointer_ + j]);
          eqPartList[j]   = strdup((jthAllocLet.partName()).c_str());
          eqDemandList[j] = strdup((jthAllocLet.demandName()).c_str());
          eqShipPd[j]     = jthAllocLet.shipPd();
          eqDemandQty[j]  = jthAllocLet.qtyDemand();
        }

	
        witEqHeurAlloc(theWitRun_,
                       aWithinEq,
                       (const char * const *)eqPartList,
                       (const char * const *)eqDemandList,
                       eqShipPd,
                       eqDemandQty,
                       &eqShipQty
                       );
        
        // check the results and update things
        // loop over each allocLEt within the equitableGroup
        for(j=0; j<aWithinEq; j++) {
	  LgFrSceAllocLet & currAllocLet = *(allocLetList_[aPointer_+ j]);

          // regardless of what happened, increment the allocation counter
          aCount++;
          // set the shipQty
          currAllocLet.qtyShip(eqShipQty[j]);
          // what is backlogQty
          float backlogQty = currAllocLet.qtyDemand() - eqShipQty[j];
          // determine if alloclet is FULLY satisfied and 
          // set the allocationFlag
          if (backlogQty < 0.001) {
            currAllocLet.allocated(1);
          }
          // Write to trace (if enabled)
          if (traceFlag_)       {
            outFile_ << currAllocLet.hrTraceString(theWitRun_, mpHelper_, eCount );
          }
          // if we DID ship everything 
          // increment the allocation pointer and move on
          if (currAllocLet.allocated())  {
            aSuccessWithin++;
          }
          // If we DID NOT  ship everything ...
          // Apply ==>  backlogStrategy
          // finish_me: need to figure this out ... 
          //     perishability 
          //     minimums and cumMins (??)
          //
          // For now we increment the shipPd and let the sortStrategy 
          // redo things.  
          else  {
            int nextShipPd = currAllocLet.shipPd() + 1;
            
            // if we are at the end of the horizon then we are done with this allocLet
            if (nextShipPd == nPeriods) {
              // then set the allocated Flag to 1
              currAllocLet.allocated(1);
              aSuccessWithin++;
            }

	    // For Rollover do the following else {} otherwise do the ifdef 0 else	    
            else if (useRolloverBacklogPolicy) { 





              // **********************************************
	      // *****  ROLLOVER VIA Pointers *****************
	      // **********************************************
	      // search through the list for an allocLet to Roll to
	      int isThereAnAllocLetInNextShipPd = 0;

	      // Check to see if nextShipPd == backlogDependentPtr's demandPd
	      LgFrSceAllocLet * backlogDependentPtr =  currAllocLet.backlogDependent();
	      if (backlogDependentPtr == 0) {
		// There is no one to roll to, so just use this one
		; // noop ??
	      }
	      else {
		int blogDepShipPd = backlogDependentPtr->shipPd();
		assert(blogDepShipPd >= nextShipPd);

		if (backlogDependentPtr->allocated()) {
		  std::cout << "About to fail an assert ...\n";
		  std::cout << "currAllocLet:" << currAllocLet.traceString() << "\n";
		  std::cout << "baclkogDependentAlloclet:" << backlogDependentPtr->traceString() << std::endl;
		  outFile_.close();
		}
		assert(backlogDependentPtr->allocated() == 0);
		if (blogDepShipPd == nextShipPd) {
		  isThereAnAllocLetInNextShipPd = 1;
		  assert(backlogDependentPtr->qtyShip() < 0.0001);
		  float newDemandQty = backlogDependentPtr->qtyDemand() + backlogQty;
		  // update the demandQty on this rolled-to allocLet (add in the backlog)
		  backlogDependentPtr->qtyDemand(newDemandQty);
		  // mark this current allocLet as being done 
		  currAllocLet.allocated(1);
		  aSuccessWithin++;
		}
	      }

	      if (! isThereAnAllocLetInNextShipPd) {
		currAllocLet.shipPd(nextShipPd);
		currAllocLet.demandPd(nextShipPd);
		currAllocLet.qtyDemand(backlogQty);
		currAllocLet.qtyShip(0.0);
		int * priorityVec;
		witGetDemandPriority(theWitRun_, 
				     currAllocLet.partName().c_str(), 
				     currAllocLet.demandName().c_str(), 
				     &priorityVec);
		currAllocLet.priority(priorityVec[nextShipPd]);
		witFree(priorityVec);
	      }
	    }	      
	    // JUST MADE  A BIG MESS !!!!!!!!!!!!!!!!!!!!!!
	    
	    else { 
              // *********************************
	      // *****  NON- ROLLOVER *****************
	      // *********************************
	      currAllocLet.shipPd(nextShipPd);
	      currAllocLet.qtyDemand(backlogQty);
	      currAllocLet.qtyShip(0.0);
            }                      
	    
	    
          }
        }           // end of "for (j=0  ...
        
        // Now sort just the elements within the equitableGroup
        // That will cause the allocated ones to move to the "front" of the subArray
        // Then we move the aPointer exactly aSuccessWithin elements forward
        
        // don't need to do this if all were satisfied
        if (aSuccessWithin < aWithinEq) {
          qsort((allocLetList_+ aPointer_),            // starting from the aPointer_
                aWithinEq,                             // residual length
                sizeof(LgFrSceAllocLet *), 
                sortStrategy_->compareVoidFunc());          
        }
        
        // Increment aPointer_ by aSuccessWithin
        aPointer_ += aSuccessWithin;

        // Do the final sort of the remaining allocLets
        qsort((allocLetList_+ aPointer_),            // starting from the aPointer_
              listMax_ - aPointer_,                  // residual length
              sizeof(LgFrSceAllocLet *), 
              sortStrategy_->compareVoidFunc());          

        // indicate that we've completed an equit group
        finishedEquitGroup = 1;

        for(j=0; j<aWithinEq; j++) {
          free(eqPartList[j]);
          free(eqDemandList[j]);
        }
	delete [] eqShipPd;    
	delete [] eqDemandQty; 
	witFree(eqShipQty);    
	delete [] eqPartList;  
	delete [] eqDemandList;
      }           // end of "if (! isNextEquitable)  ...
    }           // end of "while (! finishedEquitGroup ) ...
  }           // end of "while (aPointer_ < listMax_) ...
  std::cout << "     ...  WIT allocations completed" << std::endl;

}





// **********************************************************************
// **********************************************************************
// implode()
// **********************************************************************
// **********************************************************************
void
LgFrSceAllocationEngineMgr::implode(LgFrSceCritList & theCritList)
{
  // open the trace file
  if (traceFlag_) {
      outFile_.open(traceFileName_.c_str() );//, 0666);
    if (outFile_.fail()) {
      std::cerr << "Unable to open File for output:  Trace File: "
	   << traceFileName_ << "\n" 
	   << "Terminating the program\n\n";
      exit(8);
    }
  }


  LgFrSceSetOfParameters & setOfParameters =  sceScenSP_->setOfParameters();    
  std::string heurAllocSortStrategy = setOfParameters.getString("heurAllocSortStrategy");
  
  std::cout << "Executing (Heur Alloc) " 
	    << usageName_
	    << " engine using ("
       << heurAllocSortStrategy 
       << ") sort strategy ..." 
       << std::endl;    

#ifdef AENGMGR_DUMP_WIT_DATA_FILE
  std::cout << "     ... (debug mode) ... Writing the (heurAlloc) wit data file ..." << std::endl;                      
  sceScenSP_->setWitInformationalMessaging(theWitRun_, SCE_WIT_MESSAGING_ON);
  witWriteData(theWitRun_, "preSetPureOptionDemand.witData");
  sceScenSP_->setWitInformationalMessaging(theWitRun_, SCE_WIT_MESSAGING_OFF);          
#endif

  // Set DemandVols on special Feature parts ... custChoice is set to max feat vol
  // and pureOptional are set to bigM
  this->setPureOptionDemandVols();

  // Test the iput to see if the priorities are non-increasing
  // This is needed for backlogPolicy=memorylessRoll
  this->testForNonIncreasingPriorities();

#ifdef AENGMGR_DUMP_WIT_DATA_FILE
  std::cout << "     ... (debug mode) ... Writing the (heurAlloc) wit data file ..." << std::endl;                      
  sceScenSP_->setWitInformationalMessaging(theWitRun_, SCE_WIT_MESSAGING_ON);
  witWriteData(theWitRun_, "postSetPureOptionDemand.witData");
  witDisplayData( theWitRun_,"debug_aEngMgr.witEcho");
  sceScenSP_->setWitInformationalMessaging(theWitRun_, SCE_WIT_MESSAGING_OFF);          
#endif



  // --- Greedy Search Granularity ---
  std::string indpGreedySearchIncFile = setOfParameters.getString("indpGreedySearchIncFile");
  std::string greedySearchIncFile = setOfParameters.getString("greedySearchIncFile");
  int isGreedySearchIncSetInFile = ( (indpGreedySearchIncFile == "") && (greedySearchIncFile == "")) ? 0 : 1;
  if (! isGreedySearchIncSetInFile) {
    std::cout << "     ... setting Greedy Search Increments Globally." << std::endl;
    std::string greedySearchIncrementMethod = setOfParameters.getString("greedySearchIncrementMethod");
    if (sce::compareStringsCaseIns(greedySearchIncrementMethod, "autoScale") == 0) {
      float searchIncScaleFactor =  setOfParameters.getFloat("searchIncScaleFactor");
      sceScenSP_->setHeuristicSearchIncrement(theWitRun_, greedySearchIncrementMethod, searchIncScaleFactor); 
    }
    else {
      float searchIncAbsValue =  setOfParameters.getFloat("searchIncAbsValue");
      sceScenSP_->setHeuristicSearchIncrement(theWitRun_, greedySearchIncrementMethod, searchIncAbsValue); 
    }
  }
  else {
    //    std::cout << "Skipping Greedy Search Increment Global settings since input files were used." << std::endl;
  }


#if 0
  // FOR MRP TESTING ONLY ... Although make this a formal diagnostic report
  witSetComputeCriticalList(theWitRun_, WitTRUE);
  witSetPgdCritListMode(theWitRun_, WitTRUE);
#endif

  // See if a critical list is wanted.
  witBoolean computeCriticalList;
  witGetComputeCriticalList ( theWitRun_, &computeCriticalList );  


  //   // See if a pegged critical list is wanted.
  //  witBoolean computePeggedCriticalList;
  //  witGetPgdCritListMode ( theWitRun_, &computePeggedCriticalList );  

  //   witBoolean doesWitPipExist;

  int equitability;
  witGetEquitability(theWitRun_, &equitability);


  // Dump the heuristic version of the wit.data file
  if (setOfParameters.getBool("printHeurWitDataFile"))  {
    std::string witDataFileName = setOfParameters.getString("heurWitDataFileName");
    sceScenSP_->setWitInformationalMessaging(theWitRun_, SCE_WIT_MESSAGING_ON);
    witWriteData(theWitRun_, witDataFileName.c_str());
    if (! setOfParameters.getBool("printWitMsgFile"))   {
      sceScenSP_->setWitInformationalMessaging(theWitRun_, SCE_WIT_MESSAGING_OFF);          
    }
  }
  
  



  // tell Wit to get ready
  std::cout << "     ...  witStartHeurAlloc" << std::endl;
  witStartHeurAlloc(theWitRun_);

  

  // ////////////////////////////////////////////////////////////////////////////
  //                                                                          //
  //   We're all set up. Now for the fun...multiple implosion iterations      //
  //   to handle rollover, features, and min demands as needed                //
  //                                                                          //
  // ////////////////////////////////////////////////////////////////////////////





  // ==================================================
  // STEP 1: First Implode to MINIMUM Demands ...
  //          a) if there are no mins, then skip this whole step
  //          b) set demand vols to the mins (stored in witCumShipSoftLowerBound)
  //             AND store the residual demand (aboveMinDemandVol) in the
  //             demandAppData for each demand.
  //          c) Do ONE basic witHeurImplode to satisfy mins.  Note: we
  //             may need to address user's concerns that they want some
  //             control over the allocation of mins!
  //          d) Update the global (output) schedules: ship, prod, subsProd
  //          e) Update minLotSize, supplyVol, and prodVolUB in witRun (prep for next iteration)
  //          f) merge critical list into the global one
  //          g) Load the residual demands vols into the WitRun (prep for next iteration)
  //             (these residual demands are stored in demand App data)
  // ==================================================  
  

  std::string heurAllocMinsSortStrategy = setOfParameters.getString("heurAllocMinsSortStrategy");
  int sortID = 1;
  int minsSortId = this->sortID(heurAllocMinsSortStrategy);
  LgFrSceSortStrategy * mySortStrategy = new LgFrSceSortStrategy(minsSortId);
  
  // set allocMgr's strategy.  
  //  std::cout << "     ...  setting sortStrategy" << std::endl;
  this->sortStrategy(mySortStrategy);
  //  std::cout << "     ...  setting sortStrategy OK" << std::endl;
  
  if (sceScenSP_->nDemandsWithNonZeroMins() > 0) {
    
    std::cout << "     ... allocating to mins using (heurAlloc) scheme and ("
	      << heurAllocMinsSortStrategy 
	      << ") sort strategy ..." 
	      << std::endl;    
  }  //   end   if (nDemandsWithNonZeroMins() > 0)  
  
  // intitialize allocLetList_ for minimum demands
  // Get the minimum demands and calculate the residual "aboveMinDemands"
  // First "wave" of allocLets are exclusively for mins
  // The aboveMinDemands are stored in demand appData
  this->initializeAllocDataWithMins();
  
  // allocate this bunch of allocLets
  if  (1 == equitability){
    this->heurIncAlloc();
  }
  else {
    this->heurEqAlloc();
  }
  
  
  //  De-allocate the allocLet list for this pass????
  if (listMax_ > 0) {
    delete [] allocLetList_;
    delete [] vecAllocLetList_;
  }
  
  delete mySortStrategy;
  
  
  
  
  // ==================================================
  // STEP 2: Implode  residual "above min" demand
  //          a) If there are no mins, then the "residual above min demand"
  //             is simply the original demandVol
  // ==================================================  

  
  std::cout << "  ... First pass allocation  using (heurAlloc) scheme and ("
       << heurAllocSortStrategy 
       << ") sort strategy ..." 
       << std::endl;    
  

  int aboveMinSortId = this->sortID(heurAllocSortStrategy);
  mySortStrategy = new LgFrSceSortStrategy(aboveMinSortId);
  
  // set allocMgr's strategy.  
  this->sortStrategy(mySortStrategy);

  // intitialize allocLetList_ for minimum demands
  // Get the minimum demands and calculate the residual "aboveMinDemands"
  // First "wave" of allocLets are exclusively for mins
  // The aboveMinDemands are stored in demand appData
  this->initializeAllocDataAboveMins();

  // allocate this bunch of allocLets
  if  (1 == equitability){
    this->heurIncAlloc();
  }
  else {
    this->heurEqAlloc();
  }


  //  De-allocate the allocLet list for this pass
  if (listMax_ > 0) {
    delete [] allocLetList_;
    delete [] vecAllocLetList_;
  }

  delete mySortStrategy;


  // ==================================================
  // STEP 3: Feature Cleanup implosion ...
  // ==================================================
  //    This iteration needs some explanation
  //       Heuristic is not smart enough to allocate to features
  // ==================================================  
  
  if (sceScenSP_->nStandaloneFeatureArcs() > 0) {
    std::string heurAllocFeatSortStrategy = setOfParameters.getString("heurAllocFeatSortStrategy");
    int featSortId = this->sortID(heurAllocFeatSortStrategy);
    LgFrSceSortStrategy * mySortStrategy = new LgFrSceSortStrategy(featSortId);
    
    std::cout << "  ... Feature pass allocation using (heurAlloc) scheme and ("
	      << heurAllocFeatSortStrategy << ") sort strategy ..." << std::endl;    
    
    this->sortStrategy(mySortStrategy);
    
    // FINISH_ME_61: 
    //    - get rid of wit34
    //    - variable periods
    //    - multiAttr demand, dated vs vector ???
    //    - FINISH for Selective Sets
    //    - Do we need two codes sets ?!?!?!? setPureOption ... ForMaxAtp  ????
    // setPureOptionBuildAllocVols ... determine demandVols for feature 
    bool maxImpliedCommitsForAtp  = setOfParameters.getBool("maxImpliedCommitsForAtp");
    if (maxImpliedCommitsForAtp) 
      this->setPureOptionBuildAllocVolsForMaxATP();
    else
      this->setPureOptionBuildAllocVols();

    this->initializeAllocDataFeaturePass();
    
    
    // implode !!
    if  (1 == equitability){
      this->heurIncAlloc();
    }
    else {
      this->heurEqAlloc();
    }
    
    if (listMax_ > 0) {
      delete [] allocLetList_;
      delete [] vecAllocLetList_;
    }
    delete mySortStrategy;

  } // end of features pass
  
  witFinishHeurAlloc(theWitRun_);
  
  if (computeCriticalList) 
    theCritList.merge( theWitRun_);
  

  bool doPegging = setOfParameters.getBool("doPegging");
  if (doPegging) {
    witPostprocess (theWitRun_ );    
    witBuildPip(theWitRun_);
    sceScenSP_->loadPIPDataIntoAppData(theWitRun_);
  }

  outFile_.close();

}



// Test the iput to see if the priorities are non-increasing
// This is needed for backlogPolicy=memorylessRoll
//   testForNonIncreasingPriorities();
//  ------------------------------- 
void
LgFrSceAllocationEngineMgr::testForNonIncreasingPriorities()
{


  int   * priority;
  int nPeriods;
  char  *partName, *demandName;
  // float * demandVol;
  
    
  witGetNPeriods(theWitRun_, &nPeriods);
  int nParts;
  char  **partList;

  LgFrSceSetOfParameters & setOfParameters =  sceScenSP_->setOfParameters();    
  std::string heurAllocBacklogPriority = setOfParameters.getString("heurAllocBacklogPriority");
  int useRolloverBacklogPolicy = 1;

  if  (0 == sce::compareStringsCaseIns( heurAllocBacklogPriority, "memorylessRoll" )) 
    useRolloverBacklogPolicy = 1;
  else if (0 == sce::compareStringsCaseIns( heurAllocBacklogPriority, "immediate" )) 
    useRolloverBacklogPolicy = 0;
  else {
    useRolloverBacklogPolicy = 1;
    std::cerr << "Warning:  illegal value for parameter heurAllocBacklogPriority ==> "
	 << heurAllocBacklogPriority << "\n Using ==> memorylessRoll\n";
  }

  // if we are not using backlogRollover, then we don't need this test
  if (!useRolloverBacklogPolicy)
    return;


  std::cout << "     ... testing priorities for non-increasing values" << std::endl;

  witGetParts(theWitRun_, &nParts, &partList);




  // first count how many allocLets we need ==> listMax.
  // NOTE: we only count non-zero minDemandVols
  int hasIncreasingPriorityMessageBeenToldYet = 0;
  int i = 0; 
  for(i=0; i<nParts; i++){
    partName = partList[i];
    int nDemands;
    char ** dList;
    witGetPartDemands(theWitRun_, partList[i], &nDemands, &dList);
    int j = 0; 
    for(j=0; j<nDemands; j++){
      demandName = dList[j];
      witGetDemandPriority( theWitRun_, partName, demandName,
                                 &priority);
      int prevPrio = -INT_MAX;

      int hasPriorityChanged = 0;
	
      int t = 0; 
      for (t=0; t<nPeriods; t++)   {
        if (prevPrio > priority[t]) {
	  if (! hasIncreasingPriorityMessageBeenToldYet) {
	    std::cout << "Warning: priority vector is increasing ... \n"
		      << "Part: " << partName << "\n"
		      << "Demand: " << demandName << "\n"
		      << "period: " << t << std::endl;
	    hasIncreasingPriorityMessageBeenToldYet = 1;
	  }
	  // temp fix !!!
	  priority[t-1] = priority[t];
	  hasPriorityChanged = 1;
	}
	
	prevPrio = priority[t];
      }
      if (hasPriorityChanged)
	witSetDemandPriority( theWitRun_, partName, demandName,
                                 priority);

      witFree(dList[j]);
      witFree(priority);
    }
    witFree(dList);
    witFree(partList[i]);
  }
  witFree(partList);
  //  std::cout << "     ... done testing priorities for non-increasing values" << std::endl;
}







// ******************************************************************************
// initializeAllocDataWithMins()
// ------------------------------
// Set up allocLet List for second (main) pass through Heuristic Allocation Pass
//
// Loop through the CumShipBounds to derive the MinimumDemandVols
// - Create an allocLet for each positive minDemandVol
// - Compute and store away the aboveMinDemandVols in demand app data
// - QSORT the allocLetList
// - Note: the calling program is responsible for deleting any demand app data 
//         ptrs that are "new-ed" in here.
// - FINISH_ME: Put allocVol in appData
// ********************************************************************************
void
LgFrSceAllocationEngineMgr::initializeAllocDataWithMins()
{
  int   * priority;
  int nPeriods;
  char  *partName, *demandName;
  float * demandVol;
  
    
  witGetNPeriods(theWitRun_, &nPeriods);
  int nParts;
  char  **partList;
  witGetParts(theWitRun_, &nParts, &partList);

  std::cout << "     ... initializing allocData for mins" << std::endl;

  aPointer_ = 0;
  listMax_ = 0;

  // first count how many allocLets we need ==> listMax.
  // NOTE: we only count non-zero minDemandVols
  int i = 0; 
  for(i=0; i<nParts; i++){
    partName = partList[i];
    int nDemands;
    char ** dList;
    witGetPartDemands(theWitRun_, partList[i], &nDemands, &dList);
    int j = 0; 
    for(j=0; j<nDemands; j++){
      demandName = dList[j];
      float * cumShipBound, * hardLower, * hardUpper;
      witGetDemandCumShipBounds( theWitRun_, partName, demandName,
                                 &hardLower,
                                 &cumShipBound,
                                 &hardUpper);
      witFree ( hardLower);
      witFree ( hardUpper );
      
      // un-cum the lower bounds and use them as the demand vols for the first pass
      LgFrTimeVecFloat minDemandVol =
        LgFrTimeVecFloat(nPeriods,cumShipBound).undoCum();
      witFree ( cumShipBound );
      // make sure the de-cummed demand vol is non-negative
      assert ( minDemandVol >= 0.0 );

      int t = 0; 
      for (t=0; t<nPeriods; t++)   {
        if (minDemandVol[t] > 0.0)
	  listMax_++;
      }
      witFree(dList[j]);
    }
    witFree(dList);
  }



  // Now allocate the vector of allocLet Ptrs
  vecAllocLetList_ = new LgFrSceAllocLet [listMax_];
  // and the vector of allocLets
  allocLetList_ =     new LgFrSceAllocLet * [listMax_];
  
  LgFrSceAllocLet * dependeeAllocLet = 0;

  // now load each allocLet
  for( i=0; i<nParts; i++){
    partName = partList[i];
    int nDemands;
    char ** dList;
    witGetPartDemands(theWitRun_, partName, &nDemands, &dList);
    int j = 0; 
    for(j=0; j<nDemands; j++){
      demandName = dList[j];
      float * cumShipBound, * hardLower, * hardUpper;
      witGetDemandCumShipBounds( theWitRun_, partName, demandName,
                                 &hardLower,
                                 &cumShipBound,
                                 &hardUpper);
      witFree ( hardLower);
      witFree ( hardUpper );
      
      // un-cum the lower bounds and use them as the alloclet vols for the first pass
      LgFrTimeVecFloat minDemandVol =
        LgFrTimeVecFloat(nPeriods,cumShipBound).undoCum();
      witFree ( cumShipBound );
      // make sure the de-cummed demand vol is non-negative
      assert ( minDemandVol >= 0.0 );
      
      
      // reset the dependee ptr to 0
      dependeeAllocLet = 0;

      witGetDemandPriority(theWitRun_, partName, demandName, &priority);
      witGetDemandDemandVol(theWitRun_, partName, demandName, &demandVol);
      int t = 0; 
      for (t=0; t<nPeriods; t++) {
        if (minDemandVol[t] > 0.0) {
          LgFrSceAllocLet & myAllocLet = vecAllocLetList_[aPointer_];
          allocLetList_[aPointer_] = &myAllocLet;
          myAllocLet.partName(partName);
          myAllocLet.demandName(demandName);
          myAllocLet.priority(priority[t]);
          myAllocLet.qtyDemand(minDemandVol[t]);
          myAllocLet.demandPd(t);
          myAllocLet.shipPd(t);
          myAllocLet.allocated(0);

	  if (dependeeAllocLet != 0) {
	    // if there's a dependee, then he's waiting to know the current one
	    dependeeAllocLet->backlogDependent(&myAllocLet);
	  }
	  // remember this allocLet
	  dependeeAllocLet = &myAllocLet;
          aPointer_++;
        }
      }




      // the amt of demand in excess of the minimum (i.e. "above the min demand")
      // is demand vol used in the second pass. Calculate it and store as appData
      // in the workingWitRun
      LgFrSceDemandAppData * demandAppDataPtr = 0 ;
      witGetDemandAppData( theWitRun_, partName, demandName,
                           (void **) &demandAppDataPtr );
      if ( demandAppDataPtr == 0 ) {
        demandAppDataPtr = new LgFrSceDemandAppData ((size_t) nPeriods, 1.0);
        assert ( demandAppDataPtr != 0 );
        witSetDemandAppData( theWitRun_, partName, demandName,  
                            (void *) demandAppDataPtr );
      }
      LgFrTimeVecFloat aboveMinDemandVol((size_t) nPeriods, 0.0);
      for (t=0; t<nPeriods; t++)
	aboveMinDemandVol[t] = demandVol[t] - minDemandVol[t];
      demandAppDataPtr->aboveMinDemandVol ( aboveMinDemandVol );
      float mytemp;
      mytemp = aboveMinDemandVol.min();
      if (mytemp < 0)
         printf("HERE/n");
      assert ( aboveMinDemandVol.min() >= -0.01 );


      witFree(dList[j]);
      witFree(demandVol);
      witFree(priority);
    }
    witFree(dList);
    witFree(partList[i]);
  }
  witFree(partList);
  
  assert(aPointer_ == listMax_);
  aPointer_ = 0;

  qsort(allocLetList_, 
        listMax_, 
	sizeof(LgFrSceAllocLet*), 
        sortStrategy_->compareVoidFunc());

  std::cout << "     ... DONE initializing allocData for mins" << std::endl;

}



// ******************************************************************************
// initializeAllocDataAboveMins()
// ------------------------------
// Set up allocLet List for second (main) pass through Heuristic Allocation Pass
// - FINISH_ME: Put allocVol in appData
// ********************************************************************************
void
LgFrSceAllocationEngineMgr::initializeAllocDataAboveMins()
{
  

  int   * priority;
  int nPeriods;
  char  *partName, *demandName;
    
  witGetNPeriods(theWitRun_, &nPeriods);
  int nParts;
  char  **partList;
  witGetParts(theWitRun_, &nParts, &partList);

  // status logging only 
  std::cout << "     ... entering initializeAllocDataAboveMins() " << std::endl;

  aPointer_ = 0;
  listMax_ = 0;

  // first count how many allocLets we need ==> listMax.
  // NOTE: we only count non-zero demandVols
  int i = 0; 
  for(i=0; i<nParts; i++){
    partName = partList[i];

    // skip over any special feature parts.  Any demand on these is for the next pass
    if (mpHelper_->isPartSpecialFeature(theWitRun_, partName)) {
      continue;
    }

    int nDemands;
    char ** dList;
    witGetPartDemands(theWitRun_, partList[i], &nDemands, &dList);
    int j = 0; 
    for(j=0; j<nDemands; j++){

      demandName = dList[j];

      // get the "above min demands" out of the demand app data
      LgFrSceDemandAppData * dmdAppDataPtr;
      witGetDemandAppData( theWitRun_, partName, demandName,
			   (void **) &dmdAppDataPtr);
      LgFrTimeVecFloat demandVol( dmdAppDataPtr->aboveMinDemandVol() );
      assert (demandVol.min() >= 0.0 );

      int t = 0; 
      for (t=0; t<nPeriods; t++)   {
        if (demandVol[t] > 0.0)
	  listMax_++;
      }
      witFree(dList[j]);
    }
    witFree(dList);
  }




  // Now allocate the vector of allocLet Ptrs
  vecAllocLetList_ = new LgFrSceAllocLet [listMax_];
  // and the vector of allocLets
  allocLetList_ = new LgFrSceAllocLet * [listMax_];

  // status logging only 
  std::cout << "     ... allocLetList size:" << listMax_ << std::endl;
  

  // now load each allocLet
  for( i=0; i<nParts; i++){
    partName = partList[i];

    // skip over any special feature parts.  Any demand on these is for the next pass
    if (mpHelper_->isPartSpecialFeature(theWitRun_, partName)) {
      witFree(partList[i]);
      continue;
    }

    int nDemands;
    char ** dList;
    witGetPartDemands(theWitRun_, partName, &nDemands, &dList);
    int j = 0; 
    for(j=0; j<nDemands; j++){
      demandName = dList[j];

      LgFrSceAllocLet * dependeeAllocLet = 0;
      witGetDemandPriority(theWitRun_, partName, demandName, &priority);
      
      // get the "above min demands" out of the demand app data
      LgFrSceDemandAppData * dmdAppDataPtr;
      witGetDemandAppData( theWitRun_, partName, demandName,
			   (void **) &dmdAppDataPtr);
      LgFrTimeVecFloat demandVol( dmdAppDataPtr->aboveMinDemandVol() );
      assert (demandVol.min() >= 0.0 );

      int t = 0; 
      for (t=0; t<nPeriods; t++)   {
        if (demandVol[t] > 0.0){
          LgFrSceAllocLet & myAllocLet = vecAllocLetList_[aPointer_];
          allocLetList_[aPointer_] = &myAllocLet;
          myAllocLet.partName(partName);
          myAllocLet.demandName(demandName);
          myAllocLet.priority(priority[t]);
          myAllocLet.qtyDemand(demandVol[t]);
          myAllocLet.demandPd(t);
          myAllocLet.shipPd(t);
          myAllocLet.allocated(0);

	  if (dependeeAllocLet != 0) {
	    // if there's a dependee, then he's waiting to know the current one
	    dependeeAllocLet->backlogDependent(&myAllocLet);
	  }
	  // remember this allocLet
	  dependeeAllocLet = &myAllocLet;
          aPointer_++;
        }
      }


      witFree(dList[j]);
      witFree(priority);
    }
    witFree(dList);
    witFree(partList[i]);
  }
  witFree(partList);
  
  assert(aPointer_ == listMax_);
  aPointer_ = 0;

  // status logging only 
  std::cout << "     ... initialized allocLetLists" << std::endl;


  // status logging only 
  std::cout << "     ... starting qsort of allocLetList" << std::endl;


  qsort(allocLetList_, 
        listMax_, 
	sizeof(LgFrSceAllocLet*), 
        sortStrategy_->compareVoidFunc());

  // status logging only 
  std::cout << "     ... finished  initial qsort of allocLetList" << std::endl;

}

// ******************************************************************************
// setPureOptionDemandVols()
// ------------------------------
// Must front-load the demandVols for the special feature demands
// ********************************************************************************
void 
LgFrSceAllocationEngineMgr::setPureOptionDemandVols()
{

  std::cout << "     ... executing  setPureOptionDemandVols..." << std::endl;  

  LgFrSceSetOfParameters & setOfParameters =  sceScenSP_->setOfParameters();    

  // get the number of periods
  int nPeriods;
  witGetNPeriods( theWitRun_, &nPeriods ) ;

  // get the operation list
  int  nOperations ;      
  char ** operationList ;    
  witGetOperations( theWitRun_, &nOperations, &operationList );

  float * bigMdemandVol = new float[nPeriods];
  int t = 0; 
  for (t=0; t<nPeriods; t++)
    bigMdemandVol[t] = 98765431.f;


  std::string featureRatioPegMethod = setOfParameters.getString("featureRatioPegMethod");
  //  choices ==>  pegToMachineDemandPeriod  or  pegToMachineShipPeriod;


  // Loop once for each operation.
  int o = 0; 
  for ( o=0; o<nOperations; o++ ) {
    std::string fullWitGeoPlannerDemandOperation(operationList[o]);
    std::string plannerTopLevelPart;
    std::string geo;

    // Start with  GPD parts ...  then look for  specialFeatureParts as children. 
    if (! mpHelper_->isOperationSpecialGeoPlannerDemand(theWitRun_, fullWitGeoPlannerDemandOperation,
						     plannerTopLevelPart, geo))  {
      witFree (operationList[o]);
      continue;
    }
    int nBoms;
    witGetOperationNBomEntries( theWitRun_, operationList[o], &nBoms );
    // Now loop through the children of the GPD operation
    int j = 0; 
    for (j=0; j<nBoms; j++)  {

      // get the name of the child part, 
      char * fullWitFeaturePart;
      witGetBomEntryConsumedPart(theWitRun_, fullWitGeoPlannerDemandOperation.c_str(), j, &fullWitFeaturePart);

      // We are only interested in special Feature Parts which, at this time,
      // can either be custChoice or stdalone
      if (!  mpHelper_->isPartSpecialFeature(theWitRun_, fullWitFeaturePart)) {
	witFree(fullWitFeaturePart);
	continue;
      }
      std::string gg, pp, ppdf, fp;

      // + --------------------------------
      // + If its a CUSTOMER_CHOICE_FEATURES
      // + --------------------------------
      if (mpHelper_->isPartSpecialCustChoiceFeature(theWitRun_, fullWitFeaturePart, 
						   gg, pp, ppdf, fp)) {
	    
	    
	// Here we process Customer Choice Features
	// total possible demandVol on CC features is
	//          demandVol(GPD) * usageRate * featratio
	    
	// Multiple BOM entries between the parent and the child could be used to implement
	// different feature rates over time.
	std::string featureDemandName = mpHelper_->custChoiceFeatureDemandName(fullWitGeoPlannerDemandOperation );
	    
	float * gpdDemVol;
	witGetDemandDemandVol( theWitRun_, fullWitGeoPlannerDemandOperation.c_str(), geo.c_str(), &gpdDemVol);
	float usageRate;
	witGetBomEntryUsageRate(theWitRun_, fullWitGeoPlannerDemandOperation.c_str(), j, &usageRate);	      
	// featRatio is stored in GPD->SFP bom's appData
	LgFrTimeVecFloat featRatio = mpHelper_->custChoiceFeatureRatio(theWitRun_, fullWitFeaturePart);
    
	float * featDemandVol;
	witGetDemandDemandVol(theWitRun_, fullWitFeaturePart, featureDemandName.c_str(), &featDemandVol);
	// sanity check !!!
	LgFrTimeVecFloat featDvTVF((size_t) nPeriods, featDemandVol);
	assert(featDvTVF.max() < 0.001);

	// now compute the total Features Needed ...
	int t = 0; 
	for ( t=0; t<nPeriods; t++)
	  featDemandVol[t] = featRatio[t] * gpdDemVol[t] * usageRate;
	    
	witSetDemandDemandVol(theWitRun_, fullWitFeaturePart, featureDemandName.c_str(), featDemandVol);

	witFree(featDemandVol);
	witFree(gpdDemVol);
	witFree(fullWitFeaturePart);
	continue;
      }   //  end  ...        if (mpHelper->isPartSpecialCustChoiceFeature())  ...
      

      // + --------------------------------
      // + If its a STANDALONE FEATURE
      // + --------------------------------
      // Just for the sake of it ....
      assert (mpHelper_->isPartSpecialStandaloneFeature(theWitRun_, fullWitFeaturePart, 
							gg, pp, ppdf, fp));
      
      int nDemands;
      char ** dList;
      witGetPartDemands(theWitRun_, fullWitFeaturePart, &nDemands, &dList);
      int j = 0; 
      for (j=0; j<nDemands; j++) {
	witSetDemandDemandVol(theWitRun_, fullWitFeaturePart, dList[j], bigMdemandVol);
	witFree(dList[j]);
      }
      witFree(dList);
      witFree(fullWitFeaturePart);
    }      // end  ...  for (int j=0; j<nBoms; j++)  
    witFree (operationList[o]);
  }    // end  ...    for ( int o=0; o<nOperations; o++ ) 
  witFree(operationList);
  delete [] bigMdemandVol;
}



// use dumpaVec for debugging 
void
LgFrSceAllocationEngineMgr::dumpaVec(std::string aMessage, LgFrTimeVecFloat & theVec)
{

  int nPeriods;
  witGetNPeriods(theWitRun_, &nPeriods);

  std::cout << aMessage << ": [";
  int t = 0; 
  for (t=0; t<nPeriods-1; t++)
    std::cout << theVec[t] << ",";
  std::cout << theVec[t] << "]" << std::endl;
}

void
LgFrSceAllocationEngineMgr::dumpaVec(std::string aMessage, float * theVec)
{

  int nPeriods;
  witGetNPeriods(theWitRun_, &nPeriods);

  std::cout << aMessage << ": [";
  int t = 0; 
  for (t=0; t<nPeriods-1; t++)
    std::cout << theVec[t] << ",";
  std::cout << theVec[t] << "]" << std::endl;
}



// ******************************************************************************
// setPureOptionBuildAllocVols()
// ------------------------------
// Calculate allocVols for  for features pass of  Heuristic Allocation Pass
//   - allocVol's are placed   in appData
//   - This routine does not create  allocLets.  
//   - Instead it sets up the allocVols in dmdAppData ... in preparation for allocLets
//   - Most of this is clipped from setPureOptionBuildDemand() which is in hEngMgr
// - DEVELOP_HERE
// ********************************************************************************
void 
LgFrSceAllocationEngineMgr::setPureOptionBuildAllocVols()
{

  std::cout << "     ... executing  setPureOptionBuildAllocVols..." << std::endl;  

  LgFrSceSetOfParameters & setOfParameters =  sceScenSP_->setOfParameters();    

  // get the number of periods
  int nPeriods;
  witGetNPeriods( theWitRun_, &nPeriods ) ;

  // get the operation list
  int  nOperations ;      
  char ** operationList ;    
  witGetOperations( theWitRun_, &nOperations, &operationList );


  // this is obsolete.  We are moving towards no longer allowing ratio's to change.
  std::string featureRatioPegMethod = setOfParameters.getString("featureRatioPegMethod");
  //  choices ==>  pegToMachineDemandPeriod  or  pegToMachineShipPeriod;


  // Loop once for each operation.
  int o = 0; 
  for ( o=0; o<nOperations; o++ ) {
    std::string fullWitGeoPlannerDemandOperation(operationList[o]);
    std::string plannerTopLevelPart;
    std::string geo;

    // Start with  GPD parts ...  then look for  specialFeatureParts as children. 
    if (! mpHelper_->isOperationSpecialGeoPlannerDemand(theWitRun_, fullWitGeoPlannerDemandOperation,
						     plannerTopLevelPart, geo))  {
      continue;
    }
    int nBoms;
    witGetOperationNBomEntries( theWitRun_, operationList[o], &nBoms );
    // Now loop through the children of the GPD operation
    int j = 0; 
    for (j=0; j<nBoms; j++)  {

      // get the name of the child part, 
      char * fullWitFeaturePart;
      witGetBomEntryConsumedPart(theWitRun_, fullWitGeoPlannerDemandOperation.c_str(), j, &fullWitFeaturePart);

      // We are only interested in special Feature Parts which, at this time,
      // can either be custChoice or stdalone
      if (!  mpHelper_->isPartSpecialFeature(theWitRun_, fullWitFeaturePart)) {
	witFree(fullWitFeaturePart);
	continue;
      }
      std::string gg, pp, ppdf, fp;

      // + --------------------------------
      // + If its a CUSTOMER_CHOICE_FEATURES
      // + --------------------------------
      if (mpHelper_->isPartSpecialCustChoiceFeature(theWitRun_, fullWitFeaturePart, 
						   gg, pp, ppdf, fp)) {


	std::string featureDemandName = 
	  mpHelper_->custChoiceFeatureDemandName(fullWitGeoPlannerDemandOperation );
	    
	float * gpdDemVol;
	witGetDemandDemandVol( theWitRun_, fullWitGeoPlannerDemandOperation.c_str(), geo.c_str(), &gpdDemVol);
	float * gpdExecVol;
	witGetOperationExecVol( theWitRun_, fullWitGeoPlannerDemandOperation.c_str(), &gpdExecVol);
	float usageRate;
	witGetBomEntryUsageRate(theWitRun_, fullWitGeoPlannerDemandOperation.c_str(), j, &usageRate);	      
	// featRatio is stored in GPD->SFP bom's appData
	LgFrTimeVecFloat featRatio = mpHelper_->custChoiceFeatureRatio(theWitRun_, fullWitFeaturePart);

	// total features needed
	LgFrTimeVecFloat featureDemandPreUsageRate((size_t) nPeriods, 0.0);

	// This *may* be obsolete.  It's an attempt to adjust the execVols back to the 
	// the period when the demand was due. 
	LgFrTimeVecFloat tiedBackGpdExecVol((size_t) nPeriods, gpdExecVol);



#ifdef DEBUG_SET_PURE_OPTIONS
	std::cout << "\n\n******\nGPD:" << fullWitGeoPlannerDemandOperation << std::endl;
	std::cout << "CC Feature:" << fullWitFeaturePart << std::endl;
	dumpaVec("gpdDemVol:", gpdDemVol);
	dumpaVec("gpdExecVol:", gpdExecVol);
	dumpaVec("featRatio:", featRatio);
#endif


	// if the ratio's are constant over time, then life is easy
	int areRatiosConstant = 0;
	if (featRatio.max() - featRatio.min() < 0.0001) {
	  areRatiosConstant = 1;
	  
	  // featureDemandPreUsageRate is GPD ships times the featRatio	  
	  int t = 0; 
	  for ( t=0; t<nPeriods; t++)
	    featureDemandPreUsageRate[t] = featRatio[t] * tiedBackGpdExecVol[t];
	}
	
	// if the ratio's change over time, then life is a pain in the ass
	// here are two ways to implement, bith of which are problematic
	// For now we have an emergency fix that forces ESG user's to make
	// all ratio's equal.   Thus this case of "ratio's changing" won't bite us
	// However, there are other issues to consider ... 
	//    MachFeat Supply, 
	//    MachFeat Offsets
	//    GeoSpource transit times
	//    anything else ????
	// If's a major FINISH_ME: to clear this up!!!   We may need to retract some 
	// sce functionality
	else {
#if 1

	  // ----------------------------------------------------------	  
	  // ---- Method 1: only used when ratio's change over time  ----
	  // This method was flawed and was to be be replaced by method 2,
	  // but that was screwing up also

	  // Compute ==> tiedBackGpdExecVol 
	  int t = 0; 
	  for (t=0; t<nPeriods; t++) {
	    float demExcess = gpdDemVol[t] - tiedBackGpdExecVol[t];
	    // if this period matches, then continue
	    if (demExcess < .001)
	      continue;
	    // otherwise, look for future commits to pull in
	    int t2 = 0; 
	    for (t2=t+1; t2<nPeriods; t2++) {
	      // if period t2 execVol covers period t delta, then pull it in
	      if (tiedBackGpdExecVol[t2]  >= demExcess) {
		tiedBackGpdExecVol[t] += demExcess;
		tiedBackGpdExecVol[t2] -= demExcess;
		demExcess = 0.0;
		break;
	      }
	      else {
		tiedBackGpdExecVol[t] += tiedBackGpdExecVol[t2];
		demExcess -= tiedBackGpdExecVol[t2];
		tiedBackGpdExecVol[t2] = 0.0;
	      }
	    }
	    // now if you didn't clear the demand gap, then you're done
	    // since you've (necesarily) exhausted all future commits
	    // So break out of the loop
	    if (demExcess > 0.001) {
	      break;
	    }
	  }
	  // End: Compute ==> tiedBackGpdExecVol 	    
	  
	  // now compute the total Features Needed ...
	  // featureDemandPreUsageRate is basically the GPD shipVol times the featRatio
	  for ( t=0; t<nPeriods; t++)
	    featureDemandPreUsageRate[t] = featRatio[t] * tiedBackGpdExecVol[t];
#endif

#if 0
	  // ----------------------------------------------------------	  
	  // ---- Method 2: only used when ratios change over time  ----
	  // This method was supposed to be an improvement over Method 1
	  // but it has problems
	  int t = 0; 
	  for (t=0; t<nPeriods; t++) {
	    float demandFromPeriodT2satisfiedinPeriodT = 0.0;	  
	    // lets loop over the previous periods (t2 form 0 to t-1) and pick up any 
	    // un-"allocated" gpdDemVol.
	    int t2 = 0; 
	    for (t2=0; t2<t; t2++) {
	      demandFromPeriodT2satisfiedinPeriodT =
		(gpdDemVol[t2] < tiedBackGpdExecVol[t])  ?  gpdDemVol[t2] : 0.0;
	      // use the ratio in place in period t2 figure out how much features are needed in t
	      featureDemandPreUsageRate[t] += demandFromPeriodT2satisfiedinPeriodT * featRatio[t2];
	      // decrecment both gpdDemVol and tiedBackGpdExecVol
	      gpdDemVol[t2] -= demandFromPeriodT2satisfiedinPeriodT;
	      tiedBackGpdExecVol[t] -= demandFromPeriodT2satisfiedinPeriodT;
	    }
	    
	    //  after the loop t2=t and we simply take the min{gpdDemVol[t] and tiedBackGpdExecVol[t]
	    demandFromPeriodT2satisfiedinPeriodT =
	      (gpdDemVol[t2] < tiedBackGpdExecVol[t])  ?  gpdDemVol[t2] : tiedBackGpdExecVol[t];
	    featureDemandPreUsageRate[t] += demandFromPeriodT2satisfiedinPeriodT * featRatio[t2];
	    // decrement both gpdDemVol and tiedBackGpdExecVol
	    gpdDemVol[t2] -= demandFromPeriodT2satisfiedinPeriodT;
	    tiedBackGpdExecVol[t] -= demandFromPeriodT2satisfiedinPeriodT;
	    
	    // now it most cases, tiedBackGpdExecVol[t] should be Zero
	    // if it's not, then roll it
	    if (tiedBackGpdExecVol[t] >0.0001) {
	      if (t == (nPeriods - 1)) {
		std::cout << "Big Mess of an error ... look here!!!" << std::endl;
		exit(8);
	      }
	      
	      // roll it
	      tiedBackGpdExecVol[t+1] += tiedBackGpdExecVol[t];
	      tiedBackGpdExecVol[t] = 0.0;
	    }
	  }
#endif
	  // ----------------------------------------------------------	  
	}  // matches the else  regarding featratio's changing over time


#ifdef DEBUG_SET_PURE_OPTIONS
	dumpaVec("featureDemandPreUsageRate:", featureDemandPreUsageRate);
	dumpaVec("tiedBackGpdExecVol:", tiedBackGpdExecVol);
#endif

	// here's the amount of features supplied in first pass (pre usageRate)
	//     featuresShippedPreUsageRate = supplyVolCCfeaturePart + execVolCCfeaturePart;
	LgFrTimeVecFloat featuresShippedPreUsageRate((size_t) nPeriods, 0.0);

	float *  supplyVolCCfeaturePart;
	witGetPartSupplyVol(theWitRun_, fullWitFeaturePart, &supplyVolCCfeaturePart);
	float *  execVolCCfeaturePart;
	witGetOperationExecVol(theWitRun_, fullWitFeaturePart, &execVolCCfeaturePart);

	int t = 0; 
	for ( t=0; t<nPeriods; t++) {
	  featuresShippedPreUsageRate[t] = supplyVolCCfeaturePart[t] + execVolCCfeaturePart[t];
	}

	// here's the straight net of what you need for the second pass (pre usageRate)
	LgFrTimeVecFloat secondPassFeatureDemandVol((size_t) nPeriods, 0.0);
	for ( t=0; t<nPeriods; t++)
	  secondPassFeatureDemandVol[t] = featureDemandPreUsageRate[t] - featuresShippedPreUsageRate[t];


#ifdef DEBUG_SET_PURE_OPTIONS
	dumpaVec("supplyVolCCfeaturePart:", supplyVolCCfeaturePart);
	dumpaVec("execVolCCfeaturePart:", execVolCCfeaturePart);
	dumpaVec("featuresShippedPreUsageRate:", featuresShippedPreUsageRate);
	dumpaVec("secondPassFeatureDemandVol:", secondPassFeatureDemandVol);
#endif


#if 0      
	// ===> 11/30/2001  	 trying this over ... this doesn't work
	// Roll negative (secondPassFeatureDemandVol) forward.  This needs to  happen because:
	//   - Machine Feature Supply (ie, FEN5) 
	//   - wierd offsetting issues (??)
	for ( t=0; t<nPeriods-1; t++)
	  if (secondPassFeatureDemandVol[t] < 0) {
	    secondPassFeatureDemandVol[t+1] += secondPassFeatureDemandVol[t];
	    secondPassFeatureDemandVol[t] = 0;
	  }
	if (secondPassFeatureDemandVol[nPeriods - 1] < 0) 
	  secondPassFeatureDemandVol[nPeriods - 1] = 0;
	    
	// now insure that the cum of secondPassFeatureDemandVol does not exceed the 
	// cum of machines shipped!
	for ( t=0; t<nPeriods; t++) {
	  // add in what you rolled from last period
	  float delta = secondPassFeatureDemandVol[t] - gpdExecVol[t];
	  // do you need to roll?
	  if (delta > 0) {
	    secondPassFeatureDemandVol[t] = gpdExecVol[t];
	    if (t+1 < nPeriods)
	      secondPassFeatureDemandVol[t+1] += delta;
	  }
	  // or not roll?
	  else {
	    if (t+1 < nPeriods)
	      gpdExecVol[t+1] -= delta;
	  }
	}  //  end ... Roll negative forward
#else

	// ---------------------------------------------
	// Roll Negatives Forward:  approach  11/30/2001
	// ---------------------------------------------
	//       (now we have the luxury that all ratio's are constant)
	// Walk backwards through the timeVec  from pd n-1 to 0
	// if you find a negative carry it along and work it off
	for ( t=nPeriods-1; t>0; t--) {
	  if (secondPassFeatureDemandVol[t] < 0) {
	    secondPassFeatureDemandVol[t-1] += secondPassFeatureDemandVol[t];
	    secondPassFeatureDemandVol[t] = 0;
	  }
	}
#ifdef DEBUG_SET_PURE_OPTIONS
	std::cout << "... rolled negatives  forward of secondPassFeatureDemandVol\n";
	dumpaVec("secondPassFeatureDemandVol:", secondPassFeatureDemandVol);
#endif
	// ok, so what happens if you can't work it all off? ... punt!
	// 
	if (secondPassFeatureDemandVol[0] < 0) {
	  if (secondPassFeatureDemandVol[0] < -0.01) {
	    std::cout << "Internal SCE Code Alert: SCE00645AH.  Please notify the SCE Development Team.\n";


	    std::cout << "\n\n******\nGPD:" << fullWitGeoPlannerDemandOperation << std::endl;
	    std::cout << "CC Feature:" << fullWitFeaturePart << std::endl;
	    dumpaVec("gpdDemVol:", gpdDemVol);
	    dumpaVec("gpdExecVol:", gpdExecVol);
	    dumpaVec("featRatio:", featRatio);
	    dumpaVec("supplyVolCCfeaturePart:", supplyVolCCfeaturePart);
	    dumpaVec("execVolCCfeaturePart:", execVolCCfeaturePart);
	    dumpaVec("featuresShippedPreUsageRate:", featuresShippedPreUsageRate);
	    dumpaVec("secondPassFeatureDemandVol:", secondPassFeatureDemandVol);
	  }
	  secondPassFeatureDemandVol[0] = 0;
#ifdef DEBUG_SET_PURE_OPTIONS
	  std::cout << "... but had a negative in pd 0 so we flatten it.\n";
	  dumpaVec("secondPassFeatureDemandVol:", secondPassFeatureDemandVol);
#endif
	}
	// ---------------------------------------------
	// END: Roll Negatives Forward:  approach  11/30/2001
	// ---------------------------------------------
	

	// now insure that the cum of secondPassFeatureDemandVol does not exceed the 
	// cum of machines shipped!
	for ( t=0; t<nPeriods; t++) {
	  // add in what you rolled from last period
	  float delta = secondPassFeatureDemandVol[t] - gpdExecVol[t];
	  // do you need to roll?
	  if (delta > 0) {
	    secondPassFeatureDemandVol[t] = gpdExecVol[t];
	    if (t+1 < nPeriods)
	      secondPassFeatureDemandVol[t+1] += delta;
	  }
	  // or not roll?
	  else {
	    if (t+1 < nPeriods)
	      gpdExecVol[t+1] -= delta;
	  }
	}  //  end ... Roll negative forward
#endif


#ifdef DEBUG_SET_PURE_OPTIONS
	  std::cout << "... just adjusted for spfd exceeding gpdExecVol.\n";
	  dumpaVec("secondPassFeatureDemandVol:", secondPassFeatureDemandVol);
#endif



	// now we apply the usageRate
	for ( t=0; t<nPeriods; t++)
	  secondPassFeatureDemandVol[t] *= usageRate;


#ifdef DEBUG_SET_PURE_OPTIONS
	if (usageRate < 1 || usageRate>1) {
	  std::cout << "... just applied non-unit usageRate\n";
	  dumpaVec("secondPassFeatureDemandVol:", secondPassFeatureDemandVol);
	}
#endif


#ifdef DEBUG_SET_PURE_OPTIONS
	// and now we're done debugging
	std::cout << "****** \n\n";
#endif


	    
	    
	// YEAH, we've computed the second pass demand vol!!
	// set it in appData
	LgFrSceDemandAppData * dmdAppDataPtr;
	witGetDemandAppData( theWitRun_, fullWitFeaturePart, featureDemandName.c_str(),
			     (void **) &dmdAppDataPtr);
	if ( dmdAppDataPtr == 0 ) {
	  dmdAppDataPtr = new LgFrSceDemandAppData ((size_t) nPeriods, 1.0);
	  assert ( dmdAppDataPtr != 0 );
	  witSetDemandAppData( theWitRun_, fullWitFeaturePart, featureDemandName.c_str(),  
			       (void *) dmdAppDataPtr );
	}
	dmdAppDataPtr->allocVol(secondPassFeatureDemandVol);
	

	// FINISH_ME: Must set SpecialFeatureDemandVols prior to incHeurAlloc.  
	//   - migrate away from using demandVol at all ... use allocVol
	//   - check back in code to see if we can set it.  We may need multiple 
	//     implementations in ipSce.C based on engine!!!

	witFree(gpdDemVol);
	witFree(gpdExecVol);
	witFree(supplyVolCCfeaturePart);
	witFree(execVolCCfeaturePart);
	witFree(fullWitFeaturePart);
	continue;
      }   //  end  ...        if (mpHelper->isPartSpecialCustChoiceFeature())  ...
      


      // + --------------------------------
      // + If its a STANDALONE FEATURE
      // + --------------------------------
      // Just for the sake of it ....
      assert (mpHelper_->isPartSpecialStandaloneFeature(theWitRun_, fullWitFeaturePart, 
						       gg, pp, ppdf, fp));
      


      // if there are substitutes, then the child might be a pure option
      // note that one must look at the NullSub part to determine which of the three
      // type of STANDALONE FEATUREs it is ...
      int nSubs;
      witGetBomEntryNSubsBomEntries(theWitRun_, fullWitGeoPlannerDemandOperation.c_str(), j, &nSubs);

      if (nSubs > 0)   {

	assert (nSubs == 1);

	char * nullSub;
	witGetSubsBomEntryConsumedPart(theWitRun_, fullWitGeoPlannerDemandOperation.c_str(), j, 0, &nullSub);
	
	// the nullSub will be one of:
	//    globalNullSub (Purely optional standalone feature)
	//    globalMaxWithoutNullsub (purely mandatory standalone feature)
	//    maxWithoutNullsub  (standalone feature with 0<maxWithout <1)
	
	// -------------------------------------------------------------
	// if its a Mandatory Feature (global maxwithout) ... Skip It
	// -------------------------------------------------------------
	// skip it because there  never be any pureOption demandVol for mandatory features
	std::string pppdf;
	if (mpHelper_->isPartSpecialGlobalMaxWithoutNullSubstitute(theWitRun_, nullSub, pppdf)) {
	  witFree(nullSub);
	  continue;
	  }
	
	
	// -----------------------------------------------------------------------
	// if its a PURE Option or a MWO (ie, purely optional or partly mandatory)
	// -----------------------------------------------------------------------
	// --------------------------------------------------------------------------------
	
	// OK, if you've gotten to here then you've found a PURE OPTION!
	// The child is the pure option.
	
	// First time you find the pure option add the build demand
	// The default demand volume of a time vec of all 0.0
	// There could be multiple arcs between the child and parent AND there could
	// be multiple substitutes on each arc. We want at most one pureOptionBuildDemandName
	// Zero out all the demands in theWitRun
	// for every (special geo planner demand part)-(pure option) pair.
	//
	// Multiple BOM entries between the parent and the child could be used to implement
	// different feature rates over time.
	std::string featureDemandName = mpHelper_->pureOptionBuildDemandName(fullWitGeoPlannerDemandOperation );
	

	
	// --------------------------------------------------------------------------------
	//
	// This is the place where the rubber hits the road in feature modeling.
	// This is where the demand for features is calculated.
	// Implement you favorite algorithm for calculating the amount of a feature
	// to be built in the second pass of the heuristic HERE.
	//
	
	//
	// This code says that amount of the null substituted used times the feature ratio
	// (ie. subsVol * usageRate) is the amt of pure option to try and build
	//
	// The feature ratio used is the feature ratio in effect during the box
	// ship period (which may have no similarity with the feature rate
	// that was in effect in the period during which the demand originated from).
	  
	// *****************************************************************************
	// The amount of the produced part due to this substitute is given by subVol.

	LgFrTimeVecFloat pureOptBldDemVol((size_t) nPeriods, 0.0);
	
	// get the subVol of the nullSub
	float * subVol;
	witGetSubsBomEntrySubVol(theWitRun_, fullWitGeoPlannerDemandOperation.c_str(), j, 0, &subVol);
	

	
	if ( featureRatioPegMethod == "pegToMachineShipPeriod" ) {
	  // FINISH_ME: check this out!!!  
	  //     .... The default if pegToMachineShipPeriod but esg wants pegToMachineDemandPeriod
	  
	  
	  // But, we need the usageRatio...
	  // FINISH_ME: 2001/07/19: this now needs to be consRate!!!
	  float usageRatio;
	  witGetBomEntryUsageRate(theWitRun_, fullWitGeoPlannerDemandOperation.c_str(), j, &usageRatio);
	  
	  // this was originally commented out with the following FINISH_ME: check it out, please.
	  //	      int * impactPeriod;
	  //	      witGetBomEntryImpactPeriod(theWitRun_, fullWitGeoPlannerDemandOperation.c_str(), j, &impactPeriod);
	  // FINISH_ME: this is not right yet
	  
	  // ...to calculate the amount of the substitute that was consumed
	  // which is equal to the amount of the pure option we want to try and build.
	  
	  int t = 0; 
	  for (t=0; t<nPeriods; t++) {
	    if (subVol[t] > 0.0001) {
	      //		  assert(impactPeriod[t] >= 0);
	      //		  pureOptBldDemVol[impactPeriod[t]] += (usageRatio * subVol[t]);
	      pureOptBldDemVol[t] = usageRatio * subVol[t];
	    }
	    //	      witFree(impactPeriod);
	  }
	}


	assert (pureOptBldDemVol.min() >= 0.0);	
	
	// YEAH, we've computed the second pass demand vol!!
	// set it in appData
	LgFrSceDemandAppData * dmdAppDataPtr;
	witGetDemandAppData( theWitRun_, fullWitFeaturePart, featureDemandName.c_str(),
			     (void **) &dmdAppDataPtr);
	if ( dmdAppDataPtr == 0 ) {
	  dmdAppDataPtr = new LgFrSceDemandAppData ((size_t) nPeriods, 1.0);
	  assert ( dmdAppDataPtr != 0 );
	  witSetDemandAppData( theWitRun_, fullWitFeaturePart, featureDemandName.c_str(),  
			       (void *) dmdAppDataPtr );
	}
	dmdAppDataPtr->allocVol(pureOptBldDemVol);


	// cleanup
	witFree(subVol);
	witFree(nullSub);
      }  // end    ...    if (nSubs > 0)   
      witFree(fullWitFeaturePart);
    }      // end  ...  for (int j=0; j<nBoms; j++)  
    witFree (operationList[o]);
  }    // end  ...    for ( int o=0; o<nOperations; o++ ) 
  witFree(operationList);
}




// ******************************************************************************
// setPureOptionBuildAllocVolsForMaxATP()
// --------------------------------------
// Calculate allocVols for  for features pass of  Heuristic Allocation Pass
//   - allocVol's are placed   in appData
//   - This routine does not create  allocLets.  
//   - Instead it sets up the allocVols in dmdAppData ... in preparation for allocLets
// - DEVELOP_HERE
// ********************************************************************************
void 
LgFrSceAllocationEngineMgr::setPureOptionBuildAllocVolsForMaxATP()
{

  std::cout << "     ... executing  setPureOptionBuildAllocVolsForMaxATP ..." << std::endl;  

  LgFrSceSetOfParameters & setOfParameters =  sceScenSP_->setOfParameters();    

  // get the number of periods
  int nPeriods;
  witGetNPeriods( theWitRun_, &nPeriods ) ;

  std::string featureRatioPegMethod = setOfParameters.getString("featureRatioPegMethod");

  // get the operation list
  int  nOperations ;      
  char ** operationList ;    
  witGetOperations( theWitRun_, &nOperations, &operationList );



  // Loop once for each operation.
  int o = 0; 
  for ( o=0; o<nOperations; o++ ) {
    std::string fullWitGeoPlannerDemandOperation(operationList[o]);
    std::string plannerTopLevelPart;
    std::string geo;

    // Start with  GPD parts ...  then look for  specialFeatureParts as children. 
    if (! mpHelper_->isOperationSpecialGeoPlannerDemand(theWitRun_, fullWitGeoPlannerDemandOperation,
							plannerTopLevelPart, geo))  {
      witFree (operationList[o]);
      continue;
    }
    int nBoms;
    witGetOperationNBomEntries( theWitRun_, operationList[o], &nBoms );
    // Now loop through the children of the GPD operation
    int j = 0; 
    for (j=0; j<nBoms; j++)  {

      // get the name of the child part, 
      char * fullWitFeaturePart;
      witGetBomEntryConsumedPart(theWitRun_, fullWitGeoPlannerDemandOperation.c_str(), j, &fullWitFeaturePart);

      // We are only interested in special Feature Parts which, at this time,
      // can either be custChoice or stdalone
      if (!  mpHelper_->isPartSpecialFeature(theWitRun_, fullWitFeaturePart)) {
	witFree(fullWitFeaturePart);
	continue;
      }
      std::string gg, pp, ppdf, fp;

      // + --------------------------------
      // + If its a CUSTOMER_CHOICE_FEATURE
      // + --------------------------------
      if (mpHelper_->isPartSpecialCustChoiceFeature(theWitRun_, fullWitFeaturePart, gg, pp, ppdf, fp)) {

	std::string featureDemandName = mpHelper_->custChoiceFeatureDemandName(fullWitGeoPlannerDemandOperation );
	    
	float * gpdDemVol;
	witGetDemandDemandVol( theWitRun_, fullWitGeoPlannerDemandOperation.c_str(), geo.c_str(), &gpdDemVol);
	float * gpdExecVol;
	witGetOperationExecVol( theWitRun_, fullWitGeoPlannerDemandOperation.c_str(), &gpdExecVol);
	float * consRate;
	witGetBomEntryConsRate(theWitRun_, fullWitGeoPlannerDemandOperation.c_str(), j, &consRate);	      
	// featRatio is stored in GPD->SFP bom's appData
	LgFrTimeVecFloat featRatio = mpHelper_->custChoiceFeatureRatio(theWitRun_, fullWitFeaturePart);

	// total features demanded (boxDemand * featratio)
	LgFrTimeVecFloat featureDemand((size_t) nPeriods, 0.0);
	
	// total features committed 
	LgFrTimeVecFloat featureCommit((size_t) nPeriods, 0.0);
	// cum (featureDemand - featureCommit)
	LgFrTimeVecFloat cumDelta((size_t) nPeriods, 0.0);
	// second pass demand vol
	LgFrTimeVecFloat featureAllocVol((size_t) nPeriods, 0.0);


	float *  supplyVolCCfeaturePart;
	witGetPartSupplyVol(theWitRun_, fullWitFeaturePart, &supplyVolCCfeaturePart);
	float *  execVolCCfeaturePart;
	witGetOperationExecVol(theWitRun_, fullWitFeaturePart, &execVolCCfeaturePart);


	float prevPeriodDelta=0.0;
	int t = 0; 
	for (t=0; t<nPeriods; t++) {
	  featureDemand[t] = gpdDemVol[t] * featRatio[t] * consRate[t];
	  featureCommit[t] = supplyVolCCfeaturePart[t] + execVolCCfeaturePart[t];
	  cumDelta[t] = prevPeriodDelta + featureDemand[t] - featureCommit[t];
	  prevPeriodDelta = cumDelta[t];
	}
	
	float shortfall = cumDelta[nPeriods - 1];
	for (t=nPeriods-1; t>0; t--) {
	  if (shortfall < .00001)
	    break;
	  if (shortfall >= cumDelta[t-1])  {
	    featureAllocVol[t] = shortfall - cumDelta[t-1];
	    shortfall -= featureAllocVol[t];
	  }
	  else {
	    featureAllocVol[t] = 0;
	  }
	}
	featureAllocVol[0] = shortfall;

	
	// YEAH, we've computed the second pass demand vol!!
	// set it in appData
	LgFrSceDemandAppData * dmdAppDataPtr;
	witGetDemandAppData( theWitRun_, fullWitFeaturePart, featureDemandName.c_str(),
			     (void **) &dmdAppDataPtr);
	if ( dmdAppDataPtr == 0 ) {
	  dmdAppDataPtr = new LgFrSceDemandAppData ((size_t) nPeriods, 1.0);
	  assert ( dmdAppDataPtr != 0 );
	  witSetDemandAppData( theWitRun_, fullWitFeaturePart, featureDemandName.c_str(),  
			       (void *) dmdAppDataPtr );
	}
	dmdAppDataPtr->allocVol(featureAllocVol);
	

#ifdef DEBUG_CUSTOMER_CHOICE_MAX_ATP
	std::cout << "\n***DEBUG: MaxATP, CustomerChoice \nGPD:" << fullWitGeoPlannerDemandOperation << ",   ";
	std::cout << "CC Feature:" << fullWitFeaturePart << std::endl;
	dumpaVec("gpdDemVol:", gpdDemVol);
	dumpaVec("gpdExecVol:", gpdExecVol);
	dumpaVec("featRatio:", featRatio);
	dumpaVec("supplyVolCCfeaturePart:", supplyVolCCfeaturePart);
	dumpaVec("execVolCCfeaturePart:", execVolCCfeaturePart);
	dumpaVec("featureDemand:", featureDemand);
	dumpaVec("featureCommit:", featureCommit);
	dumpaVec("cumDelta:", cumDelta);
	dumpaVec("featureAllocVol:", featureAllocVol);
#endif

	witFree(gpdDemVol);
	witFree(gpdExecVol);
	witFree(supplyVolCCfeaturePart);
	witFree(execVolCCfeaturePart);
	witFree(fullWitFeaturePart);
	continue;
      }   //  end  ...        if (mpHelper->isPartSpecialCustChoiceFeature())  ...
      


      // At this point we know it's a STANDALONE FEATURE
      // look at the substitute(s) of the Special Standalone Feature 
      // the nullSub will be one of:
      //    globalNullSub           ==> optional            maxWithout = 1
      //    globalMaxWithoutNullsub ==> mandatory           maxWithout = 0
      //    maxWithoutNullsub       ==> tweener         0 < maxWithout < 1
      assert (mpHelper_->isPartSpecialStandaloneFeature(theWitRun_, fullWitFeaturePart, 
						       gg, pp, ppdf, fp));
      int nSubs;
      witGetBomEntryNSubsBomEntries(theWitRun_, fullWitGeoPlannerDemandOperation.c_str(), j, &nSubs);
      if (nSubs > 0)   {
	assert (nSubs == 1);
	char * nullSub;
	witGetSubsBomEntryConsumedPart(theWitRun_, fullWitGeoPlannerDemandOperation.c_str(), j, 0, &nullSub);
	std::string pppdf;

	// + --------------------------------
	// + If its a MANDATORY_FEATURE
	// + --------------------------------
	if (mpHelper_->isPartSpecialGlobalMaxWithoutNullSubstitute(theWitRun_, nullSub, pppdf)) {

	  std::string featureDemandName = mpHelper_->pureOptionBuildDemandName(fullWitGeoPlannerDemandOperation );	  
	  
	  float * gpdDemVol;
	  witGetDemandDemandVol( theWitRun_, fullWitGeoPlannerDemandOperation.c_str(), geo.c_str(), &gpdDemVol);
	  float * gpdExecVol;
	  witGetOperationExecVol( theWitRun_, fullWitGeoPlannerDemandOperation.c_str(), &gpdExecVol);

	  float featRatio;
	  witGetBomEntryUsageRate(theWitRun_, fullWitGeoPlannerDemandOperation.c_str(), j, &featRatio);

	  // total features demanded (unsquared)
	  LgFrTimeVecFloat featureDemand((size_t) nPeriods, 0.0);

	  // total features committed (squared)
	  LgFrTimeVecFloat featureCommit((size_t) nPeriods, 0.0);
	  
	  LgFrTimeVecFloat cumDelta((size_t) nPeriods, 0.0);
	  LgFrTimeVecFloat featureAllocVol((size_t) nPeriods, 0.0);

	  int t = 0; 
	  float prevPeriodDelta=0.0;
	  for (t=0; t<nPeriods; t++) {
	    featureDemand[t] = gpdDemVol[t] * featRatio;
	    featureCommit[t] = gpdExecVol[t] * featRatio;
            cumDelta[t] = prevPeriodDelta + featureDemand[t] - featureCommit[t];
	    prevPeriodDelta = cumDelta[t];
	  }

	  float shortfall = cumDelta[nPeriods - 1];
	  for (t=nPeriods-1; t>0; t--) {
	    if (shortfall < .00001)
	      break;
	    if (shortfall >= cumDelta[t-1])  {
	      featureAllocVol[t] = shortfall - cumDelta[t-1];
	      shortfall -= featureAllocVol[t];
	    }
	    else {
	      featureAllocVol[t] = 0;
	    }
	  }
	  featureAllocVol[0] = shortfall;


	  
	  // featureAllocVol is the second pass demand vol
	  // set it in appData
	  LgFrSceDemandAppData * dmdAppDataPtr;
	  witGetDemandAppData( theWitRun_, fullWitFeaturePart, featureDemandName.c_str(),
			       (void **) &dmdAppDataPtr);
	  if ( dmdAppDataPtr == 0 ) {
	    dmdAppDataPtr = new LgFrSceDemandAppData ((size_t) nPeriods, 1.0);
	    assert ( dmdAppDataPtr != 0 );
	    witSetDemandAppData( theWitRun_, fullWitFeaturePart, featureDemandName.c_str(),  
				 (void *) dmdAppDataPtr );
	  }
	  dmdAppDataPtr->allocVol(featureAllocVol);



#ifdef DEBUG_MANDATORY_MAX_ATP
	  std::cout << "\n***DEBUG: MaxATP, Mandatory \nGPD:" << fullWitGeoPlannerDemandOperation << ",  ";
	  std::cout << "Mandatory Feature:" << fullWitFeaturePart << std::endl;
	  dumpaVec("gpdDemVol:", gpdDemVol);
	  dumpaVec("gpdExecVol:", gpdExecVol);
	  std::cout << "featRatio: " << featRatio << "\n";
	  dumpaVec("featureDemand:", featureDemand);
	  dumpaVec("featureCommit:", featureCommit);
	  dumpaVec("cumDelta:", cumDelta);
	  dumpaVec("featureAllocVol:", featureAllocVol);
#endif

	  witFree(gpdDemVol);
	  witFree(gpdExecVol);
	}
	

	else   {
	  // -----------------------------------------------------------------------
	  // if its a PURE Option or a MWO tweener
	  // -----------------------------------------------------------------------
	  // --------------------------------------------------------------------------------
	  std::string featureDemandName = mpHelper_->pureOptionBuildDemandName(fullWitGeoPlannerDemandOperation );
	  
	  LgFrTimeVecFloat pureOptBldDemVol((size_t) nPeriods, 0.0);


	  float * gpdDemVol;
	  witGetDemandDemandVol( theWitRun_, fullWitGeoPlannerDemandOperation.c_str(), geo.c_str(), &gpdDemVol);
	  float * gpdExecVol;
	  witGetOperationExecVol( theWitRun_, fullWitGeoPlannerDemandOperation.c_str(), &gpdExecVol);
	  float * consRate;
	  witGetBomEntryConsRate(theWitRun_, fullWitGeoPlannerDemandOperation.c_str(), j, &consRate);	      
	  // featRatio is stored in GPD->SFP bom's appData
	  //	  LgFrTimeVecFloat featRatio = mpHelper_->custChoiceFeatureRatio(theWitRun_, fullWitFeaturePart);

	  // total features demanded (boxDemand * featratio)
	  LgFrTimeVecFloat featureDemand((size_t) nPeriods, 0.0);
	
	  // total features committed 
	  LgFrTimeVecFloat featureCommit((size_t) nPeriods, 0.0);
	  // cum (featureDemand - featureCommit)
	  LgFrTimeVecFloat cumDelta((size_t) nPeriods, 0.0);
	  // second pass demand vol
	  LgFrTimeVecFloat featureAllocVol((size_t) nPeriods, 0.0);


	  float *  supplyVolSpecialFeaturePart;
	  witGetPartSupplyVol(theWitRun_, fullWitFeaturePart, &supplyVolSpecialFeaturePart);
	  float *  execVolSpecialFeaturePart;
	  witGetOperationExecVol(theWitRun_, fullWitFeaturePart, &execVolSpecialFeaturePart);


	  float prevPeriodDelta=0.0;
	  int t = 0; 
	  for (t=0; t<nPeriods; t++) {
	    featureDemand[t] = gpdDemVol[t] * consRate[t];
	    featureCommit[t] = supplyVolSpecialFeaturePart[t] + execVolSpecialFeaturePart[t];
	    cumDelta[t] = prevPeriodDelta + featureDemand[t] - featureCommit[t];
	    prevPeriodDelta = cumDelta[t];
	  }
	  
	  float shortfall = cumDelta[nPeriods - 1];
	  for (t=nPeriods-1; t>0; t--) {
	    if (shortfall < .00001)
	      break;
	    if (shortfall >= cumDelta[t-1])  {
	      featureAllocVol[t] = shortfall - cumDelta[t-1];
	      shortfall -= featureAllocVol[t];
	    }
	    else {
	      featureAllocVol[t] = 0;
	    }
	  }
	  featureAllocVol[0] = shortfall;


#ifdef DEBUG_PURE_OPTION_MAX_ATP
	  std::cout << "\n***DEBUG: MaxATP, PureOption \nGPD:" << fullWitGeoPlannerDemandOperation << ",   ";
	  std::cout << "CC Feature:" << fullWitFeaturePart << std::endl;
	  dumpaVec("gpdDemVol:", gpdDemVol);
	  dumpaVec("gpdExecVol:", gpdExecVol);
	  //	dumpaVec("featRatio:", usageRate);
	  std::cout << "featRatio:" << usageRate << std::endl;
	  dumpaVec("supplyVolSpecialFeaturePart:", supplyVolSpecialFeaturePart);
	  dumpaVec("execVolSpecialFeaturePart:", execVolSpecialFeaturePart);
	  dumpaVec("featureDemand:", featureDemand);
	  dumpaVec("featureCommit:", featureCommit);
	  dumpaVec("cumDelta:", cumDelta);
	  dumpaVec("featureAllocVol:", featureAllocVol);
#endif

	  
	  
	  
	  
	  
	  // YEAH, we've computed the second pass demand vol!!
	  // set it in appData
	  LgFrSceDemandAppData * dmdAppDataPtr;
	  witGetDemandAppData( theWitRun_, fullWitFeaturePart, featureDemandName.c_str(),
			       (void **) &dmdAppDataPtr);
	  if ( dmdAppDataPtr == 0 ) {
	    dmdAppDataPtr = new LgFrSceDemandAppData ((size_t) nPeriods, 1.0);
	    assert ( dmdAppDataPtr != 0 );
	    witSetDemandAppData( theWitRun_, fullWitFeaturePart, featureDemandName.c_str(),  
				 (void *) dmdAppDataPtr );
	  }
	  dmdAppDataPtr->allocVol(featureAllocVol);
	  
	  
	  // cleanup
	  witFree(gpdDemVol);
	  witFree(gpdExecVol);
	  witFree(consRate);
	  witFree(supplyVolSpecialFeaturePart);
	  witFree(execVolSpecialFeaturePart);
	}  // end (else it's a  NULL SUB for pure options or MWO)
	witFree(nullSub);
      }  // end    ...    if (nSubs > 0)   
      witFree(fullWitFeaturePart);
    }      // end  ...  for (int j=0; j<nBoms; j++)  
    witFree (operationList[o]);
  }    // end  ...    for ( int o=0; o<nOperations; o++ ) 
  witFree(operationList);
}





// ******************************************************************************
// initializeAllocDataFeaturePass()

// ------------------------------
// Set up allocLet List for features pass of  Heuristic Allocation Pass
// - FINISH_ME: Put allocVol in appData
// - DEVELOP_HERE
//       - Create an allocLet for each positive special features pass
//       - QSORT the allocLetList
//       - Note: the calling program is responsible for deleting any demand app data 
//                ptrs that are "new-ed" in here.
// ********************************************************************************
void
LgFrSceAllocationEngineMgr::initializeAllocDataFeaturePass()
{
  std::cout << "     ... executing initializeAllocDataFeaturePass ..." << std::endl;  

  int   * priority;
  int nPeriods;
  
  witGetNPeriods(theWitRun_, &nPeriods);
  int nParts;
  char  **partList;
  witGetParts(theWitRun_, &nParts, &partList);
  
  aPointer_ = 0;
  listMax_ = 0;
  
  // first count how many allocLets we need ==> listMax.
  // NOTE: we only count non-zero minDemandVols
  int i = 0; 
  for(i=0; i<nParts; i++) {

    char * fullWitFeaturePart = partList[i];

    // We are only interested in special Feature Parts which, at this time,
    // can either be custChoice or stdalone
    if (!  mpHelper_->isPartSpecialFeature(theWitRun_, fullWitFeaturePart)) {
      continue;
    }

    int nDemands;
    char ** dList;
    witGetPartDemands(theWitRun_, fullWitFeaturePart, &nDemands, &dList);
    LgFrSceDemandAppData * dmdAppDataPtr;
    witGetDemandAppData( theWitRun_, fullWitFeaturePart, dList[0],
			 (void **) &dmdAppDataPtr);
    if ( dmdAppDataPtr == 0 ) {
      witFree(dList[0]);
      witFree(dList);
      continue;
    }

    LgFrTimeVecFloat allocVol(dmdAppDataPtr->allocVol());
    int t = 0; 
    for (t=0; t<nPeriods; t++) {
      if (allocVol[t] > 0.0) {
         listMax_++;
      }
    }
    
    witFree(dList[0]);
    witFree(dList);
  }

  // status logging only 
  std::cout << "     ... allocLetList size:" << listMax_ << std::endl;

  // Now allocate the vector of allocLet Ptrs
  vecAllocLetList_ = new LgFrSceAllocLet [listMax_];
  // and the vector of allocLets
  allocLetList_ = new LgFrSceAllocLet * [listMax_];
  
  LgFrSceAllocLet * dependeeAllocLet = 0;

  // now load each allocLet
  for( i=0; i<nParts; i++){
    
    char * fullWitFeaturePart = partList[i];
    
    // We are only interested in special Feature Parts which, at this time,
    // can either be custChoice or stdalone
    if (!  mpHelper_->isPartSpecialFeature(theWitRun_, fullWitFeaturePart)) {
      witFree(partList[i]);
      continue;
    }
    
    // reset the dependee ptr to 0
    dependeeAllocLet = 0;
    
    int nDemands;
    char ** dList;
    witGetPartDemands(theWitRun_, fullWitFeaturePart, &nDemands, &dList);
    
    LgFrSceDemandAppData * dmdAppDataPtr;
    witGetDemandAppData( theWitRun_, fullWitFeaturePart, dList[0],
			 (void **) &dmdAppDataPtr);
    if ( dmdAppDataPtr == 0 ) {
      witFree(dList[0]);
      witFree(dList);
      witFree(partList[i]);
      continue;
    }
    
    LgFrTimeVecFloat allocVol(dmdAppDataPtr->allocVol());
    witGetDemandPriority(theWitRun_, fullWitFeaturePart, dList[0], &priority);
    
    
    int t = 0; 
    for (t=0; t<nPeriods; t++) {
      if (allocVol[t] > 0.0) {
	LgFrSceAllocLet & myAllocLet = vecAllocLetList_[aPointer_];
	allocLetList_[aPointer_] = &myAllocLet;
	myAllocLet.partName(fullWitFeaturePart);
	myAllocLet.demandName(dList[0]);
	myAllocLet.priority(priority[t]);
	myAllocLet.qtyDemand(allocVol[t]);
	myAllocLet.demandPd(t);
	myAllocLet.shipPd(t);
	myAllocLet.allocated(0);
	
	if (dependeeAllocLet != 0) {
	  // if there's a dependee, then he's waiting to know the current one
	  dependeeAllocLet->backlogDependent(&myAllocLet);
	}
	// remember this allocLet
	dependeeAllocLet = &myAllocLet;
	aPointer_++;
      }
    }
    
    witFree(dList[0]);
    witFree(dList);
    witFree(priority);
    witFree(partList[i]);
  }
  witFree(partList);
  
  assert(aPointer_ == listMax_);
  aPointer_ = 0;
  
  qsort(allocLetList_, 
        listMax_, 
	sizeof(LgFrSceAllocLet*), 
        sortStrategy_->compareVoidFunc());

}








 








 

// Part of an alternative method to calculate the (second pass) demand vols for features.
// This method pegs the shipVolWithoutFeature to the liveDemandVol, and using the
// featureRatio in the live demand period, calculates the demand vol of the feature in the second pass.
 
void
LgFrSceAllocationEngineMgr::calculateOneFeaturesBuildDemandVol ( int nPeriods,
                                                           float * liveDemandVol,
                                                           float * shipVolWithoutFeature,
                                                           float * featureRatio,
                                                           float * featureBuildDemandVols )
{
  // initialize the featureBuildDemandVols to zero
  int t = 0; 
  for (t=0; t<nPeriods; t++)
    featureBuildDemandVols[t] = 0.0;

 // need two counters.
 // td is the period for the "d"emand and ts is the period for the "ship"
 int td = 0;
 
 int ts = 0; 
 for ( ts=0; ts<nPeriods; ts++) {
   // if nothing to allocate then go on to the next shipVol bucket
   if ( shipVolWithoutFeature[ts] < AENGMGR_FLT_EPS )
     continue;

   while ( shipVolWithoutFeature[ts] > liveDemandVol[td] ) {
     featureBuildDemandVols[ts] += liveDemandVol[td] * featureRatio[td];
     shipVolWithoutFeature[ts] -= liveDemandVol[td];
     td++;
   }

   featureBuildDemandVols[ts] += shipVolWithoutFeature[ts] * featureRatio[td];
   liveDemandVol[td] -= shipVolWithoutFeature[ts];
 }

}

// Dan's algorithm for calculating the amount of demand lost due to backlogYield.
// original source code from:  /u/dpc/implode/sce/src/test2.c
// Given the demandVol, the shipVol, and the backlogYield vector, this method calculates
// the amount of demandVol that was "lost" due to applying the backlogYield (where shipLateLimit = 0).
//
// Example: demand= ( 2, 4, 6 ), ship=( 1, 2, 3 ) and backlogYld=( 0.6, 0.6, 0.6 )
// then the lostDemandVol=( 0.400, 1.040, 1.824)

void
LgFrSceAllocationEngineMgr::calculateLostDemandUnderBacklogYield ( int nPeriods,
                                                             float * demandVol,
                                                             float * shipVol,
                                                             float * backlogYield,
                                                             // output vectors
                                                             float * lostDemandVol,
                                                             float * backlog)
{
  float cumDemand, cumShip, cumLost;
  // initialize local variables  
  cumDemand = 0.0;
  cumShip = 0.0;
  cumLost = 0.0;

  // march through the periods, and iteratively calculate the amount
  // of demand lost in each period and the backlog

  // assumes your float * are nPeriods long
  int t = 0; 
  for(t=0; t<nPeriods; t++) {
    cumDemand += demandVol[t];
    cumShip += shipVol[t];
    backlog[t] = cumDemand - cumShip - cumLost;
    lostDemandVol[t] = (1.0 - backlogYield[t]) * backlog[t];
    cumLost += lostDemandVol[t];
  }

}

// Dan's algorithm for calculating the amount of demand lost due to shipLateLimit.
// original source code from: /u/dpc/implode/sce/src/test3.c
void
LgFrSceAllocationEngineMgr::calculateLostDemandUnderShipLateLimit ( int nPeriods,
                                                              int shipLateLimit,
                                                              float * demandVol,
                                                              float * shipVol,
                                                              // output vectors
                                                              float * lostDemandVol,
                                                              float * backlog )


{
  // Here, "cum" means cummulative over periods 0 to t, except for cumShipThruSLL.
  // cumShipThruSLL = shipVol[0] +...+ shipVol[t+ShipLateLimit]
  float cumDemand, cumShipThruSLL, cumLost, cumShip;

  float * loss = (float *) malloc (nPeriods * sizeof (float));
  assert (loss!=0);
  int t = 0; 
  for (t=0; t<nPeriods; t++)
    loss[t] = 0.0;

  float * cumLostVec = (float *) malloc (nPeriods * sizeof (float));
  assert (cumLostVec!=0);
  for ( t=0; t<nPeriods; t++)
    cumLostVec[t] = 0.0;
  
  cumDemand = 0.0;
  cumShipThruSLL = 0.0;
  cumShip = 0.0;
  cumLost = 0.0;
  for( t=0; t<shipLateLimit; t++) {
    cumShipThruSLL += shipVol[t];
  }

  // March through the periods and iteratively calculate the amount of
  // demandVol lost due to hitting the shipLateLimit.
  // We operate under the same assumption as the heuristic-fullfill
  // oldest demand first.
  
  int shipLateLimitHorizon = nPeriods-shipLateLimit;
  for ( t=0; t<nPeriods; t++ )   {
    cumDemand += demandVol[t];
    
    // In periods 0 thru (nPeriods-1-shipLateLimit), demand is either satisfied
    // or it is lost (due to the shipLateLimit).
    if ( t < shipLateLimitHorizon )   {
      cumShipThruSLL += shipVol[ t+shipLateLimit ];
      loss[t] = cumDemand - cumShipThruSLL - cumLost;
    }

    // In periods (nPeriods-shipLateLimit) thru (nPeriods-1) demand is either
    // satisfied or it is "unmet". The demand in these late periods never
    // hit the shipLateLimit.
    else {
      loss[t] = 0.0;
    }
    
    if (loss[t] < 0)
      loss[t] = 0.0;
    
    cumLost += loss[t];
  }
  
  // Dan shifts the lostDemandVol vector over to report the
  // the amount lost in the period where we defined it to be lost

  for ( t=0; t<shipLateLimit; t++ )
    lostDemandVol[t] = 0.0;
  for ( t=shipLateLimit; t<nPeriods; t++)
    lostDemandVol[t] = loss[t-shipLateLimit];

  cumLostVec[0]=lostDemandVol[0];
  for (t=1; t<nPeriods; t++)
    cumLostVec[t]=cumLostVec[t-1]+lostDemandVol[t];
  
  free (loss);

  // backlog calculation
  cumShip = shipVol[0];
  cumDemand = demandVol[0];
  backlog[0]=cumDemand-cumShip;
  for (t=1; t<nPeriods; t++) {
    cumShip += shipVol[t];
    cumDemand += demandVol[t];
    backlog[t] = cumDemand - cumShip - cumLostVec[t-1];
  }

  free (cumLostVec);
  
}
  

// copy constructor 
LgFrSceAllocationEngineMgr::LgFrSceAllocationEngineMgr(const LgFrSceAllocationEngineMgr& source)
  :   
  sceScenSP_ (source.sceScenSP_),
  theWitRun_ (source.theWitRun_),
  mpHelper_(source.mpHelper_),
  usageName_(source.usageName_)
{
  // nothing to do
}

// assignment operator
LgFrSceAllocationEngineMgr&
LgFrSceAllocationEngineMgr::operator=(const LgFrSceAllocationEngineMgr& rhs)
{
  if (this != &rhs) {		// Check for assignment to self
    sceScenSP_ = rhs.sceScenSP_;
    theWitRun_ = rhs.theWitRun_;
    mpHelper_ = rhs.mpHelper_;
    usageName_ = rhs.usageName_;
  }
  return *this;
}

// destructor
LgFrSceAllocationEngineMgr::~LgFrSceAllocationEngineMgr()
{

}


 
 
// ---------------------------------------------------------------------------
int
LgFrSceAllocationEngineMgr::sortID(std::string & sortStrategyString)
{
  if (0 == sce::compareStringsCaseIns( sortStrategyString, "truePriority" ))
    return LgFrSceSortId_PDS;
  else if (0 == sce::compareStringsCaseIns( sortStrategyString, "PDS" ))
    return LgFrSceSortId_PDS;
  else if (0 == sce::compareStringsCaseIns( sortStrategyString, "PSD" ))
    return LgFrSceSortId_PSD;
  else if (0 == sce::compareStringsCaseIns( sortStrategyString, "SPD" ))
    return LgFrSceSortId_SPD;
  else if (0 == sce::compareStringsCaseIns( sortStrategyString, "SDP" ))
    return LgFrSceSortId_SDP;
  else if (0 == sce::compareStringsCaseIns( sortStrategyString, "DSP" ))
    return LgFrSceSortId_DSP;
  else if (0 == sce::compareStringsCaseIns( sortStrategyString, "DPS" ))
    return LgFrSceSortId_DPS;

  else {
    std::cerr << "Error:  illegal sortStrrategy parameter ==> "
	 << sortStrategyString << "\n Terminating SCE\n";
    exit(8);
  }
  return 0;
}




// ---------------------------------------------------------------------------
int
LgFrSceAllocationEngineMgr::sortID()
{
  
    return sortStrategy_->sortId();
}




// Set the sort strategy
void 
LgFrSceAllocationEngineMgr::sortStrategy(LgFrSceSortStrategy * sStrat)
  {
    sortStrategy_ = sStrat;
  }

// Set the bklg strategy
// NOTE: this will eventually become an object
void 
LgFrSceAllocationEngineMgr::backlogStrategy(LgFrSceBacklogStrategy * bStrat)
  {
    bklgStrategy_ = bStrat;
  }


  // set flag to print trace
void   
LgFrSceAllocationEngineMgr::trace(int traceFlag)
  {
    traceFlag_ = traceFlag;
  }

  // set filename for trace
void   
LgFrSceAllocationEngineMgr::traceFileName(std::string & traceFile)
  {
    traceFileName_ = traceFile;
  }


// set usageName variable
void
LgFrSceAllocationEngineMgr::setUsageName(const std::string & usageName)
{
  usageName_ = usageName;
}

// Get usageName variable pointer
std::string 
LgFrSceAllocationEngineMgr::getUsageName()
{
  return usageName_;
}




// default constructor
LgFrSceAllocationEngineMgr::LgFrSceAllocationEngineMgr()
  :   
  sceScenSP_(),
  theWitRun_ (0),
  mpHelper_(0),
  usageName_(""),
  vecAllocLetList_(0),
  allocLetList_(0),
  sortStrategy_(0),
  bklgStrategy_(0),
  traceFlag_(0),
  traceFileName_(""),
  listMax_(0),
  aPointer_(0),
  outFile_()
{
    // all the work is done in initializer
}


// fairly general constructor:
LgFrSceAllocationEngineMgr::LgFrSceAllocationEngineMgr(
						       LgFrScenarioForSceSmartPointer sceScenSP,
						       WitRun * const theWitRun, 
						       LgFrMultiPlantHelper * mpHelper,
						       std::string & usageName)
  :   
  sceScenSP_(sceScenSP),
  theWitRun_ (theWitRun),
  mpHelper_(mpHelper),
  usageName_(usageName),
  vecAllocLetList_(0),
  allocLetList_(0),
  sortStrategy_(0),
  bklgStrategy_(0),
  traceFlag_(0),
  traceFileName_(""),
  listMax_(0),
  aPointer_(0),
  outFile_()
{
  LgFrSceSetOfParameters & setOfParameters =  sceScenSP_->setOfParameters();    

  if (usageName == "explosion") {
    traceFlag_ = setOfParameters.getBool("printHeurAllocExplodeTrace");
    traceFileName_ = setOfParameters.getString("heurAllocExplodeTraceFileName");
  }
  else {
    traceFlag_ = setOfParameters.getBool("printHeurAllocTrace");
    traceFileName_ = setOfParameters.getString("heurAllocTraceFileName");
  }
  
  
  
}















#ifdef NDEBUG
#undef NDEBUG
#endif



// self-test : can I self test ??
void
LgFrSceAllocationEngineMgr::test()
{
  // do-nothing test  
}

 










@


1.38
log
@selective Sets is working under 6.1
@
text
@a1914 1
//   - Most of this is clipped from setPureOptionBuildDemand() which is in hEngMgr
d1972 1
a1972 2
      if (mpHelper_->isPartSpecialCustChoiceFeature(theWitRun_, fullWitFeaturePart, 
						   gg, pp, ppdf, fp)) {
d1974 1
a1974 3

	std::string featureDemandName = 
	  mpHelper_->custChoiceFeatureDemandName(fullWitGeoPlannerDemandOperation );
a2053 6






@


1.37
log
@mfo fix take two
@
text
@d1948 1
a1948 1
						     plannerTopLevelPart, geo))  {
d1984 2
a1985 2
	float usageRate;
	witGetBomEntryUsageRate(theWitRun_, fullWitGeoPlannerDemandOperation.c_str(), j, &usageRate);	      
d2009 1
a2009 1
	  featureDemand[t] = gpdDemVol[t] * featRatio[t] * usageRate;
a2029 8



	// now we apply the usageRate
	//	for ( t=0; t<nPeriods; t++)
	//	  secondPassFeatureDemandVol[t] *= usageRate;

	    
d2185 2
a2186 2
	  float usageRate;
	  witGetBomEntryUsageRate(theWitRun_, fullWitGeoPlannerDemandOperation.c_str(), j, &usageRate);	      
d2210 1
a2210 1
	    featureDemand[t] = gpdDemVol[t] * usageRate;
d2268 1
@


1.36
log
@more dated fixes
@
text
@d521 1
a521 1

a523 1

a524 1

a525 2
    std::cout << "     ... executing  setPureOptionBuildAllocVolsForMaxATP ..." << std::endl;  

a526 2

    // 4.60:  Heuristic Binary Search Granularity
a527 2

    float searchIncScaleFactor;
a705 3
    // if there are have features, we need to do another round of implosion
    // determine how much of the feature can be built.
    
d711 1
a711 3
	      << heurAllocFeatSortStrategy 
	      << ") sort strategy ..." 
	      << std::endl;    
a712 1
    // set allocMgr's strategy.  
d715 7
a721 4
    // prep for Features pass.  Set the second pasa feature allocDemands
    // in app Data
    // set the demand on the feature nodes, and zero out the other demand

a727 3
    // intitialize allocLetList_ for special features pass
    // First "wave" of allocLets are exclusively for mins
    // The aboveMinDemands are stored in demand appData
d731 1
a731 1
    // allocate this bunch of allocLets
a738 1
    //  De-allocate the allocLet list for this pass
d745 1
a745 1
  } // end if (stand-alone features exist)
a1672 13













@


1.35
log
@intermediate commit towards implementation of Partial Periods and removal of wit34Compatible needs.  This code set is work in progress.
@
text
@d550 5
a554 3



@


1.34
log
@Last commit for maxForAtp
@
text
@d568 15
@


1.33
log
@enabled customer choice for max ATP
@
text
@d28 3
a30 2
// #define DEBUG_MAX_ATP
// #define DEBUG_CUSTOMER_CHOICE
d225 1
a225 1

d458 2
d528 3
a530 1
    std::cout << "Setting Greedy Search Increments Globally since no files used." << std::endl;
d546 1
a546 1
    std::cout << "Skipping Greedy Search Increment Global settings since input files were used." << std::endl;
a570 1
  std::cout << "     ...  witStartHeurAlloc ok" << std::endl;
d581 4
d600 2
d608 1
a608 1
  std::cout << "     ...  setting sortStrategy" << std::endl;
d610 1
a610 1
  std::cout << "     ...  setting sortStrategy OK" << std::endl;
d613 1
d615 5
a619 5
	 << heurAllocMinsSortStrategy 
	 << ") sort strategy ..." 
	 << std::endl;    
  }

d625 1
a625 1

d633 2
a634 2


d642 4
a645 2


d653 1
a653 1
  std::cout << "     ... allocating to Above Mins using (heurAlloc) scheme and ("
d704 1
a704 1
    std::cout << "     ... allocating to Standalone Features using (heurAlloc) scheme and ("
d855 1
a855 1
  std::cout << "     ... done testing priorities for non-increasing values" << std::endl;
a1105 3
  // status logging only 
  std::cout << "     ... about to new allocLetList of size:" << listMax_ << std::endl;
  std::cout << "     ... about to new vecAllocLetList of size:" << listMax_ << std::endl;
a1111 4
  
  // status logging only 
  std::cout << "     ... done new'ing" << std::endl;

d1114 2
a1115 2
  std::cout << "     ... about to loop through demands and populate ... allocLetLists" << std::endl;

d1180 1
a1180 1
  std::cout << "     ... done populating initial allocLetLists" << std::endl;
d1184 1
a1184 1
  std::cout << "     ... starting the initial qsort of allocLetList" << std::endl;
a1741 70

#if 0
	// DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD
	// DDDDDDDDDd   debug dump  DDDDDDDDDDD
	{
	  std::cout << "\n\n CC Feature: " << fullWitFeaturePart;

	  std::cout << "\n areRatiosConstant: " << areRatiosConstant;

	  std::cout << "\n gpdDemVol: ";
	  int tdbg = 0; 
	  for (tdbg=0; tdbg<nPeriods; tdbg++) {
	    std::cout << gpdDemVol[tdbg] << ",";
	  }

	  std::cout << "\n gpdExecVol: ";
	  for ( tdbg=0; tdbg<nPeriods; tdbg++) {
	    std::cout << gpdExecVol[tdbg] << ",";
	  }

	  std::cout << "\n featRatio: ";
	  for ( tdbg=0; tdbg<nPeriods; tdbg++) {
	    std::cout << featRatio[tdbg] << ",";
	  }

	  std::cout << "\n featureDemandPreUsageRate: ";
	  for ( tdbg=0; tdbg<nPeriods; tdbg++) {
	    std::cout << featureDemandPreUsageRate[tdbg] << ",";
	  }

	  std::cout << "\n featuresShippedPreUsageRate: ";
	  for ( tdbg=0; tdbg<nPeriods; tdbg++) {
	    std::cout << featuresShippedPreUsageRate[tdbg] << ",";
	  }

	  std::cout << "\n supplyVolCCfeaturePart: ";
	  for ( tdbg=0; tdbg<nPeriods; tdbg++) {
	    std::cout << supplyVolCCfeaturePart[tdbg] << ",";
	  }

	  std::cout << "\n execVolCCfeaturePart: ";
	  for ( tdbg=0; tdbg<nPeriods; tdbg++) {
	    std::cout << execVolCCfeaturePart[tdbg] << ",";
	  }

	  std::cout << "\n secondPassFeatureDemandVol: ";
	  for ( tdbg=0; tdbg<nPeriods; tdbg++) {
	    std::cout << secondPassFeatureDemandVol[tdbg] << ",";
	  }

	  int nSubs;
	  witGetBomEntryNSubsBomEntries(theWitRun_, fullWitGeoPlannerDemandOperation.c_str(), j, &nSubs);
	  if (nSubs > 0)   {
	    assert (nSubs == 1);
	    float * subVol;
	    witGetSubsBomEntrySubVol(theWitRun_, fullWitGeoPlannerDemandOperation.c_str(), j, 0, &subVol);

	    std::cout << "\n nullSubVol: ";
	    for ( tdbg=0; tdbg<nPeriods; tdbg++) {
	      std::cout << subVol[tdbg] << ",";
	    }
	  
	    witFree(subVol);
	  }

	  std::cout << "\n";
	}
	// DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD
#endif

d1960 1
d1982 1
a1982 1
      // + If its a CUSTOMER_CHOICE_FEATURES
d2063 1
a2063 1
#ifdef DEBUG_CUSTOMER_CHOICE
d2093 6
a2098 4
      // + --------------------------------
      // + If its a STANDALONE FEATURE
      // + --------------------------------
      // Just for the sake of it ....
a2100 6
      


      // if there are substitutes, then the child might be a pure option
      // note that one must look at the NullSub part to determine which of the three
      // type of STANDALONE FEATUREs it is ...
a2102 1

a2103 1

a2104 1

a2106 9
	
	// the nullSub will be one of:
	//    globalNullSub (Purely optional standalone feature)
	//    globalMaxWithoutNullsub (purely mandatory standalone feature)
	//    maxWithoutNullsub  (standalone feature with 0<maxWithout <1)
	
	// -------------------------------------------------------------
	// if its a Mandatory Feature (global maxwithout)
	// -------------------------------------------------------------
d2108 4
d2173 1
a2173 1
#ifdef DEBUG_MAX_ATP
d2185 2
a2186 1
	  witFree(nullSub);
d2192 1
a2192 1
	  // if its a PURE Option or a MWO (ie, purely optional or partly mandatory)
a2194 1
	  
a2196 1
	  
d2198 36
d2235 30
a2264 3
	  // get the subVol of the nullSub
	  float * subVol;
	  witGetSubsBomEntrySubVol(theWitRun_, fullWitGeoPlannerDemandOperation.c_str(), j, 0, &subVol);
a2267 28
	  if ( featureRatioPegMethod == "pegToMachineShipPeriod" ) {
	    // FINISH_ME: check this out!!!  
	    //     .... The default if pegToMachineShipPeriod but esg wants pegToMachineDemandPeriod
	    
	    
	    // But, we need the usageRatio...
	    // FINISH_ME: 2001/07/19: this now needs to be consRate!!!
	    float usageRatio;
	    witGetBomEntryUsageRate(theWitRun_, fullWitGeoPlannerDemandOperation.c_str(), j, &usageRatio);
	    
	    // this was originally commented out with the following FINISH_ME: check it out, please.
	    //	      int * impactPeriod;
	    //	      witGetBomEntryImpactPeriod(theWitRun_, fullWitGeoPlannerDemandOperation.c_str(), j, &impactPeriod);
	    // FINISH_ME: this is not right yet
	    
	    // ...to calculate the amount of the substitute that was consumed
	    // which is equal to the amount of the pure option we want to try and build.
	    
	    int t = 0; 
	    for (t=0; t<nPeriods; t++) {
	      if (subVol[t] > 0.0001) {
		//		  assert(impactPeriod[t] >= 0);
		//		  pureOptBldDemVol[impactPeriod[t]] += (usageRatio * subVol[t]);
		pureOptBldDemVol[t] = usageRatio * subVol[t];
	      }
	      //	      witFree(impactPeriod);
	    }
	  }
a2268 2

	  assert (pureOptBldDemVol.min() >= 0.0);	
d2281 1
a2281 1
	  dmdAppDataPtr->allocVol(pureOptBldDemVol);
d2285 4
a2288 2
	  witFree(subVol);
	  witFree(nullSub);
d2290 1
a2317 3
  


a2319 1

a2322 1
    
d2327 1
a2327 3



d2330 1
a2330 1

d2334 1
a2334 1
  for(i=0; i<nParts; i++){
d2361 2
a2362 2
         }
       }
a2366 2
 

d2368 2
d2380 1
a2380 1

d2382 1
a2382 1

d2386 1
d2389 1
a2389 3



d2392 1
a2392 3



d2396 1
a2396 5





d2403 1
d2406 1
a2406 1

d2410 1
a2410 1
      
@


1.32
log
@turned debug off
@
text
@d1 2
a3 1
// RW2STL - inserted:
a6 4
// End of RW2STL - inserted includes.
// file: aEngMgr.C
// author:  tom

a12 3



a20 1
//  #include <sce/src/itHelpr.h>
d29 1
a29 7

// FINISH_ME: needs min demand file for independent demand

// FINISH_ME: using incHeurAlloc for features pass ... what happens to unit lot-sizing???



d1985 1
a1985 1
// ------------------------------
d2063 2
a2064 28
	// total features needed
	LgFrTimeVecFloat featureDemandPreUsageRate((size_t) nPeriods, 0.0);

	// This *may* be obsolete.  It's an attempt to adjust the execVols back to the 
	// the period when the demand was due. 
	LgFrTimeVecFloat tiedBackGpdExecVol((size_t) nPeriods, gpdExecVol);



#ifdef DEBUG_SET_PURE_OPTIONS
	std::cout << "\n\n******\nGPD:" << fullWitGeoPlannerDemandOperation << std::endl;
	std::cout << "CC Feature:" << fullWitFeaturePart << std::endl;
	dumpaVec("gpdDemVol:", gpdDemVol);
	dumpaVec("gpdExecVol:", gpdExecVol);
	dumpaVec("featRatio:", featRatio);
#endif


	// if the ratio's are constant over time, then life is easy
	int areRatiosConstant = 0;
	if (featRatio.max() - featRatio.min() < 0.0001) {
	  areRatiosConstant = 1;
	  
	  // featureDemandPreUsageRate is GPD ships times the featRatio	  
	  int t = 0; 
	  for ( t=0; t<nPeriods; t++)
	    featureDemandPreUsageRate[t] = featRatio[t] * tiedBackGpdExecVol[t];
	}
d2066 6
a2071 56
	// if the ratio's change over time, then life is a pain in the ass
	// here are two ways to implement, both of which are problematic
	// For now we have an emergency fix that forces ESG user's to make
	// all ratio's equal.   Thus this case of "ratio's changing" won't bite us
	// However, there are other issues to consider ... 
	//    MachFeat Supply, 
	//    MachFeat Offsets
	//    GeoSpource transit times
	//    anything else ????
	// If's a major FINISH_ME: to clear this up!!!   We may need to retract some 
	// sce functionality
	else {
	  // ----------------------------------------------------------	  
	  // ---- Method 1: only used when ratio's change over time  ----
	  // This method was flawed and was to be be replaced by method 2,
	  // but that was screwing up also
	  
	  // Compute ==> tiedBackGpdExecVol 
	  int t = 0; 
	  for (t=0; t<nPeriods; t++) {
	    float demExcess = gpdDemVol[t] - tiedBackGpdExecVol[t];
	    // if this period matches, then continue
	    if (demExcess < .001)
	      continue;
	    // otherwise, look for future commits to pull in
	    int t2 = 0; 
	    for (t2=t+1; t2<nPeriods; t2++) {
	      // if period t2 execVol covers period t delta, then pull it in
	      if (tiedBackGpdExecVol[t2]  >= demExcess) {
		tiedBackGpdExecVol[t] += demExcess;
		tiedBackGpdExecVol[t2] -= demExcess;
		demExcess = 0.0;
		break;
	      }
	      else {
		tiedBackGpdExecVol[t] += tiedBackGpdExecVol[t2];
		demExcess -= tiedBackGpdExecVol[t2];
		tiedBackGpdExecVol[t2] = 0.0;
	      }
	    }
	    // now if you didn't clear the demand gap, then you're done
	    // since you've (necesarily) exhausted all future commits
	    // So break out of the loop
	    if (demExcess > 0.001) {
	      break;
	    }
	  }
	  // End: Compute ==> tiedBackGpdExecVol 	    
	  
	  // now compute the total Features Needed ...
	  // featureDemandPreUsageRate is basically the GPD shipVol times the featRatio
	  for ( t=0; t<nPeriods; t++)
	    featureDemandPreUsageRate[t] = featRatio[t] * tiedBackGpdExecVol[t];

	}  // matches the else  regarding featratio's changing over time

a2072 4
#ifdef DEBUG_SET_PURE_OPTIONS
	dumpaVec("featureDemandPreUsageRate:", featureDemandPreUsageRate);
	dumpaVec("tiedBackGpdExecVol:", tiedBackGpdExecVol);
#endif
a2073 4
	// here's the amount of features supplied in first pass (pre usageRate)
	//     featuresShippedPreUsageRate = supplyVolCCfeaturePart + execVolCCfeaturePart;
	LgFrTimeVecFloat featuresShippedPreUsageRate((size_t) nPeriods, 0.0);
	
a2077 20
	
	int t = 0; 
	for ( t=0; t<nPeriods; t++) {
	  featuresShippedPreUsageRate[t] = supplyVolCCfeaturePart[t] + execVolCCfeaturePart[t];
	}
	
	// here's the straight net of what you need for the second pass (pre usageRate)
	LgFrTimeVecFloat secondPassFeatureDemandVol((size_t) nPeriods, 0.0);
	for ( t=0; t<nPeriods; t++)
	  secondPassFeatureDemandVol[t] = featureDemandPreUsageRate[t] - featuresShippedPreUsageRate[t];
	
	
#ifdef DEBUG_SET_PURE_OPTIONS
	dumpaVec("supplyVolCCfeaturePart:", supplyVolCCfeaturePart);
	dumpaVec("execVolCCfeaturePart:", execVolCCfeaturePart);
	dumpaVec("featuresShippedPreUsageRate:", featuresShippedPreUsageRate);
	dumpaVec("secondPassFeatureDemandVol:", secondPassFeatureDemandVol);
#endif
	
	
a2078 21
	// ---------------------------------------------
	// Roll Negatives Forward:  approach  11/30/2001
	// ---------------------------------------------
	//       (now we have the luxury that all ratio's are constant)
	// Walk backwards through the timeVec  from pd n-1 to 0
	// if you find a negative carry it along and work it off
	for ( t=nPeriods-1; t>0; t--) {
	  if (secondPassFeatureDemandVol[t] < 0) {
	    secondPassFeatureDemandVol[t-1] += secondPassFeatureDemandVol[t];
	    secondPassFeatureDemandVol[t] = 0;
	  }
	}
#ifdef DEBUG_SET_PURE_OPTIONS
	std::cout << "... rolled negatives  forward of secondPassFeatureDemandVol\n";
	dumpaVec("secondPassFeatureDemandVol:", secondPassFeatureDemandVol);
#endif
	// ok, so what happens if you can't work it all off? ... punt!
	// 
	if (secondPassFeatureDemandVol[0] < 0) {
	  if (secondPassFeatureDemandVol[0] < -0.01) {
	    std::cout << "Internal SCE Code Alert: SCE00645AH.  Please notify the SCE Development Team.\n";
d2080 7
a2086 16
	    std::cout << "\n\n******\nGPD:" << fullWitGeoPlannerDemandOperation << std::endl;
	    std::cout << "CC Feature:" << fullWitFeaturePart << std::endl;
	    dumpaVec("gpdDemVol:", gpdDemVol);
	    dumpaVec("gpdExecVol:", gpdExecVol);
	    dumpaVec("featRatio:", featRatio);
	    dumpaVec("supplyVolCCfeaturePart:", supplyVolCCfeaturePart);
	    dumpaVec("execVolCCfeaturePart:", execVolCCfeaturePart);
	    dumpaVec("featuresShippedPreUsageRate:", featuresShippedPreUsageRate);
	    dumpaVec("secondPassFeatureDemandVol:", secondPassFeatureDemandVol);

	  }
	  secondPassFeatureDemandVol[0] = 0;
#ifdef DEBUG_SET_PURE_OPTIONS
	  std::cout << "... but had a negative in pd 0 so we flatten it.\n";
	  dumpaVec("secondPassFeatureDemandVol:", secondPassFeatureDemandVol);
#endif
a2087 3
	// ---------------------------------------------
	// END: Roll Negatives Forward:  approach  11/30/2001
	// ---------------------------------------------
d2089 7
a2095 11

	// now insure that the cum of secondPassFeatureDemandVol does not exceed the 
	// cum of machines shipped!
	for ( t=0; t<nPeriods; t++) {
	  // add in what you rolled from last period
	  float delta = secondPassFeatureDemandVol[t] - gpdExecVol[t];
	  // do you need to roll?
	  if (delta > 0) {
	    secondPassFeatureDemandVol[t] = gpdExecVol[t];
	    if (t+1 < nPeriods)
	      secondPassFeatureDemandVol[t+1] += delta;
a2096 1
	  // or not roll?
d2098 1
a2098 2
	    if (t+1 < nPeriods)
	      gpdExecVol[t+1] -= delta;
d2100 2
a2101 1
	}  //  end ... Roll negative forward
d2103 1
a2103 5

#ifdef DEBUG_SET_PURE_OPTIONS
	  std::cout << "... just adjusted for spfd exceeding gpdExecVol.\n";
	  dumpaVec("secondPassFeatureDemandVol:", secondPassFeatureDemandVol);
#endif
d2108 2
a2109 24
	for ( t=0; t<nPeriods; t++)
	  secondPassFeatureDemandVol[t] *= usageRate;


#ifdef DEBUG_SET_PURE_OPTIONS
	if (usageRate < 1 || usageRate>1) {
	  std::cout << "... just applied non-unit usageRate\n";
	  dumpaVec("secondPassFeatureDemandVol:", secondPassFeatureDemandVol);
	}
#endif


#ifdef DEBUG_SET_PURE_OPTIONS
	// and now we're done debugging
	std::cout << "****** \n\n";
#endif



#if 0
	// DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD
	// DDDDDDDDDd   debug dump  DDDDDDDDDDD
	{
	  std::cout << "\n\n CC Feature: " << fullWitFeaturePart;
a2110 64
	  std::cout << "\n areRatiosConstant: " << areRatiosConstant;

	  std::cout << "\n gpdDemVol: ";
	  int tdbg = 0; 
	  for (tdbg=0; tdbg<nPeriods; tdbg++) {
	    std::cout << gpdDemVol[tdbg] << ",";
	  }

	  std::cout << "\n gpdExecVol: ";
	  for ( tdbg=0; tdbg<nPeriods; tdbg++) {
	    std::cout << gpdExecVol[tdbg] << ",";
	  }

	  std::cout << "\n featRatio: ";
	  for ( tdbg=0; tdbg<nPeriods; tdbg++) {
	    std::cout << featRatio[tdbg] << ",";
	  }

	  std::cout << "\n featureDemandPreUsageRate: ";
	  for ( tdbg=0; tdbg<nPeriods; tdbg++) {
	    std::cout << featureDemandPreUsageRate[tdbg] << ",";
	  }

	  std::cout << "\n featuresShippedPreUsageRate: ";
	  for ( tdbg=0; tdbg<nPeriods; tdbg++) {
	    std::cout << featuresShippedPreUsageRate[tdbg] << ",";
	  }

	  std::cout << "\n supplyVolCCfeaturePart: ";
	  for ( tdbg=0; tdbg<nPeriods; tdbg++) {
	    std::cout << supplyVolCCfeaturePart[tdbg] << ",";
	  }

	  std::cout << "\n execVolCCfeaturePart: ";
	  for ( tdbg=0; tdbg<nPeriods; tdbg++) {
	    std::cout << execVolCCfeaturePart[tdbg] << ",";
	  }

	  std::cout << "\n secondPassFeatureDemandVol: ";
	  for ( tdbg=0; tdbg<nPeriods; tdbg++) {
	    std::cout << secondPassFeatureDemandVol[tdbg] << ",";
	  }

	  int nSubs;
	  witGetBomEntryNSubsBomEntries(theWitRun_, fullWitGeoPlannerDemandOperation.c_str(), j, &nSubs);
	  if (nSubs > 0)   {
	    assert (nSubs == 1);
	    float * subVol;
	    witGetSubsBomEntrySubVol(theWitRun_, fullWitGeoPlannerDemandOperation.c_str(), j, 0, &subVol);

	    std::cout << "\n nullSubVol: ";
	    for ( tdbg=0; tdbg<nPeriods; tdbg++) {
	      std::cout << subVol[tdbg] << ",";
	    }
	  
	    witFree(subVol);
	  }

	  std::cout << "\n";
	}
	// DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD
#endif

	    
d2123 1
a2123 1
	dmdAppDataPtr->allocVol(secondPassFeatureDemandVol);
d2126 20
d2213 1
a2213 1
            cumDelta[t] = prevPeriodDelta + gpdDemVol[t] - gpdExecVol[t];
d2249 2
a2250 1
	  std::cout << "... Debug For MaxATP.\n";
@


1.31
log
@first pass at maxImpliedCommitForATP
@
text
@d35 1
a35 1
#define DEBUG_MAX_ATP
@


1.30
log
@Version 5.  initial commit
@
text
@d35 1
d554 1
a554 1
    std::cout << "Skipping  Greedy Search Increment Global settings since infput files were  used." << std::endl;
a570 2


d715 6
a720 1
    this->setPureOptionBuildAllocVols();
d1996 570
@


1.29
log
@sce 4.60, scrapCost, stockCost, greedySearchIncrement,pegging in heuristic, removal of optWithLotSizes
@
text
@d530 9
d540 11
a550 5
  std::string greedySearchIncrementMethod = setOfParameters.getString("greedySearchIncrementMethod");
  float searchIncScaleFactor;
  if (sce::compareStringsCaseIns(greedySearchIncrementMethod, "autoScale") == 0) {
    float searchIncScaleFactor =  setOfParameters.getFloat("searchIncScaleFactor");
    sceScenSP_->setHeuristicSearchIncrement(theWitRun_, greedySearchIncrementMethod, searchIncScaleFactor); 
d553 1
a553 2
    float searchIncAbsValue =  setOfParameters.getFloat("searchIncAbsValue");
    sceScenSP_->setHeuristicSearchIncrement(theWitRun_, greedySearchIncrementMethod, searchIncAbsValue); 
a560 1

d1066 1
a1066 1
  // NOTE: we only count non-zero minDemandVols
d1242 1
@


1.28
log
@when priorities are found to be increasing in aEngMgr, they are forced to
be non-increasing.   And messaging is only done once.
@
text
@d524 1
d528 20
d725 1
a725 1
    witFinishHeurAlloc(theWitRun_);
d728 1
@


1.27
log
@First pass at sce 4.20 function.
@
text
@d772 1
d786 1
a786 1
      
d791 10
a800 4
	  std::cout << "Warning: priority vector is increasing ... \n"
	       << "Part: " << partName << "\n"
	       << "Demand: " << demandName << "\n"
	       << "period: " << t << std::endl;
d805 4
d1024 2
a1025 1

d1067 3
d1077 6
d1147 8
d1160 3
@


1.26
log
@4.20 commit: global subs, prioritized explode
@
text
@a2279 1
  engine_(source.engine_),
a2292 1
    engine_ = rhs.engine_;
a2377 14
// set engine variable
void
LgFrSceAllocationEngineMgr::setEngine(const std::string & engine)
{
  engine_ = engine;
}

// Get engine variable pointer
std::string 
LgFrSceAllocationEngineMgr::getEngine()
{
  return engine_;
}

a2401 1
  engine_(""),
a2421 1
						       const std::string & engine,
a2426 1
  engine_(engine),
@


1.25
log
@sce4.10 changes
@
text
@a482 3
  // ounce of prevention is worth a pound of ...
  assert (engine_ == "heuralloc");

d498 3
a500 1
  std::cout << "Executing (Heur Allocation) implosion engine using ("
d2277 5
a2281 5
      sceScenSP_ (source.sceScenSP_),
      theWitRun_ (source.theWitRun_),
      theCal_(source.theCal_),
      mpHelper_(source.mpHelper_),
      engine_(source.engine_)
a2292 1
    theCal_ = rhs.theCal_;
d2295 1
d2393 19
a2416 1
  theCal_(0),
d2419 1
d2436 5
a2440 5
                                         LgFrScenarioForSceSmartPointer sceScenSP,
                                         WitRun * const theWitRun, 
                                         LgFrCalendar * theCal,
                                         LgFrMultiPlantHelper * mpHelper,
                                         const std::string & engine)
a2443 1
  theCal_(theCal),
d2446 1
d2459 10
a2468 2
  traceFlag_ = setOfParameters.getBool("printHeurAllocTrace");
  traceFileName_ = setOfParameters.getString("heurAllocTraceFileName");
d2497 1
a2497 1
 }
d2502 8
@


1.24
log
@preping for release 4.1
@
text
@a33 1

@


1.23
log
@feature sets logic automatically uses proportional routing when engine is NOT optimization.   for optimization, it uses the OLD BBCat modelling trick.
@
text
@d533 7
@


1.22
log
@more minor memory fixes
@
text
@d1258 1
a1258 2
#ifdef DEBUG_SET_PURE_OPTIONS
// vec debug
a1285 1
#endif
d1393 1
a1393 1

d1399 1
a1399 1

d1413 1
d1590 24
@


1.21
log
@more memory cleanup
@
text
@d539 1
d541 1
d573 1
d575 1
d794 1
d800 1
d836 1
a836 1

d981 2
@


1.20
log
@fixed some bad memory management ... was freeing insted of deleting
@
text
@d178 1
a178 1
	  free(priorityVec);
a294 1
        // eqShipQty     =  new float[aWithinEq];
d416 1
a416 1
		free(priorityVec);
a711 6

  //
  // Clean-Up: free up all the memory we malloc-ed and no longer need
  //
  

d851 2
a852 2
      portableFree ( hardLower);
      portableFree ( hardUpper );
d857 1
a857 1
      portableFree ( cumShipBound );
d872 1
d876 1
a876 1
  allocLetList_ = new LgFrSceAllocLet * [listMax_];
d894 2
a895 2
      portableFree ( hardLower);
      portableFree ( hardUpper );
d900 1
a900 1
      portableFree ( cumShipBound );
d1177 1
a1177 1
	portableFree(fullWitFeaturePart);
d1217 3
a1219 3
	portableFree(featDemandVol);
	portableFree(gpdDemVol);
	portableFree(fullWitFeaturePart);
d1237 1
a1237 1
	portableFree(dList[j]);
d1239 2
a1240 2
      portableFree(dList);
      portableFree(fullWitFeaturePart);
d1242 1
a1242 1
    portableFree (operationList[o]);
d1244 1
a1244 1
  portableFree(operationList);
d1341 1
a1341 1
	portableFree(fullWitFeaturePart);
d1703 1
a1703 1
	    portableFree(subVol);
d1732 5
a1736 5
	portableFree(gpdDemVol);
	portableFree(gpdExecVol);
	portableFree(supplyVolCCfeaturePart);
	portableFree(execVolCCfeaturePart);
	portableFree(fullWitFeaturePart);
d1775 1
a1775 1
	  portableFree(nullSub);
d1853 1
a1853 1
	    //	      portableFree(impactPeriod);
d1875 2
a1876 2
	portableFree(subVol);
	portableFree(nullSub);
d1878 1
a1878 1
      portableFree(fullWitFeaturePart);
d1880 1
a1880 1
    portableFree (operationList[o]);
d1882 1
a1882 1
  portableFree(operationList);
d2221 1
a2221 1
  portableFree (loss);
d2233 1
a2233 1
  portableFree (cumLostVec);
@


1.19
log
@permanently replaced Concurrent Pegging with Post Implosion pegging.
Parameters stay the same though.
@
text
@d463 5
a467 7
       delete [] eqShipPd;    
       delete [] eqDemandQty; 
       free(eqShipQty);    
       delete [] eqPartList;  
       delete [] eqDemandList;


@


1.18
log
@rearranged to gt PIP after postProcess
@
text
@d705 1
d708 1
a708 8
    sceScenSP_->loadPegDataIntoAppData(theWitRun_);
  }

  //post-process
  witPostprocess (theWitRun_ );    
  
  bool doPIP = setOfParameters.getBool("doPIP");
  if (doPIP) {
@


1.17
log
@added witBuildPip
@
text
@a509 8

  // FINISH_ME: Must ensure that there are demandVols set up, even though we will 
  // use allocVol's
  //
  // TEMP solution:lets go in and set demandVols on special Feature parts to be big M



d517 2
a518 2


a520 2


a524 5





a531 2


d536 1
a536 5

  witBoolean doesWitPipExist;

  witGetPipExists(theWitRun_, &doesWitPipExist);
  std::cout << "witPIPExists=" << std::endl;                      
a543 3
  witGetPipExists(theWitRun_, &doesWitPipExist);
  std::cout << "just started HeurAlloc ... witPIPExists=" << doesWitPipExist << std::endl;                      

a567 2
  

a582 4




a588 2


a605 4
  witGetPipExists(theWitRun_, &doesWitPipExist);
  std::cout << "just finished mins run  ... witPIPExists=" << doesWitPipExist << std::endl;                      


a624 1
  
a631 5
  witGetPipExists(theWitRun_, &doesWitPipExist);
  std::cout << "just finished initializeAllocDataAboveMins  ... witPIPExists=" << doesWitPipExist << std::endl;                      



a648 4
  witGetPipExists(theWitRun_, &doesWitPipExist);
  std::cout << "just finished main implosion   ... witPIPExists=" << doesWitPipExist << std::endl;                      
  

a654 5
  //

  

   
a660 2
    
    
a664 3
    
    
    
a669 3
    
    
    
a672 1
    
a677 6

    witGetPipExists(theWitRun_, &doesWitPipExist);
    std::cout << "just finished setPureOptionBuildAllocVols   ... witPIPExists=" << doesWitPipExist << std::endl;                      
    

    
a691 1
    
a697 5

    witGetPipExists(theWitRun_, &doesWitPipExist);
    std::cout << "finished feature pass, about to call witFinishHeurAlloc  ... witPIPExists=" << doesWitPipExist << std::endl;                      

    
a698 6

    witGetPipExists(theWitRun_, &doesWitPipExist);
    std::cout << "just  called witFinishHeurAlloc  ... witPIPExists=" << doesWitPipExist << std::endl;                      
    
    
    
a704 2
  
  
a709 4
  witGetPipExists(theWitRun_, &doesWitPipExist);
  std::cout << "just  did load PEG data in AppData  ... witPIPExists=" << doesWitPipExist << std::endl;                      


a711 1

a717 2

  
@


1.16
log
@*** empty log message ***
@
text
@d554 5
d564 4
d638 2
d669 3
d690 3
d703 1
d737 4
d765 4
d771 3
d790 8
d800 1
a804 2
  //post-process
  witPostprocess (theWitRun_ );    
@


1.15
log
@first level of PIP
@
text
@a510 1

d761 4
a771 4
  bool doPIP = setOfParameters.getBool("doPIP");
  if (doPIP) {
    sceScenSP_->loadPIPDataIntoAppData(theWitRun_);
  }
@


1.14
log
@fixed critList bug
@
text
@d769 5
@


1.13
log
@minor updates for SCE
@
text
@d694 1
a694 1

d700 3
a702 3



d705 5
a709 3
	 << heurAllocFeatSortStrategy 
	 << ") sort strategy ..." 
	 << std::endl;    
a710 2


d714 2
a715 2


d720 1
a720 26



  // intitialize allocLetList_ for special features pass
  // First "wave" of allocLets are exclusively for mins
  // The aboveMinDemands are stored in demand appData
  this->initializeAllocDataFeaturePass();


  // allocate this bunch of allocLets
  if  (1 == equitability){
    this->heurIncAlloc();
  }
  else {
    this->heurEqAlloc();
  }


  //  De-allocate the allocLet list for this pass
  if (listMax_ > 0) {
    delete [] allocLetList_;
    delete [] vecAllocLetList_;
  }
  delete mySortStrategy;

  witFinishHeurAlloc(theWitRun_);
d723 23
a746 2
  if (computeCriticalList) 
    theCritList.merge( theWitRun_);
d750 7
a756 2


@


1.12
log
@commiting to main branch witutil, scenario, and sce code which removes RW
@
text
@d302 1
a302 1
        int j = 0; // Pulled out of the for below by RW2STL
d824 1
a824 1
  int i = 0; // Pulled out of the for below by RW2STL
d830 1
a830 1
    int j = 0; // Pulled out of the for below by RW2STL
d839 1
a839 1
      int t = 0; // Pulled out of the for below by RW2STL
d898 1
a898 1
  int i = 0; // Pulled out of the for below by RW2STL
d904 1
a904 1
    int j = 0; // Pulled out of the for below by RW2STL
d922 1
a922 1
      int t = 0; // Pulled out of the for below by RW2STL
d946 1
a946 1
    int j = 0; // Pulled out of the for below by RW2STL
d970 1
a970 1
      int t = 0; // Pulled out of the for below by RW2STL
d1067 1
a1067 1
  int i = 0; // Pulled out of the for below by RW2STL
d1079 1
a1079 1
    int j = 0; // Pulled out of the for below by RW2STL
d1091 1
a1091 1
      int t = 0; // Pulled out of the for below by RW2STL
d1124 1
a1124 1
    int j = 0; // Pulled out of the for below by RW2STL
d1138 1
a1138 1
      int t = 0; // Pulled out of the for below by RW2STL
d1203 1
a1203 1
  int t = 0; // Pulled out of the for below by RW2STL
d1213 1
a1213 1
  int o = 0; // Pulled out of the for below by RW2STL
d1227 1
a1227 1
    int j = 0; // Pulled out of the for below by RW2STL
d1271 1
a1271 1
	int t = 0; // Pulled out of the for below by RW2STL
d1294 1
a1294 1
      int j = 0; // Pulled out of the for below by RW2STL
d1320 1
a1320 1
  int t = 0; // Pulled out of the for below by RW2STL
d1334 1
a1334 1
  int t = 0; // Pulled out of the for below by RW2STL
d1377 1
a1377 1
  int o = 0; // Pulled out of the for below by RW2STL
d1391 1
a1391 1
    int j = 0; // Pulled out of the for below by RW2STL
d1449 1
a1449 1
	  int t = 0; // Pulled out of the for below by RW2STL
d1473 1
a1473 1
	  int t = 0; // Pulled out of the for below by RW2STL
d1480 1
a1480 1
	    int t2 = 0; // Pulled out of the for below by RW2STL
d1515 1
a1515 1
	  int t = 0; // Pulled out of the for below by RW2STL
d1520 1
a1520 1
	    int t2 = 0; // Pulled out of the for below by RW2STL
d1571 1
a1571 1
	int t = 0; // Pulled out of the for below by RW2STL
d1711 1
a1711 1
	  int tdbg = 0; // Pulled out of the for below by RW2STL
d1906 1
a1906 1
	  int t = 0; // Pulled out of the for below by RW2STL
d1986 1
a1986 1
  int i = 0; // Pulled out of the for below by RW2STL
d2010 1
a2010 1
    int t = 0; // Pulled out of the for below by RW2STL
d2070 1
a2070 1
    int t = 0; // Pulled out of the for below by RW2STL
d2140 1
a2140 1
  int t = 0; // Pulled out of the for below by RW2STL
d2148 1
a2148 1
 int ts = 0; // Pulled out of the for below by RW2STL
d2193 1
a2193 1
  int t = 0; // Pulled out of the for below by RW2STL
d2223 1
a2223 1
  int t = 0; // Pulled out of the for below by RW2STL
@


1.11
log
@Added include of mcl/src/mcl.h near top of include list to avoid
compile time problems on AIX which did not occur on Windows.

added
  implement(RWGVector, float)
  implement(RWGVector, int)
to ipSce.C to avoid unresolved symbols at link time
@
text
@d1 6
d57 1
a57 1
  RWCString heurAllocBacklogPriority = setOfParameters.getString("heurAllocBacklogPriority");
d60 1
a60 1
  if      (0 == heurAllocBacklogPriority.compareTo("memorylessRoll", RWCString::ignoreCase)) 
d62 1
a62 1
  else if (0 == heurAllocBacklogPriority.compareTo("immediate", RWCString::ignoreCase)) 
d66 1
a66 1
    cerr << "Warning:  illegal value for parameter heurAllocBacklogPriority ==> "
d79 2
a80 2
                    myAllocLet.partName(),
                    myAllocLet.demandName(),
d108 1
a108 1
      RWCString p, g;
d110 1
a110 1
      RWCString p0 = partList[0];
d143 1
a143 1
	if (backlogDependentPtr != NULL) {
d174 2
a175 2
			       myAllocLet.partName(), 
			       myAllocLet.demandName(), 
d186 1
a186 1
      // do this if useRolloverBacklogPolicy == FALSE
d224 1
a224 1
  RWCString heurAllocBacklogPriority = setOfParameters.getString("heurAllocBacklogPriority");
d227 1
a227 1
  if      (0 == heurAllocBacklogPriority.compareTo("memorylessRoll", RWCString::ignoreCase)) 
d229 1
a229 1
  else if (0 == heurAllocBacklogPriority.compareTo("immediate", RWCString::ignoreCase)) 
d233 1
a233 1
    cerr << "Warning:  illegal value for parameter heurAllocBacklogPriority ==> "
d302 2
a303 1
        for(int j=0; j<aWithinEq; j++) {
d305 2
a306 2
          eqPartList[j]   = strdup((jthAllocLet.partName()).data());
          eqDemandList[j] = strdup((jthAllocLet.demandName()).data());
d379 1
a379 1
	      if (backlogDependentPtr == NULL) {
d388 3
a390 3
		  cout << "About to fail an assert ...\n";
		  cout << "currAllocLet:" << currAllocLet.traceString() << "\n";
		  cout << "baclkogDependentAlloclet:" << backlogDependentPtr->traceString() << endl;
d413 2
a414 2
				     currAllocLet.partName(), 
				     currAllocLet.demandName(), 
d492 1
a492 1
    outFile_.open(traceFileName_, ios::out, 0666);
d494 1
a494 1
      cerr << "Unable to open File for output:  Trace File: "
d503 1
a503 1
  RWCString heurAllocSortStrategy = setOfParameters.getString("heurAllocSortStrategy");
d505 1
a505 1
  cout << "Executing (Heur Allocation) implosion engine using ("
d508 1
a508 1
       << endl;    
d520 1
a520 1
  cout << "     ... (debug mode) ... Writing the (heurAlloc) wit data file ..." << endl;                      
d542 1
a542 1
  cout << "     ... (debug mode) ... Writing the (heurAlloc) wit data file ..." << endl;                      
d586 1
a586 1
  RWCString heurAllocMinsSortStrategy = setOfParameters.getString("heurAllocMinsSortStrategy");
d595 1
a595 1
    cout << "     ... allocating to mins using (heurAlloc) scheme and ("
d598 1
a598 1
	 << endl;    
d640 1
a640 1
  cout << "     ... allocating to Above Mins using (heurAlloc) scheme and ("
d643 1
a643 1
       << endl;    
d697 1
a697 1
    RWCString heurAllocFeatSortStrategy = setOfParameters.getString("heurAllocFeatSortStrategy");
d704 1
a704 1
    cout << "     ... allocating to Standalone Features using (heurAlloc) scheme and ("
d707 1
a707 1
	 << endl;    
d756 1
a756 1
  RWBoolean doPegging = setOfParameters.getBool("doPegging");
d797 1
a797 1
  RWCString heurAllocBacklogPriority = setOfParameters.getString("heurAllocBacklogPriority");
d800 1
a800 1
  if  (0 == heurAllocBacklogPriority.compareTo("memorylessRoll", RWCString::ignoreCase)) 
d802 1
a802 1
  else if (0 == heurAllocBacklogPriority.compareTo("immediate", RWCString::ignoreCase)) 
d806 1
a806 1
    cerr << "Warning:  illegal value for parameter heurAllocBacklogPriority ==> "
d815 1
a815 1
  cout << "     ... testing priorities for non-increasing values" << endl;
d824 2
a825 1
  for(int i=0; i<nParts; i++){
d830 2
a831 1
    for(int j=0; j<nDemands; j++){
d839 2
a840 1
      for (int t=0; t<nPeriods; t++)   {
d842 1
a842 1
	  cout << "Warning: priority vector is increasing ... \n"
d845 1
a845 1
	       << "period: " << t << endl;
d898 2
a899 1
  for(int i=0; i<nParts; i++){
d904 2
a905 1
    for(int j=0; j<nDemands; j++){
d922 2
a923 1
      for (int t=0; t<nPeriods; t++)   {
d938 1
a938 1
  LgFrSceAllocLet * dependeeAllocLet = NULL;
d946 2
a947 1
    for(int j=0; j<nDemands; j++){
d965 2
a966 2
      // reset the dependee ptr to NULL
      dependeeAllocLet = NULL;
d970 2
a971 1
      for (int t=0; t<nPeriods; t++) {
d983 1
a983 1
	  if (dependeeAllocLet != NULL) {
d999 1
a999 1
      LgFrSceDemandAppData * demandAppDataPtr = NULL ;
d1002 1
a1002 1
      if ( demandAppDataPtr == NULL ) {
d1067 2
a1068 1
  for(int i=0; i<nParts; i++){
d1079 2
a1080 1
    for(int j=0; j<nDemands; j++){
d1091 2
a1092 1
      for (int t=0; t<nPeriods; t++)   {
d1124 2
a1125 1
    for(int j=0; j<nDemands; j++){
d1128 1
a1128 1
      LgFrSceAllocLet * dependeeAllocLet = NULL;
d1138 2
a1139 1
      for (int t=0; t<nPeriods; t++)   {
d1151 1
a1151 1
	  if (dependeeAllocLet != NULL) {
d1189 1
a1189 1
  cout << "     ... executing  setPureOptionDemandVols..." << endl;  
d1203 2
a1204 1
  for (int t=0; t<nPeriods; t++)
d1208 1
a1208 1
  RWCString featureRatioPegMethod = setOfParameters.getString("featureRatioPegMethod");
d1213 5
a1217 4
  for ( int o=0; o<nOperations; o++ ) {
    RWCString fullWitGeoPlannerDemandOperation(operationList[o]);
    RWCString plannerTopLevelPart;
    RWCString geo;
d1227 2
a1228 1
    for (int j=0; j<nBoms; j++)  {
d1232 1
a1232 1
      witGetBomEntryConsumedPart(theWitRun_, fullWitGeoPlannerDemandOperation, j, &fullWitFeaturePart);
d1240 1
a1240 1
      RWCString gg, pp, ppdf, fp;
d1255 1
a1255 1
	RWCString featureDemandName = mpHelper_->custChoiceFeatureDemandName(fullWitGeoPlannerDemandOperation );
d1258 1
a1258 1
	witGetDemandDemandVol( theWitRun_, fullWitGeoPlannerDemandOperation, geo, &gpdDemVol);
d1260 1
a1260 1
	witGetBomEntryUsageRate(theWitRun_, fullWitGeoPlannerDemandOperation, j, &usageRate);	      
d1265 1
a1265 1
	witGetDemandDemandVol(theWitRun_, fullWitFeaturePart, featureDemandName, &featDemandVol);
d1271 2
a1272 1
	for ( int t=0; t<nPeriods; t++)
d1275 1
a1275 1
	witSetDemandDemandVol(theWitRun_, fullWitFeaturePart, featureDemandName, featDemandVol);
d1294 2
a1295 1
      for (int j=0; j<nDemands; j++) {
d1313 1
a1313 1
LgFrSceAllocationEngineMgr::dumpaVec(RWCString aMessage, LgFrTimeVecFloat & theVec)
d1319 5
a1323 4
  cout << aMessage << ": [";
  for (int t=0; t<nPeriods-1; t++)
    cout << theVec[t] << ",";
  cout << theVec[t] << "]" << endl;
d1327 1
a1327 1
LgFrSceAllocationEngineMgr::dumpaVec(RWCString aMessage, float * theVec)
d1333 5
a1337 4
  cout << aMessage << ": [";
  for (int t=0; t<nPeriods-1; t++)
    cout << theVec[t] << ",";
  cout << theVec[t] << "]" << endl;
d1357 1
a1357 1
  cout << "     ... executing  setPureOptionBuildAllocVols..." << endl;  
d1372 1
a1372 1
  RWCString featureRatioPegMethod = setOfParameters.getString("featureRatioPegMethod");
d1377 5
a1381 4
  for ( int o=0; o<nOperations; o++ ) {
    RWCString fullWitGeoPlannerDemandOperation(operationList[o]);
    RWCString plannerTopLevelPart;
    RWCString geo;
d1391 2
a1392 1
    for (int j=0; j<nBoms; j++)  {
d1396 1
a1396 1
      witGetBomEntryConsumedPart(theWitRun_, fullWitGeoPlannerDemandOperation, j, &fullWitFeaturePart);
d1404 1
a1404 1
      RWCString gg, pp, ppdf, fp;
d1413 1
a1413 1
	RWCString featureDemandName = 
d1417 1
a1417 1
	witGetDemandDemandVol( theWitRun_, fullWitGeoPlannerDemandOperation, geo, &gpdDemVol);
d1419 1
a1419 1
	witGetOperationExecVol( theWitRun_, fullWitGeoPlannerDemandOperation, &gpdExecVol);
d1421 1
a1421 1
	witGetBomEntryUsageRate(theWitRun_, fullWitGeoPlannerDemandOperation, j, &usageRate);	      
d1435 2
a1436 2
	cout << "\n\n******\nGPD:" << fullWitGeoPlannerDemandOperation << endl;
	cout << "CC Feature:" << fullWitFeaturePart << endl;
d1449 2
a1450 1
	  for ( int t=0; t<nPeriods; t++)
d1473 2
a1474 1
	  for (int t=0; t<nPeriods; t++) {
d1480 2
a1481 1
	    for (int t2=t+1; t2<nPeriods; t2++) {
d1515 2
a1516 1
	  for (int t=0; t<nPeriods; t++) {
d1520 2
a1521 1
	    for (int t2=0; t2<t; t2++) {
d1543 1
a1543 1
		cout << "Big Mess of an error ... look here!!!" << endl;
d1571 2
a1572 1
	for ( int t=0; t<nPeriods; t++) {
d1635 1
a1635 1
	cout << "... rolled negatives  forward of secondPassFeatureDemandVol\n";
d1642 1
a1642 1
	    cout << "Internal SCE Code Alert: SCE00645AH.  Please notify the SCE Development Team.\n";
d1646 1
a1646 1
	  cout << "... but had a negative in pd 0 so we flatten it.\n";
d1676 1
a1676 1
	  cout << "... just adjusted for spfd exceeding gpdExecVol.\n";
d1689 1
a1689 1
	  cout << "... just applied non-unit usageRate\n";
d1697 1
a1697 1
	cout << "****** \n\n";
d1706 1
a1706 1
	  cout << "\n\n CC Feature: " << fullWitFeaturePart;
d1708 1
a1708 1
	  cout << "\n areRatiosConstant: " << areRatiosConstant;
d1710 4
a1713 3
	  cout << "\n gpdDemVol: ";
	  for (int tdbg=0; tdbg<nPeriods; tdbg++) {
	    cout << gpdDemVol[tdbg] << ",";
d1716 1
a1716 1
	  cout << "\n gpdExecVol: ";
d1718 1
a1718 1
	    cout << gpdExecVol[tdbg] << ",";
d1721 1
a1721 1
	  cout << "\n featRatio: ";
d1723 1
a1723 1
	    cout << featRatio[tdbg] << ",";
d1726 1
a1726 1
	  cout << "\n featureDemandPreUsageRate: ";
d1728 1
a1728 1
	    cout << featureDemandPreUsageRate[tdbg] << ",";
d1731 1
a1731 1
	  cout << "\n featuresShippedPreUsageRate: ";
d1733 1
a1733 1
	    cout << featuresShippedPreUsageRate[tdbg] << ",";
d1736 1
a1736 1
	  cout << "\n supplyVolCCfeaturePart: ";
d1738 1
a1738 1
	    cout << supplyVolCCfeaturePart[tdbg] << ",";
d1741 1
a1741 1
	  cout << "\n execVolCCfeaturePart: ";
d1743 1
a1743 1
	    cout << execVolCCfeaturePart[tdbg] << ",";
d1746 1
a1746 1
	  cout << "\n secondPassFeatureDemandVol: ";
d1748 1
a1748 1
	    cout << secondPassFeatureDemandVol[tdbg] << ",";
d1752 1
a1752 1
	  witGetBomEntryNSubsBomEntries(theWitRun_, fullWitGeoPlannerDemandOperation, j, &nSubs);
d1756 1
a1756 1
	    witGetSubsBomEntrySubVol(theWitRun_, fullWitGeoPlannerDemandOperation, j, 0, &subVol);
d1758 1
a1758 1
	    cout << "\n nullSubVol: ";
d1760 1
a1760 1
	      cout << subVol[tdbg] << ",";
d1766 1
a1766 1
	  cout << "\n";
d1776 1
a1776 1
	witGetDemandAppData( theWitRun_, fullWitFeaturePart, featureDemandName,
d1778 1
a1778 1
	if ( dmdAppDataPtr == NULL ) {
d1780 2
a1781 2
	  assert ( dmdAppDataPtr != NULL );
	  witSetDemandAppData( theWitRun_, fullWitFeaturePart, featureDemandName,  
d1815 1
a1815 1
      witGetBomEntryNSubsBomEntries(theWitRun_, fullWitGeoPlannerDemandOperation, j, &nSubs);
d1822 1
a1822 1
	witGetSubsBomEntryConsumedPart(theWitRun_, fullWitGeoPlannerDemandOperation, j, 0, &nullSub);
d1833 1
a1833 1
	RWCString pppdf;
d1857 1
a1857 1
	RWCString featureDemandName = mpHelper_->pureOptionBuildDemandName(fullWitGeoPlannerDemandOperation );
d1884 1
a1884 1
	witGetSubsBomEntrySubVol(theWitRun_, fullWitGeoPlannerDemandOperation, j, 0, &subVol);
d1896 1
a1896 1
	  witGetBomEntryUsageRate(theWitRun_, fullWitGeoPlannerDemandOperation, j, &usageRatio);
d1900 1
a1900 1
	  //	      witGetBomEntryImpactPeriod(theWitRun_, fullWitGeoPlannerDemandOperation, j, &impactPeriod);
d1906 2
a1907 1
	  for (int t=0; t<nPeriods; t++) {
d1923 1
a1923 1
	witGetDemandAppData( theWitRun_, fullWitFeaturePart, featureDemandName,
d1925 1
a1925 1
	if ( dmdAppDataPtr == NULL ) {
d1927 2
a1928 2
	  assert ( dmdAppDataPtr != NULL );
	  witSetDemandAppData( theWitRun_, fullWitFeaturePart, featureDemandName,  
d1967 1
a1967 1
  cout << "     ... executing initializeAllocDataFeaturePass ..." << endl;  
d1986 2
a1987 1
  for(int i=0; i<nParts; i++){
d2003 1
a2003 1
    if ( dmdAppDataPtr == NULL ) {
d2010 2
a2011 1
    for (int t=0; t<nPeriods; t++) {
d2029 1
a2029 1
  LgFrSceAllocLet * dependeeAllocLet = NULL;
d2044 2
a2045 2
    // reset the dependee ptr to NULL
    dependeeAllocLet = NULL;
d2060 1
a2060 1
    if ( dmdAppDataPtr == NULL ) {
d2070 2
a2071 1
    for (int t=0; t<nPeriods; t++) {
d2083 1
a2083 1
	if (dependeeAllocLet != NULL) {
d2140 2
a2141 1
  for (int t=0; t<nPeriods; t++)
d2148 2
a2149 1
 for ( int ts=0; ts<nPeriods; ts++) {
d2193 2
a2194 1
  for(int t=0; t<nPeriods; t++) {
d2222 3
a2224 2
  assert (loss!=NULL);
  for (int t=0; t<nPeriods; t++)
d2228 1
a2228 1
  assert (cumLostVec!=NULL);
d2335 1
a2335 1
LgFrSceAllocationEngineMgr::sortID(RWCString & sortStrategyString)
d2337 1
a2337 1
  if (0 == sortStrategyString.compareTo("truePriority", RWCString::ignoreCase))
d2339 1
a2339 1
  else if (0 == sortStrategyString.compareTo("PDS", RWCString::ignoreCase))
d2341 1
a2341 1
  else if (0 == sortStrategyString.compareTo("PSD", RWCString::ignoreCase))
d2343 1
a2343 1
  else if (0 == sortStrategyString.compareTo("SPD", RWCString::ignoreCase))
d2345 1
a2345 1
  else if (0 == sortStrategyString.compareTo("SDP", RWCString::ignoreCase))
d2347 1
a2347 1
  else if (0 == sortStrategyString.compareTo("DSP", RWCString::ignoreCase))
d2349 1
a2349 1
  else if (0 == sortStrategyString.compareTo("DPS", RWCString::ignoreCase))
d2353 1
a2353 1
    cerr << "Error:  illegal sortStrrategy parameter ==> "
d2399 1
a2399 1
LgFrSceAllocationEngineMgr::traceFileName(RWCString & traceFile)
d2406 1
a2406 1
LgFrSceAllocationEngineMgr::setEngine(const RWCString & engine)
d2412 1
a2412 1
RWCString 
d2421 3
a2423 3
  theWitRun_ (NULL),
  theCal_(NULL),
  mpHelper_(NULL),
d2425 4
a2428 4
  vecAllocLetList_(NULL),
  allocLetList_(NULL),
  sortStrategy_(NULL),
  bklgStrategy_(NULL),
d2445 1
a2445 1
                                         const RWCString & engine)
d2452 4
a2455 4
  vecAllocLetList_(NULL),
  allocLetList_(NULL),
  sortStrategy_(NULL),
  bklgStrategy_(NULL),
@


1.11.2.1
log
@Roguewave is gone
@
text
@a0 6

// RW2STL - inserted:
#include <string>
#include <ostream.h>
#include <scenario/src/RWToSTLHelpers.h>
// End of RW2STL - inserted includes.
d51 1
a51 1
  std::string heurAllocBacklogPriority = setOfParameters.getString("heurAllocBacklogPriority");
d54 1
a54 1
  if      (0 == sce::compareStringsCaseIns( heurAllocBacklogPriority, "memorylessRoll" )) 
d56 1
a56 1
  else if (0 == sce::compareStringsCaseIns( heurAllocBacklogPriority, "immediate" )) 
d73 2
a74 2
                    myAllocLet.partName().c_str(),
                    myAllocLet.demandName().c_str(),
d102 1
a102 1
      std::string p, g;
d104 1
a104 1
      std::string p0 = partList[0];
d137 1
a137 1
	if (backlogDependentPtr != 0) {
d168 2
a169 2
			       myAllocLet.partName().c_str(), 
			       myAllocLet.demandName().c_str(), 
d180 1
a180 1
      // do this if useRolloverBacklogPolicy == false
d218 1
a218 1
  std::string heurAllocBacklogPriority = setOfParameters.getString("heurAllocBacklogPriority");
d221 1
a221 1
  if      (0 == sce::compareStringsCaseIns( heurAllocBacklogPriority, "memorylessRoll" )) 
d223 1
a223 1
  else if (0 == sce::compareStringsCaseIns( heurAllocBacklogPriority, "immediate" )) 
d296 1
a296 2
        int j = 0; // Pulled out of the for below by RW2STL
        for(j=0; j<aWithinEq; j++) {
d298 2
a299 2
          eqPartList[j]   = strdup((jthAllocLet.partName()).c_str());
          eqDemandList[j] = strdup((jthAllocLet.demandName()).c_str());
d372 1
a372 1
	      if (backlogDependentPtr == 0) {
d406 2
a407 2
				     currAllocLet.partName().c_str(), 
				     currAllocLet.demandName().c_str(), 
d485 1
a485 1
      outFile_.open(traceFileName_.c_str() );//, 0666);
d496 1
a496 1
  std::string heurAllocSortStrategy = setOfParameters.getString("heurAllocSortStrategy");
d579 1
a579 1
  std::string heurAllocMinsSortStrategy = setOfParameters.getString("heurAllocMinsSortStrategy");
d690 1
a690 1
    std::string heurAllocFeatSortStrategy = setOfParameters.getString("heurAllocFeatSortStrategy");
d749 1
a749 1
  bool doPegging = setOfParameters.getBool("doPegging");
d790 1
a790 1
  std::string heurAllocBacklogPriority = setOfParameters.getString("heurAllocBacklogPriority");
d793 1
a793 1
  if  (0 == sce::compareStringsCaseIns( heurAllocBacklogPriority, "memorylessRoll" )) 
d795 1
a795 1
  else if (0 == sce::compareStringsCaseIns( heurAllocBacklogPriority, "immediate" )) 
d817 1
a817 2
  int i = 0; // Pulled out of the for below by RW2STL
  for(i=0; i<nParts; i++){
d822 1
a822 2
    int j = 0; // Pulled out of the for below by RW2STL
    for(j=0; j<nDemands; j++){
d830 1
a830 2
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods; t++)   {
d888 1
a888 2
  int i = 0; // Pulled out of the for below by RW2STL
  for(i=0; i<nParts; i++){
d893 1
a893 2
    int j = 0; // Pulled out of the for below by RW2STL
    for(j=0; j<nDemands; j++){
d910 1
a910 2
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods; t++)   {
d925 1
a925 1
  LgFrSceAllocLet * dependeeAllocLet = 0;
d933 1
a933 2
    int j = 0; // Pulled out of the for below by RW2STL
    for(j=0; j<nDemands; j++){
d951 2
a952 2
      // reset the dependee ptr to 0
      dependeeAllocLet = 0;
d956 1
a956 2
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods; t++) {
d968 1
a968 1
	  if (dependeeAllocLet != 0) {
d984 1
a984 1
      LgFrSceDemandAppData * demandAppDataPtr = 0 ;
d987 1
a987 1
      if ( demandAppDataPtr == 0 ) {
d1052 1
a1052 2
  int i = 0; // Pulled out of the for below by RW2STL
  for(i=0; i<nParts; i++){
d1063 1
a1063 2
    int j = 0; // Pulled out of the for below by RW2STL
    for(j=0; j<nDemands; j++){
d1074 1
a1074 2
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods; t++)   {
d1106 1
a1106 2
    int j = 0; // Pulled out of the for below by RW2STL
    for(j=0; j<nDemands; j++){
d1109 1
a1109 1
      LgFrSceAllocLet * dependeeAllocLet = 0;
d1119 1
a1119 2
      int t = 0; // Pulled out of the for below by RW2STL
      for (t=0; t<nPeriods; t++)   {
d1131 1
a1131 1
	  if (dependeeAllocLet != 0) {
d1183 1
a1183 2
  int t = 0; // Pulled out of the for below by RW2STL
  for (t=0; t<nPeriods; t++)
d1187 1
a1187 1
  std::string featureRatioPegMethod = setOfParameters.getString("featureRatioPegMethod");
d1192 4
a1195 5
  int o = 0; // Pulled out of the for below by RW2STL
  for ( o=0; o<nOperations; o++ ) {
    std::string fullWitGeoPlannerDemandOperation(operationList[o]);
    std::string plannerTopLevelPart;
    std::string geo;
d1205 1
a1205 2
    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<nBoms; j++)  {
d1209 1
a1209 1
      witGetBomEntryConsumedPart(theWitRun_, fullWitGeoPlannerDemandOperation.c_str(), j, &fullWitFeaturePart);
d1217 1
a1217 1
      std::string gg, pp, ppdf, fp;
d1232 1
a1232 1
	std::string featureDemandName = mpHelper_->custChoiceFeatureDemandName(fullWitGeoPlannerDemandOperation );
d1235 1
a1235 1
	witGetDemandDemandVol( theWitRun_, fullWitGeoPlannerDemandOperation.c_str(), geo.c_str(), &gpdDemVol);
d1237 1
a1237 1
	witGetBomEntryUsageRate(theWitRun_, fullWitGeoPlannerDemandOperation.c_str(), j, &usageRate);	      
d1242 1
a1242 1
	witGetDemandDemandVol(theWitRun_, fullWitFeaturePart, featureDemandName.c_str(), &featDemandVol);
d1248 1
a1248 2
	int t = 0; // Pulled out of the for below by RW2STL
	for ( t=0; t<nPeriods; t++)
d1251 1
a1251 1
	witSetDemandDemandVol(theWitRun_, fullWitFeaturePart, featureDemandName.c_str(), featDemandVol);
d1270 1
a1270 2
      int j = 0; // Pulled out of the for below by RW2STL
      for (j=0; j<nDemands; j++) {
d1288 1
a1288 1
LgFrSceAllocationEngineMgr::dumpaVec(std::string aMessage, LgFrTimeVecFloat & theVec)
d1295 1
a1295 2
  int t = 0; // Pulled out of the for below by RW2STL
  for (t=0; t<nPeriods-1; t++)
d1301 1
a1301 1
LgFrSceAllocationEngineMgr::dumpaVec(std::string aMessage, float * theVec)
d1308 1
a1308 2
  int t = 0; // Pulled out of the for below by RW2STL
  for (t=0; t<nPeriods-1; t++)
d1345 1
a1345 1
  std::string featureRatioPegMethod = setOfParameters.getString("featureRatioPegMethod");
d1350 4
a1353 5
  int o = 0; // Pulled out of the for below by RW2STL
  for ( o=0; o<nOperations; o++ ) {
    std::string fullWitGeoPlannerDemandOperation(operationList[o]);
    std::string plannerTopLevelPart;
    std::string geo;
d1363 1
a1363 2
    int j = 0; // Pulled out of the for below by RW2STL
    for (j=0; j<nBoms; j++)  {
d1367 1
a1367 1
      witGetBomEntryConsumedPart(theWitRun_, fullWitGeoPlannerDemandOperation.c_str(), j, &fullWitFeaturePart);
d1375 1
a1375 1
      std::string gg, pp, ppdf, fp;
d1384 1
a1384 1
	std::string featureDemandName = 
d1388 1
a1388 1
	witGetDemandDemandVol( theWitRun_, fullWitGeoPlannerDemandOperation.c_str(), geo.c_str(), &gpdDemVol);
d1390 1
a1390 1
	witGetOperationExecVol( theWitRun_, fullWitGeoPlannerDemandOperation.c_str(), &gpdExecVol);
d1392 1
a1392 1
	witGetBomEntryUsageRate(theWitRun_, fullWitGeoPlannerDemandOperation.c_str(), j, &usageRate);	      
d1420 1
a1420 2
	  int t = 0; // Pulled out of the for below by RW2STL
	  for ( t=0; t<nPeriods; t++)
d1443 1
a1443 2
	  int t = 0; // Pulled out of the for below by RW2STL
	  for (t=0; t<nPeriods; t++) {
d1449 1
a1449 2
	    int t2 = 0; // Pulled out of the for below by RW2STL
	    for (t2=t+1; t2<nPeriods; t2++) {
d1483 1
a1483 2
	  int t = 0; // Pulled out of the for below by RW2STL
	  for (t=0; t<nPeriods; t++) {
d1487 1
a1487 2
	    int t2 = 0; // Pulled out of the for below by RW2STL
	    for (t2=0; t2<t; t2++) {
d1537 1
a1537 2
	int t = 0; // Pulled out of the for below by RW2STL
	for ( t=0; t<nPeriods; t++) {
d1676 1
a1676 2
	  int tdbg = 0; // Pulled out of the for below by RW2STL
	  for (tdbg=0; tdbg<nPeriods; tdbg++) {
d1716 1
a1716 1
	  witGetBomEntryNSubsBomEntries(theWitRun_, fullWitGeoPlannerDemandOperation.c_str(), j, &nSubs);
d1720 1
a1720 1
	    witGetSubsBomEntrySubVol(theWitRun_, fullWitGeoPlannerDemandOperation.c_str(), j, 0, &subVol);
d1740 1
a1740 1
	witGetDemandAppData( theWitRun_, fullWitFeaturePart, featureDemandName.c_str(),
d1742 1
a1742 1
	if ( dmdAppDataPtr == 0 ) {
d1744 2
a1745 2
	  assert ( dmdAppDataPtr != 0 );
	  witSetDemandAppData( theWitRun_, fullWitFeaturePart, featureDemandName.c_str(),  
d1779 1
a1779 1
      witGetBomEntryNSubsBomEntries(theWitRun_, fullWitGeoPlannerDemandOperation.c_str(), j, &nSubs);
d1786 1
a1786 1
	witGetSubsBomEntryConsumedPart(theWitRun_, fullWitGeoPlannerDemandOperation.c_str(), j, 0, &nullSub);
d1797 1
a1797 1
	std::string pppdf;
d1821 1
a1821 1
	std::string featureDemandName = mpHelper_->pureOptionBuildDemandName(fullWitGeoPlannerDemandOperation );
d1848 1
a1848 1
	witGetSubsBomEntrySubVol(theWitRun_, fullWitGeoPlannerDemandOperation.c_str(), j, 0, &subVol);
d1860 1
a1860 1
	  witGetBomEntryUsageRate(theWitRun_, fullWitGeoPlannerDemandOperation.c_str(), j, &usageRatio);
d1864 1
a1864 1
	  //	      witGetBomEntryImpactPeriod(theWitRun_, fullWitGeoPlannerDemandOperation.c_str(), j, &impactPeriod);
d1870 1
a1870 2
	  int t = 0; // Pulled out of the for below by RW2STL
	  for (t=0; t<nPeriods; t++) {
d1886 1
a1886 1
	witGetDemandAppData( theWitRun_, fullWitFeaturePart, featureDemandName.c_str(),
d1888 1
a1888 1
	if ( dmdAppDataPtr == 0 ) {
d1890 2
a1891 2
	  assert ( dmdAppDataPtr != 0 );
	  witSetDemandAppData( theWitRun_, fullWitFeaturePart, featureDemandName.c_str(),  
d1949 1
a1949 2
  int i = 0; // Pulled out of the for below by RW2STL
  for(i=0; i<nParts; i++){
d1965 1
a1965 1
    if ( dmdAppDataPtr == 0 ) {
d1972 1
a1972 2
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nPeriods; t++) {
d1990 1
a1990 1
  LgFrSceAllocLet * dependeeAllocLet = 0;
d2005 2
a2006 2
    // reset the dependee ptr to 0
    dependeeAllocLet = 0;
d2021 1
a2021 1
    if ( dmdAppDataPtr == 0 ) {
d2031 1
a2031 2
    int t = 0; // Pulled out of the for below by RW2STL
    for (t=0; t<nPeriods; t++) {
d2043 1
a2043 1
	if (dependeeAllocLet != 0) {
d2100 1
a2100 2
  int t = 0; // Pulled out of the for below by RW2STL
  for (t=0; t<nPeriods; t++)
d2107 1
a2107 2
 int ts = 0; // Pulled out of the for below by RW2STL
 for ( ts=0; ts<nPeriods; ts++) {
d2151 1
a2151 2
  int t = 0; // Pulled out of the for below by RW2STL
  for(t=0; t<nPeriods; t++) {
d2179 2
a2180 3
  assert (loss!=0);
  int t = 0; // Pulled out of the for below by RW2STL
  for (t=0; t<nPeriods; t++)
d2184 1
a2184 1
  assert (cumLostVec!=0);
d2291 1
a2291 1
LgFrSceAllocationEngineMgr::sortID(std::string & sortStrategyString)
d2293 1
a2293 1
  if (0 == sce::compareStringsCaseIns( sortStrategyString, "truePriority" ))
d2295 1
a2295 1
  else if (0 == sce::compareStringsCaseIns( sortStrategyString, "PDS" ))
d2297 1
a2297 1
  else if (0 == sce::compareStringsCaseIns( sortStrategyString, "PSD" ))
d2299 1
a2299 1
  else if (0 == sce::compareStringsCaseIns( sortStrategyString, "SPD" ))
d2301 1
a2301 1
  else if (0 == sce::compareStringsCaseIns( sortStrategyString, "SDP" ))
d2303 1
a2303 1
  else if (0 == sce::compareStringsCaseIns( sortStrategyString, "DSP" ))
d2305 1
a2305 1
  else if (0 == sce::compareStringsCaseIns( sortStrategyString, "DPS" ))
d2355 1
a2355 1
LgFrSceAllocationEngineMgr::traceFileName(std::string & traceFile)
d2362 1
a2362 1
LgFrSceAllocationEngineMgr::setEngine(const std::string & engine)
d2368 1
a2368 1
std::string 
d2377 3
a2379 3
  theWitRun_ (0),
  theCal_(0),
  mpHelper_(0),
d2381 4
a2384 4
  vecAllocLetList_(0),
  allocLetList_(0),
  sortStrategy_(0),
  bklgStrategy_(0),
d2401 1
a2401 1
                                         const std::string & engine)
d2408 4
a2411 4
  vecAllocLetList_(0),
  allocLetList_(0),
  sortStrategy_(0),
  bklgStrategy_(0),
@


1.11.2.2
log
@Went all the way to std::cout
@
text
@d4 1
a4 1
#include <iostream>
d66 1
a66 1
    std::cerr << "Warning:  illegal value for parameter heurAllocBacklogPriority ==> "
d233 1
a233 1
    std::cerr << "Warning:  illegal value for parameter heurAllocBacklogPriority ==> "
d388 3
a390 3
		  std::cout << "About to fail an assert ...\n";
		  std::cout << "currAllocLet:" << currAllocLet.traceString() << "\n";
		  std::cout << "baclkogDependentAlloclet:" << backlogDependentPtr->traceString() << std::endl;
d494 1
a494 1
      std::cerr << "Unable to open File for output:  Trace File: "
d505 1
a505 1
  std::cout << "Executing (Heur Allocation) implosion engine using ("
d508 1
a508 1
       << std::endl;    
d520 1
a520 1
  std::cout << "     ... (debug mode) ... Writing the (heurAlloc) wit data file ..." << std::endl;                      
d542 1
a542 1
  std::cout << "     ... (debug mode) ... Writing the (heurAlloc) wit data file ..." << std::endl;                      
d595 1
a595 1
    std::cout << "     ... allocating to mins using (heurAlloc) scheme and ("
d598 1
a598 1
	 << std::endl;    
d640 1
a640 1
  std::cout << "     ... allocating to Above Mins using (heurAlloc) scheme and ("
d643 1
a643 1
       << std::endl;    
d704 1
a704 1
    std::cout << "     ... allocating to Standalone Features using (heurAlloc) scheme and ("
d707 1
a707 1
	 << std::endl;    
d806 1
a806 1
    std::cerr << "Warning:  illegal value for parameter heurAllocBacklogPriority ==> "
d815 1
a815 1
  std::cout << "     ... testing priorities for non-increasing values" << std::endl;
d842 1
a842 1
	  std::cout << "Warning: priority vector is increasing ... \n"
d845 1
a845 1
	       << "period: " << t << std::endl;
d1189 1
a1189 1
  std::cout << "     ... executing  setPureOptionDemandVols..." << std::endl;  
d1319 1
a1319 1
  std::cout << aMessage << ": [";
d1322 2
a1323 2
    std::cout << theVec[t] << ",";
  std::cout << theVec[t] << "]" << std::endl;
d1333 1
a1333 1
  std::cout << aMessage << ": [";
d1336 2
a1337 2
    std::cout << theVec[t] << ",";
  std::cout << theVec[t] << "]" << std::endl;
d1357 1
a1357 1
  std::cout << "     ... executing  setPureOptionBuildAllocVols..." << std::endl;  
d1435 2
a1436 2
	std::cout << "\n\n******\nGPD:" << fullWitGeoPlannerDemandOperation << std::endl;
	std::cout << "CC Feature:" << fullWitFeaturePart << std::endl;
d1543 1
a1543 1
		std::cout << "Big Mess of an error ... look here!!!" << std::endl;
d1635 1
a1635 1
	std::cout << "... rolled negatives  forward of secondPassFeatureDemandVol\n";
d1642 1
a1642 1
	    std::cout << "Internal SCE Code Alert: SCE00645AH.  Please notify the SCE Development Team.\n";
d1646 1
a1646 1
	  std::cout << "... but had a negative in pd 0 so we flatten it.\n";
d1676 1
a1676 1
	  std::cout << "... just adjusted for spfd exceeding gpdExecVol.\n";
d1689 1
a1689 1
	  std::cout << "... just applied non-unit usageRate\n";
d1697 1
a1697 1
	std::cout << "****** \n\n";
d1706 1
a1706 1
	  std::cout << "\n\n CC Feature: " << fullWitFeaturePart;
d1708 1
a1708 1
	  std::cout << "\n areRatiosConstant: " << areRatiosConstant;
d1710 1
a1710 1
	  std::cout << "\n gpdDemVol: ";
d1713 1
a1713 1
	    std::cout << gpdDemVol[tdbg] << ",";
d1716 1
a1716 1
	  std::cout << "\n gpdExecVol: ";
d1718 1
a1718 1
	    std::cout << gpdExecVol[tdbg] << ",";
d1721 1
a1721 1
	  std::cout << "\n featRatio: ";
d1723 1
a1723 1
	    std::cout << featRatio[tdbg] << ",";
d1726 1
a1726 1
	  std::cout << "\n featureDemandPreUsageRate: ";
d1728 1
a1728 1
	    std::cout << featureDemandPreUsageRate[tdbg] << ",";
d1731 1
a1731 1
	  std::cout << "\n featuresShippedPreUsageRate: ";
d1733 1
a1733 1
	    std::cout << featuresShippedPreUsageRate[tdbg] << ",";
d1736 1
a1736 1
	  std::cout << "\n supplyVolCCfeaturePart: ";
d1738 1
a1738 1
	    std::cout << supplyVolCCfeaturePart[tdbg] << ",";
d1741 1
a1741 1
	  std::cout << "\n execVolCCfeaturePart: ";
d1743 1
a1743 1
	    std::cout << execVolCCfeaturePart[tdbg] << ",";
d1746 1
a1746 1
	  std::cout << "\n secondPassFeatureDemandVol: ";
d1748 1
a1748 1
	    std::cout << secondPassFeatureDemandVol[tdbg] << ",";
d1758 1
a1758 1
	    std::cout << "\n nullSubVol: ";
d1760 1
a1760 1
	      std::cout << subVol[tdbg] << ",";
d1766 1
a1766 1
	  std::cout << "\n";
d1967 1
a1967 1
  std::cout << "     ... executing initializeAllocDataFeaturePass ..." << std::endl;  
d2353 1
a2353 1
    std::cerr << "Error:  illegal sortStrrategy parameter ==> "
@


1.10
log
@file cleaning ... more pegging ... parameters ...
@
text
@d5 1
@


1.9
log
@moved comments off of ifdef lines
@
text
@d1183 1
a1183 1
    bigMdemandVol[t] = 98765431.;
@


1.8
log
@yet another fix for setPureOptionBuild.
New parameter: shutOffAllLotSizing ... which does just that
@
text
@d95 2
a96 1
#if 0           // TEMPORARY DEBUG
d1554 2
a1555 1
#if 0      // ===> 11/30/2001  	 trying this over ... this doesn't work
@


1.7
log
@commit for 3.103
@
text
@d28 2
a627 7
  //          b) run either witHeurImplode or rolloverImplode depending on
  //             on user's preference.
  //          c) Update the global (output) schedules: ship, prod, subsProd
  //          d) Update minLotSize, supplyVol, and prodVolUB in witRun (prep for next iteration)
  //          e) merge critical list into the global one
  //          NOTE:  c,d,e don't need to be done when using rollover,
  //                 because they're done by rollover itself.
a628 5
  
  // if min demands existed, then the demands are set to the residual "above min" demand
  // if min demands did not exist, then the demand is equal to the orginal demand.
  // For which ever demand, implode with your favorite engine and update.

d780 1
a780 1
  float * demandVol;
d1182 1
a1182 1
    bigMdemandVol[t] = 98765431;
d1283 31
d1401 11
a1433 2


d1436 1
a1436 1
	  // ---- Method 1 ----
a1469 1
	  
a1473 1
	  
a1475 4




d1478 1
a1478 1
	  // ---- Method 2 ----
a1480 1
	  
d1521 4
a1525 1
	    
d1538 1
a1538 2
	    
	    
d1544 10
a1553 1
	    
d1582 62
a1643 2
	    
	    
d1649 7
d1657 4
a1730 11











@


1.6
log
@shortcut bug fix for when CC featureratio's are constant
@
text
@a831 1
      float * cumShipBound, * hardLower, * hardUpper;
d834 1
a834 1
      int prevPrio = INT_MAX;
d839 2
a840 2
        if (prevPrio < priority[t]) {
	  cerr << "Warning: priority vector is increasing ... \n"
@


1.5
log
@premiminary coomit for release 3.11
@
text
@d1322 1
a1322 1

d1362 2
a1363 10
#if 1
	// This method is flawed and is being replaced 

	// Here we process Customer Choice Features
	// demandVol on CC features is
	// (shipVol(GPD) * usageRate * featratio) - execVol(SFO)  (rolled) for timing
	    
	// Multiple BOM entries between the parent and the child could be used to implement
	// different feature rates over time.
	RWCString featureDemandName = mpHelper_->custChoiceFeatureDemandName(fullWitGeoPlannerDemandOperation );
d1374 2
a1375 14
	    
	// THE OLD NEW WAY
	// Based on GPD commits, compute totalFeaturesNeeded
	// (note: this is not the mrp view but the implosion view given that we already
	//  know our machine commits)
	//
	// This is basically the gpdExecVol * featureRatio EXCEPT that if the machine
	// shipped late and the featureRatio changed over time, then we need to tie the
	// gpdExecVol back to the period it was due -- that determines what feature demand 
	// is needed.  
	//
	// To compute, we need to take the gpdExecVol and "tie" it back to the period
	// in which it was due.  Then we can do a straight multiplication against
	// totalFeaturesNeeded = tiedBackGpdExecVol * featRatio
d1377 2
a1378 1
	// Compute ==> tiedBackGpdExecVol 
d1380 56
a1435 12
	for (int t=0; t<nPeriods; t++) {
	  float demExcess = gpdDemVol[t] - tiedBackGpdExecVol[t];
	  // if this period matches, then continue
	  if (demExcess < .001)
	    continue;
	  // otherwise, look for future commits to pull in
	  for (int t2=t+1; t2<nPeriods; t2++) {
	    // if period t2 execVol covers period t delta, then pull it in
	    if (tiedBackGpdExecVol[t2]  >= demExcess) {
	      tiedBackGpdExecVol[t] += demExcess;
	      tiedBackGpdExecVol[t2] -= demExcess;
	      demExcess = 0.0;
a1437 11
	    else {
	      tiedBackGpdExecVol[t] += tiedBackGpdExecVol[t2];
	      demExcess -= tiedBackGpdExecVol[t2];
	      tiedBackGpdExecVol[t2] = 0.0;
	    }
	  }
	  // now if you didn't clear the demand gap, then you're done
	  // since you've (necesarily) exhausted all future commits
	  // So break out of the loop
	  if (demExcess > 0.001) {
	    break;
d1439 8
a1446 10
	}
	// End: Compute ==> tiedBackGpdExecVol 	    


	// now compute the total Features Needed ...
	// featureDemandPreUsageRate is basically the GPD shipVol times the featRatio
	LgFrTimeVecFloat featureDemandPreUsageRate((size_t) nPeriods, 0.0);
	for ( t=0; t<nPeriods; t++)
	  featureDemandPreUsageRate[t] = featRatio[t] * tiedBackGpdExecVol[t];
	    
d1454 18
a1471 9
	// NEW METHOD TO REPLACE THE ABOVE

	// Here we process Customer Choice Features
	// demandVol on CC features is
	// (shipVol(GPD) * usageRate * featratio) - execVol(SFO)  (rolled) for timing
	    
	// Multiple BOM entries between the parent and the child could be used to implement
	// different feature rates over time.
	RWCString featureDemandName = mpHelper_->custChoiceFeatureDemandName(fullWitGeoPlannerDemandOperation );
d1473 1
a1473 34
	float * gpdDemVol;
	witGetDemandDemandVol( theWitRun_, fullWitGeoPlannerDemandOperation, geo, &gpdDemVol);
	float * gpdExecVol;
	witGetOperationExecVol( theWitRun_, fullWitGeoPlannerDemandOperation, &gpdExecVol);
	float usageRate;
	witGetBomEntryUsageRate(theWitRun_, fullWitGeoPlannerDemandOperation, j, &usageRate);	      
	// featRatio is stored in GPD->SFP bom's appData
	LgFrTimeVecFloat featRatio = mpHelper_->custChoiceFeatureRatio(theWitRun_, fullWitFeaturePart);

	    
	// Based on GPD commits, compute totalFeaturesNeeded
	// (note: this is not the mrp view but the implosion view given that we already
	//  know our machine commits)
	//
	// This is basically the gpdExecVol * featureRatio EXCEPT that if the machine
	// shipped late and the featureRatio changed over time, then we need to tie the
	// gpdExecVol back to the period it was due -- that determines what feature demand 
	// is needed.  
	//
	// To compute, we need to take the gpdExecVol and "tie" it back to the period
	// in which it was due.  Then we can do a straight multiplication against
	// totalFeaturesNeeded = tiedBackGpdExecVol * featRatio

	LgFrTimeVecFloat tiedBackGpdExecVol((size_t) nPeriods, gpdExecVol);

	// this is the puppy we'll try to populate
	LgFrTimeVecFloat featureDemandPreUsageRate((size_t) nPeriods, 0.0);

	for (int t=0; t<nPeriods; t++) {

	  float demandFromPeriodT2satisfiedinPeriodT = 0.0;	  
	  // lets loop over the previous periods (t2 form 0 to t-1) and pick up any 
	  // un-"allocated" gpdDemVol.
	  for (int t2=0; t2<t; t2++) {
d1475 1
a1475 2
	      (gpdDemVol[t2] < tiedBackGpdExecVol[t])  ?  gpdDemVol[t2] : 0.0;
	    // use the ratio in place in period t2 figure out how much features are needed in t
d1477 1
a1477 1
	    // decrecment both gpdDemVol and tiedBackGpdExecVol
d1480 12
a1491 16
	  }

	  //  after the loop t2=t and we simply take the min{gpdDemVol[t] and tiedBackGpdExecVol[t]
	  demandFromPeriodT2satisfiedinPeriodT =
	    (gpdDemVol[t2] < tiedBackGpdExecVol[t])  ?  gpdDemVol[t2] : tiedBackGpdExecVol[t];
	  featureDemandPreUsageRate[t] += demandFromPeriodT2satisfiedinPeriodT * featRatio[t2];
	  // decrement both gpdDemVol and tiedBackGpdExecVol
	  gpdDemVol[t2] -= demandFromPeriodT2satisfiedinPeriodT;
	  tiedBackGpdExecVol[t] -= demandFromPeriodT2satisfiedinPeriodT;

	  // now it most cases, tiedBackGpdExecVol[t] should be Zero
	  // if it's not, then roll it
	  if (tiedBackGpdExecVol[t] >0.0001) {
	    if (t == (nPeriods - 1)) {
	      cout << "Big Mess of an error ... look here!!!" << endl;
	      exit(8);
a1492 4
	    
	    // roll it
	    tiedBackGpdExecVol[t+1] += tiedBackGpdExecVol[t];
	    tiedBackGpdExecVol[t] = 0.0;
a1493 1
	}
d1495 3
d1510 1
a1510 1
	for ( t=0; t<nPeriods; t++) {
d1554 85
@


1.4
log
@3.10 pegging capability
@
text
@a32 80
  // ===================================================================
  // goRunAllocation()
  // ===================================================================
void
LgFrSceAllocationEngineMgr::goRunAllocation()
{
    int equitability;

    // tell Wit to get ready
    witStartHeurAlloc(theWitRun_);


    // intitialize allocLetList_
    // This method reads the entire witRun and populates the sorted vector
    // of allocLets.  The list is prepared and completely specified.  
    // However, during the running of heur***Alloc(), new allocLets will
    // be generated and merged into the sort.  These new allocLets generate
    // primarily from backlogged demands.  
    this->initializeAllocData();

    witGetEquitability(theWitRun_, &equitability);

    if  (1 == equitability){
      this->heurIncAlloc();
    }
    else {
      this->heurEqAlloc();
    }

    witFinishHeurAlloc(theWitRun_);


    if (listMax_ > 0) {
       delete [] allocLetList_;
       delete [] vecAllocLetList_;
    }
}



// ==========================================================
// ==========   initializeAllocData() =======================
// ==========================================================
void
LgFrSceAllocationEngineMgr::initializeAllocData()
{
  int   * priority;
  int nPeriods;
  char  *partName, *demandName;
  float * demandVol;
  
    
  witGetNPeriods(theWitRun_, &nPeriods);
  int nParts;
  char  **partList;
  witGetParts(theWitRun_, &nParts, &partList);



  aPointer_ = 0;
  listMax_ = 0;

  // first count how many allocLets we need ==> listMax.
  // NOTE: we only count non-zero demandVols
  for(int i=0; i<nParts; i++){
    partName = partList[i];
    int nDemands;
    char ** dList;
    witGetPartDemands(theWitRun_, partList[i], &nDemands, &dList);
    for(int j=0; j<nDemands; j++){
      witGetDemandDemandVol(theWitRun_, partList[i], dList[j], &demandVol);
      for (int t=0; t<nPeriods; t++)   {
        if (demandVol[t] > 0.0)
                 listMax_++;
         }
      witFree(dList[j]);
      witFree(demandVol);
    }
    witFree(dList);
  }
a35 57
  // Now allocate the vector of allocLet Ptrs
  vecAllocLetList_ = new LgFrSceAllocLet [listMax_];
  // and the vector of allocLets
  allocLetList_ = new LgFrSceAllocLet * [listMax_];
  
  LgFrSceAllocLet * dependeeAllocLet = NULL;

  // now load each allocLet
  for( i=0; i<nParts; i++){
    partName = partList[i];
    int nDemands;
    char ** dList;
    witGetPartDemands(theWitRun_, partName, &nDemands, &dList);
    for(int j=0; j<nDemands; j++){
      // reset the dependee ptr to NULL
      dependeeAllocLet = NULL;
      demandName = dList[j];
      witGetDemandDemandVol(theWitRun_, partName, demandName, &demandVol);
      witGetDemandPriority(theWitRun_, partName, demandName, &priority);
      for (int t=0; t<nPeriods; t++)
        if (demandVol[t] > 0.0) {
          LgFrSceAllocLet & myAllocLet = vecAllocLetList_[aPointer_];
          allocLetList_[aPointer_] = &myAllocLet;
          myAllocLet.partName(partName);
          myAllocLet.demandName(demandName);
          myAllocLet.priority(priority[t]);
          myAllocLet.qtyDemand(demandVol[t]);
          myAllocLet.demandPd(t);
          myAllocLet.shipPd(t);
          myAllocLet.allocated(0);

	  if (dependeeAllocLet != NULL) {
	    // if there's a dependee, then he's waiting to know the current one
	    dependeeAllocLet->backlogDependent(&myAllocLet);
	  }
	  // remember this allocLet
	  dependeeAllocLet = &myAllocLet;
          aPointer_++;
        }
      witFree(dList[j]);
      witFree(demandVol);
      witFree(priority);
    }
    witFree(dList);
    witFree(partList[i]);
  }
  witFree(partList);
  
  assert(aPointer_ == listMax_);
  aPointer_ = 0;

  qsort(allocLetList_, 
        listMax_, 
	sizeof(LgFrSceAllocLet*), 
        sortStrategy_->compareVoidFunc());
}

d227 2
a228 1
    
d260 8
a267 3
        if ( (useRolloverBacklogPolicy || (myAllocLet.demandPd() == nextEquitAlloc.demandPd()))       &&
             myAllocLet.shipPd()   == nextEquitAlloc.shipPd()         &&
             myAllocLet.priority() == nextEquitAlloc.priority() ) {
d374 1
d376 5
a380 3
		if (blogDepShipPd < nextShipPd) {
		  cout << "assert fail" << endl;
		  
a381 1
		assert(blogDepShipPd >= nextShipPd);
d408 4
a411 6


            }                      


            else { 
d419 2
a420 2


d520 10
d778 85
d867 1
a867 1

d2152 11
@


1.3
log
@Fixed the way tiedBackGpdVols were computed in both heurAlloc mode and
normal heuristic (rollover and heuristic).  This was affecting the way
customerChoice was being pegged to the machine.  Old code is still there,
just in case ... it's #ifdef'd out.
@
text
@d10 2
d26 1
a26 1
#define AENGMGR_DUMP_WIT_DATA_FILE
d877 7
d1398 1
a1398 1
#if 0 	    
d1477 1
a1477 1
#if 1
@


1.2
log
@Preliminary Commit for release 3.10 ... still in development!!!!
@
text
@a1541 1
	  
a1542 2


a1549 2


@


1.1
log
@new files for release 3.00
@
text
@d18 1
a18 1
#include <sce/src/itHelpr.h>
a22 1
// #define AENGMGR_DUMP_WIT_DATA_FILE
d24 1
a24 4
// turn this on to get two wit data files generated:
//    one for the first pass
//    another for second pass
// #define DUMP_WIT_DATA_FILE
d26 1
d28 1
a28 113


// Set the sort strategy
void 
LgFrSceAllocationEngineMgr::sortStrategy(LgFrSceSortStrategy * sStrat)
  {
    sortStrategy_ = sStrat;
  }

// Set the bklg strategy
// NOTE: this will eventually become an object
void 
LgFrSceAllocationEngineMgr::backlogStrategy(LgFrSceBacklogStrategy * bStrat)
  {
    bklgStrategy_ = bStrat;
  }


  // set flag to print trace
void   
LgFrSceAllocationEngineMgr::trace(int traceFlag)
  {
    traceFlag_ = traceFlag;
  }

  // set filename for trace
void   
LgFrSceAllocationEngineMgr::traceFileName(RWCString & traceFile)
  {
    traceFileName_ = traceFile;
  }

















// set engine variable
void
LgFrSceAllocationEngineMgr::setEngine(const RWCString & engine)
{
  engine_ = engine;
}

// Get engine variable pointer
RWCString 
LgFrSceAllocationEngineMgr::getEngine()
{
  return engine_;
}
// default constructor
LgFrSceAllocationEngineMgr::LgFrSceAllocationEngineMgr()
  :   
  sceScenSP_(),
  theWitRun_ (NULL),
  theCal_(NULL),
  mpHelper_(NULL),
  engine_(""),
  vecAllocLetList_(NULL),
  allocLetList_(NULL),
  sortStrategy_(NULL),
  bklgStrategy_(NULL),
  traceFlag_(0),
  traceFileName_(""),
  listMax_(0),
  aPointer_(0),
  outFile_()
{
    // all the work is done in initializer
}


// fairly general constructor:
LgFrSceAllocationEngineMgr::LgFrSceAllocationEngineMgr(
                                         LgFrScenarioForSceSmartPointer sceScenSP,
                                         WitRun * const theWitRun, 
                                         LgFrCalendar * theCal,
                                         LgFrMultiPlantHelper * mpHelper,
                                         const RWCString & engine)
  :   
  sceScenSP_(sceScenSP),
  theWitRun_ (theWitRun),
  theCal_(theCal),
  mpHelper_(mpHelper),
  engine_(engine),
  vecAllocLetList_(NULL),
  allocLetList_(NULL),
  sortStrategy_(NULL),
  bklgStrategy_(NULL),
  traceFlag_(0),
  traceFileName_(""),
  listMax_(0),
  aPointer_(0),
  outFile_()
{
  LgFrSceSetOfParameters & setOfParameters =  sceScenSP_->setOfParameters();    

  traceFlag_ = setOfParameters.getBool("printHeurAllocTrace");
  traceFileName_ = setOfParameters.getString("heurAllocTraceFileName");
  
}

d503 5
d597 5
a601 13












// run the truePriority ==> heuralloc 
a619 80
  if ( (sceScenSP_->nStandaloneFeatureArcs() == 0) && 
       (sceScenSP_->nDemandsWithNonZeroMins() == 0)
       )  {
    // if  there are no stand alone features and
    // no minimum demands


    LgFrSceSetOfParameters & setOfParameters =  sceScenSP_->setOfParameters();    

    RWCString heurAllocSortStrategy = setOfParameters.getString("heurAllocSortStrategy");
    
    cout << "Executing (Heur Allocation) implosion engine using ("
	 << heurAllocSortStrategy 
	 << ") sort strategy ..." 
	 << endl;    
    


    witPreprocess(theWitRun_);
    
    // Print the heuristic form of the echo file
    if (setOfParameters.getBool("printHeurEchoFile"))  {
      RWCString echoFileName = setOfParameters.getString("heurEchoFileName");
      sceScenSP_->setWitInformationalMessaging(theWitRun_, SCE_WIT_MESSAGING_ON);
      witDisplayData( theWitRun_, echoFileName);
      if (! setOfParameters.getBool("printWitMsgFile"))   {
	sceScenSP_->setWitInformationalMessaging(theWitRun_, SCE_WIT_MESSAGING_OFF);          
      }
    }
    // Dump the optimization version of the wit.data file
    if (setOfParameters.getBool("printHeurWitDataFile"))  {
      RWCString witDataFileName = setOfParameters.getString("heurWitDataFileName");
      sceScenSP_->setWitInformationalMessaging(theWitRun_, SCE_WIT_MESSAGING_ON);
      witWriteData(theWitRun_, witDataFileName);
      if (! setOfParameters.getBool("printWitMsgFile"))   {
	sceScenSP_->setWitInformationalMessaging(theWitRun_, SCE_WIT_MESSAGING_OFF);          
      }
    }

    int heurAllocSortId = this->sortID(heurAllocSortStrategy);
    LgFrSceSortStrategy * mySortStrategy = new LgFrSceSortStrategy(heurAllocSortId);

    // set allocMgr's strategy.  
    this->sortStrategy(mySortStrategy);


    // set allocMgr's backlog strategy.  
    //   this->backlogStrategy(myBacklogStrategy);


    // Implode !! 
    this->goRunAllocation();

    delete mySortStrategy;



    int printCriticalListFile = setOfParameters.getBool("printCriticalListFile");
    if (printCriticalListFile) 
      theCritList.merge( theWitRun_);
  }
  
  else {
    // you have to do a multiple iterations of implosions for either rollover, min demands,
    // and/or stand alone features. 
    heurImplodeOptFeaturesAndMins( theCritList );
  }
}


// ==================================================================================
// ===========  Multiple Passes of heurAlloc ========================================
// ==========    - use if Mins or Features   ========================================
// ==================================================================================
// purely-optional-feature fix using multiple implosion iterations of either vanilla heuristic
// or the rollover heuristic implosion engine 
void
LgFrSceAllocationEngineMgr::heurImplodeOptFeaturesAndMins(LgFrSceCritList & theCritList)
{

d630 15
a644 8
  // ////////////////////////////////////////////////////////////////////////////
  //                                                                          //
  //        Get a whole heck of a lot of stuff and initialize it              //
  //                                                                          //
  // ////////////////////////////////////////////////////////////////////////////
  
  // get an iterative imploder helper to do the dirty work... 
  LgFrSceIterativeImpHelper  iterativeImpHelper;
d646 1
a646 8
  // get the number of periods
  int nPeriods;
  witGetNPeriods( theWitRun_, &nPeriods ) ;
  
  // get the part list 
  int nParts ;
  char ** partList ;            
  witGetParts( theWitRun_, &nParts, &partList ) ;
a647 4
  // get the operation names so don't have to keep calling API routines
  int  nOperations ;      
  char ** operationList ;    
  witGetOperations( theWitRun_, &nOperations, &operationList );
d649 6
a656 36
  // re-set part and operation indices, this is done primarily for CUSTOMER_CHOICE_FEATURES
  mpHelper_->setAllWitPartIndices(theWitRun_);
  mpHelper_->setCCOperationIndices(theWitRun_);
  

  // get the demand names so don't have to keep calling API routines
  int * nDemandsList ;      
  char *** allDemandsList ;    
  iterativeImpHelper.getDemandLists( theWitRun_, nParts, partList,
                                     &nDemandsList, &allDemandsList );
  
  // we're going to muck with demand vols.
  // So, make a copy of the original demand vols to clean-up the corrupted witRun at the end
  // remember to free the allDemandsVols up at the end
  float *** allDemandsVols;
  iterativeImpHelper.getDemandVols ( theWitRun_, nPeriods, nParts, partList, nDemandsList,
                                     allDemandsList, &allDemandsVols );
    
  // determine if minimum lot sizes are used global and for each part
  witBoolean isMinLotSizeUsedAnywhere ;
  witBoolean * isMinLotSizeUsedForOperation ;
  float ** minLotSizes;
  iterativeImpHelper.getMinLotSizeFlagsAndVols( theWitRun_, nOperations, nPeriods,
                                                operationList, &isMinLotSizeUsedAnywhere,
                                                &isMinLotSizeUsedForOperation, &minLotSizes );

  // get a copy of the original supply vols so that we can set them back
  // when we're done
  float ** allSupplyVols;
  iterativeImpHelper.getSupplyVols( theWitRun_, nParts, 
                                    partList, &allSupplyVols);

  // get a copy of the production hard upper bounds so we can restore
  // them to their original values after we are through mucking them up
  float ** allExecUpperBounds;
  iterativeImpHelper.getExecUpperBounds( theWitRun_, nOperations, operationList, &allExecUpperBounds );
a657 1
  
d661 7
a668 37
  // get the number of BOM entries for each operation to minimize number of API calls
  // we'll need this info to update the global substitute BOM production schedule
  // (remember to clean up this memory later)
  int * nBom = NULL; 
  iterativeImpHelper.getNBom ( theWitRun_, nOperations, operationList, &nBom );
  
  // get the number of substitutes on each BOM entree on each operation to minimize API calling
  // we'll need this info to update the global substitute BOM production schedule
  // (remember to clean up this memory later)
  int ** nSubsBom = NULL; 
  iterativeImpHelper.getNSubsBom ( theWitRun_, nOperations, operationList, nBom, &nSubsBom);   
  
  // allocate and initialize global shipment schedule
  // (remember to clean up this memory later)
  float *** globalShipSchedule = NULL;
  iterativeImpHelper.initGlobalShipSchedule ( &globalShipSchedule,
                                              nPeriods,
                                              nParts,
                                              nDemandsList );
  
  //
  // allocate and initialize global execution schedule
  // (remember to clean up this memory later)
  float ** globalExecSchedule = NULL;
  iterativeImpHelper.initGlobalExecSchedule ( &globalExecSchedule,
                                              nPeriods,
                                              nOperations );

  
  // allocate and initialize global substitute production schedule
  // (remember to clean up this memory later)
  float **** globalSubsBomProdSchedule = NULL;
  iterativeImpHelper.initGlobalSubsBomProdSchedule ( &globalSubsBomProdSchedule,
                                                     nPeriods,
                                                     nOperations,
                                                     nBom,
                                                     nSubsBom);
d693 9
d703 5
a707 14
    // Get the minimum demands and calculate the residual "aboveMinDemands"
    // Do one heuristic implosions on the minimum demands.
    // Set the demand vol equal to the residual "above min" demands.
    setMinDemandsAndCalculateAboveMinDemands( theWitRun_, nPeriods,
                                              nParts, partList,
                                              nDemandsList, allDemandsList,
                                              allDemandsVols );
#ifdef AENGMGR_DUMP_WIT_DATA_FILE
    cout << "Writing the (heur mins pass) wit data file ..." << endl;                      
    sceScenSP_->setWitInformationalMessaging(theWitRun_, SCE_WIT_MESSAGING_ON);
    witWriteData(theWitRun_, "witDataForMins.data");
    sceScenSP_->setWitInformationalMessaging(theWitRun_, SCE_WIT_MESSAGING_OFF);          

#endif
a709 5
    // 3.00: MINS engine must also use heurAlloc engine (minsEngine is ignored!!)
    // 2.30: allow user to specify which engine to use for mins
    //    Note: the updateGlobalSchedules and prepOperationConstraintsForNextImplosionIteration
    //          only needs to be done for heuristic. The Rollover does it within rolloverHeurImplode
    LgFrSceSetOfParameters & setOfParameters =  sceScenSP_->setOfParameters();    
a710 1
    RWCString heurAllocMinsSortStrategy = setOfParameters.getString("heurAllocMinsSortStrategy");
a711 4
    cout << "     ... allocating to mins using (heurAlloc) scheme and ("
	 << heurAllocMinsSortStrategy 
	 << ") sort strategy ..." 
	 << endl;    
d713 5
a717 3
    int sortID = 1;
    int minsSortId = this->sortID(heurAllocMinsSortStrategy);
    LgFrSceSortStrategy * mySortStrategy = new LgFrSceSortStrategy(minsSortId);
a718 2
    // set allocMgr's strategy.  
    this->sortStrategy(mySortStrategy);
a719 2
    // Implode !! 
    this->goRunAllocation();
d721 7
a727 1
    delete mySortStrategy;
a728 3
    
    if (computeCriticalList) 
	theCritList.merge( theWitRun_);
d730 5
a734 14
    iterativeImpHelper.updateGlobalSchedules( theWitRun_, nPeriods, nParts, nOperations,
					      partList, operationList,
					      nDemandsList, allDemandsList,
					      nBom, nSubsBom,
					      globalShipSchedule,
					      globalExecSchedule,
					      globalSubsBomProdSchedule);
    
    iterativeImpHelper.prepOperationConstraintsForNextImplosionIteration ( theWitRun_, nPeriods, nParts,
									   partList, nOperations, operationList,
									   globalExecSchedule,
									   allExecUpperBounds,
									   isMinLotSizeUsedAnywhere, 
									   isMinLotSizeUsedForOperation );
d736 1
a740 15
    // get the "above min demands" out of the demand app data and set the demand
    // vols for the implosion (roll or heur) on the residual demand
    LgFrSceDemandAppData * dmdAppDataPtr;
    for (int i=0; i<nParts; i++)  {
      for (int j=0; j<nDemandsList[i]; j++)  {
        witGetDemandAppData( theWitRun_, partList[i], allDemandsList[i][j],
                             (void **) &dmdAppDataPtr);
        LgFrTimeVecFloat demandVol( dmdAppDataPtr->aboveMinDemandVol() );
        assert (demandVol.min() >= 0.0 );
        witSetDemandDemandVol( theWitRun_, partList[i], allDemandsList[i][j],
                               demandVol.data() );
      }
    }
  } // end if (min demands exist)

a757 6
#ifdef AENGMGR_DUMP_WIT_DATA_FILE
  cout << "Writing the (heurAlloc first pass) wit data file ..." << endl;                      
  sceScenSP_->setWitInformationalMessaging(theWitRun_, SCE_WIT_MESSAGING_ON);
  witWriteData(theWitRun_, "witDataForFirstPass.data");
  sceScenSP_->setWitInformationalMessaging(theWitRun_, SCE_WIT_MESSAGING_OFF);          
#endif
d767 1
a767 1
  LgFrSceSortStrategy * mySortStrategy = new LgFrSceSortStrategy(aboveMinSortId);
d772 23
a794 2
  // Implode !! 
  this->goRunAllocation();
a797 17
  if (computeCriticalList) 
    theCritList.merge( theWitRun_);

  iterativeImpHelper.updateGlobalSchedules( theWitRun_, nPeriods, nParts, nOperations,
					    partList, operationList,
					    nDemandsList, allDemandsList,
					    nBom, nSubsBom,
					    globalShipSchedule,
					    globalExecSchedule, 
					    globalSubsBomProdSchedule);

  iterativeImpHelper.prepOperationConstraintsForNextImplosionIteration(theWitRun_, nPeriods, nParts,
								       partList, nOperations, operationList, 
								       globalExecSchedule, 
								       allExecUpperBounds,
								       isMinLotSizeUsedAnywhere, 
								       isMinLotSizeUsedForOperation );
a814 7
    // set the demand on the feature nodes, and zero out the other demand
    setPureOptionBuildDemand( theWitRun_, nPeriods, nParts, partList, 
			      nOperations, operationList, nDemandsList,
                              allDemandsList, allSupplyVols, nBom, nSubsBom, mpHelper_, iterativeImpHelper,
                              globalSubsBomProdSchedule, globalShipSchedule,
			      allDemandsVols, globalExecSchedule);
    
a815 6
#ifdef AENGMGR_DUMP_WIT_DATA_FILE
    cout << "    ...  Writing the (heur second pass) wit data file ..." << endl;                      
    sceScenSP_->setWitInformationalMessaging(theWitRun_, SCE_WIT_MESSAGING_ON);
    witWriteData(theWitRun_, "witDataForFeaturesPass.data");
    sceScenSP_->setWitInformationalMessaging(theWitRun_, SCE_WIT_MESSAGING_OFF);          
#endif
d819 1
d830 1
a830 1
    LgFrSceSortStrategy * mySortStrategy = new LgFrSceSortStrategy(featSortId);
a833 3
    
    // Implode !! 
    this->goRunAllocation();
d835 32
a866 1
    delete mySortStrategy;
d869 2
a870 2
    if (computeCriticalList) 
      theCritList.merge( theWitRun_);
a871 14
    iterativeImpHelper.updateGlobalSchedules( theWitRun_, nPeriods, nParts, nOperations,
					      partList, operationList, 
					      nDemandsList, allDemandsList,
					      nBom, nSubsBom,
					      globalShipSchedule,
					      globalExecSchedule,                                  
					      globalSubsBomProdSchedule);
    
    iterativeImpHelper.prepOperationConstraintsForNextImplosionIteration(theWitRun_, nPeriods, nParts,
									 partList, nOperations, operationList,
									 globalExecSchedule, 
									 allExecUpperBounds,
									 isMinLotSizeUsedAnywhere, 
									 isMinLotSizeUsedForOperation );
d875 1
a875 24
  // put the global solution schedules in theWitRun
  iterativeImpHelper.stuffGlobalSolutionSchedules( theWitRun_, nPeriods, nParts, nOperations,
                                                   nDemandsList, allDemandsList,
                                                   partList, operationList, nBom, nSubsBom,
                                                   globalShipSchedule,
                                                   globalExecSchedule,                                
                                                   globalSubsBomProdSchedule );
  
  // Uncorrupt the WitRun: set the minLotSizes back to original values
  if (isMinLotSizeUsedAnywhere) 
    iterativeImpHelper.setMinLotSize( theWitRun_, nPeriods, nOperations, operationList,
                                      isMinLotSizeUsedForOperation, minLotSizes );

  // Uncorrupt the WitRun: set the supplyVols back to original values
  iterativeImpHelper.setSupplyVols( theWitRun_, nParts, partList, allSupplyVols );

  // Uncorrupt the WitRun: set the production hard upper bounds back to their original values
  iterativeImpHelper.setExecUpperBounds( theWitRun_, nOperations, operationList, allExecUpperBounds );
  // Uncorrupt the WitRun: set the demands back to their original values (but leave
  // the feature demands as they are now.  (this is because their original values
  // are zero.
  this->setAllDemandVolsExceptFeatureDemands(nParts, partList,
                                             nDemandsList, allDemandsList,
                                             allDemandsVols);
d881 437
a1317 5
  //
  // Clean-Up: free up all the memory we malloc-ed and no longer need
  //
  // clean-up global ship and prod schedule
  for ( int i=0; i<nParts; i++ ) {
a1318 7
    for ( int j=0; j<nDemandsList[i]; j++) 
      portableFree(globalShipSchedule[i][j] );
    portableFree(globalShipSchedule[i]);
  }
  portableFree(globalShipSchedule);
  
  for ( int o=0; o<nOperations; o++){
a1319 3
    portableFree(allExecUpperBounds[o]);
    if (isMinLotSizeUsedForOperation[o])
      portableFree(minLotSizes[o]);
d1321 13
a1333 9
    for (int j=0; j<nBom[o]; j++){
      for (int k=0; k<nSubsBom[o][j]; k++) 
        portableFree ( globalSubsBomProdSchedule[o][j][k] );
      portableFree ( globalSubsBomProdSchedule[o][j] );
    }
    portableFree ( globalSubsBomProdSchedule[o] );
    portableFree (nSubsBom[o]);
  }
  portableFree ( globalSubsBomProdSchedule );
d1335 1
a1335 10
  
  for (i=0; i<nParts; i++) {
    portableFree(allSupplyVols[i]);
  }
  portableFree(allSupplyVols);
  portableFree(allExecUpperBounds);
  portableFree(minLotSizes);
  portableFree (nSubsBom);
  portableFree (nBom);
  portableFree(isMinLotSizeUsedForOperation);
d1337 1
d1339 3
a1341 4
  // clean-up global exec schedule
  for (o=0; o<nOperations; o++ )
    portableFree( globalExecSchedule[o] );
  portableFree(globalExecSchedule);  
d1343 4
a1346 59
  
  // clean-up allDemandsList
  for ( i=0; i<nParts; i++ ) {
    for ( int j=0; j<nDemandsList[i]; j++ )  {
      portableFree( allDemandsList[i][j] );
      portableFree( allDemandsVols[i][j] );
    }
    portableFree ( allDemandsList[i] );
    portableFree ( allDemandsVols[i] );
  }
  portableFree( allDemandsList );
  portableFree( allDemandsVols );
  portableFree( nDemandsList );
  
  //clean-up partList
  for ( i=0; i<nParts; i++ )
    portableFree( partList[i] );
  portableFree(partList);

  //clean-up operationList
  for ( o=0; o<nOperations; o++ )
    portableFree( operationList[o] );
  portableFree(operationList);  
  
}
 
// This is member function mucks up the demands - if you want to get back your
// original demands, you best have saved them somewhere safe before you invoke
// this member function.
//
// Calculate amount of pure option we want to try and build
// (code snipped from LgFrInitialProblemForSce::printStandAloneFeatureAnalysisReport).
// Set the demand on the pure options nodes in the WitRun and zero-out all other
// demands.
//
// increment the global number of demands, the global demand list, and the global shipment
//
void 
LgFrSceAllocationEngineMgr::setPureOptionBuildDemand(
         WitRun * const theWitRun,   // WIT environment   
         const int nPeriods,         // Number of periods 
         const int nParts,           // Number of parts   
         char ** partList,           // List of part names
         const int nOperations,
         char ** operationList,
         int * nDemandsList,         // number of demands on each part
         char *** allDemandsList,    // list of demands names
	 float ** allSupplyVols,
         int * nBom,                 // Number of BOM entries for each part
         int ** nSubsBom,            // Number of substitutes on each part's BOM entries 
	 LgFrMultiPlantHelper * mpHelper,
         LgFrSceIterativeImpHelper  & iterativeImpHelper,
         float **** glbSubsProdVol,  // substitute bom production vol
         float *** glbShipSched,
	 float *** allDemandsVols,
	 float ** globalExecSchedule)
{
  RWCString plannerTopLevelPart;
  RWCString geo;
a1347 1
  cout << "Executing  setPureOptionBuildDemand..." << endl;  
a1349 1
  LgFrSceSetOfParameters & setOfParameters =  sceScenSP_->setOfParameters();    
d1351 1
a1351 2
  //  RWCString pegToMachineDemandPeriod;
  //  RWCString pegToMachineShipPeriod;
a1352 8
  LgFrTimeVecFloat zeroTimeVec( (size_t) nPeriods, 0.0 );
  
  // Zero-out all the demand vols.
  // As we loop through, the demands are going to be incremented so it's important to
  // start with all demands set equal to zero
  iterativeImpHelper.zeroOutAllDemands (theWitRun, nPeriods, nParts,
                                        partList, nDemandsList,
                                        allDemandsList);
d1357 5
a1361 2
    // The only place we find specialFeatureParts is as children of GPD parts.
    if (! mpHelper->isOperationSpecialGeoPlannerDemand(theWitRun, fullWitGeoPlannerDemandOperation,
d1365 2
a1366 1

d1368 1
a1368 1
    for (int j=0; j<nBom[o]; j++)  {
d1372 1
a1372 1
      witGetBomEntryConsumedPart(theWitRun, fullWitGeoPlannerDemandOperation, j, &fullWitFeaturePart);
d1376 1
a1376 1
      if (!  mpHelper->isPartSpecialFeature(theWitRun, fullWitFeaturePart)) {
a1379 1

d1385 1
a1385 1
      if (mpHelper->isPartSpecialCustChoiceFeature(theWitRun, fullWitFeaturePart, 
d1387 5
a1391 2
	    
	    
d1394 1
a1394 5
	// (shipVol(GPD) * usageRate * featratio) - prodVol(SFP)  (rolled) for timing
	    
	    // Multiple BOM entries between the parent and the child could be used to implement
	    // different feature rates over time.
	RWCString featureDemandName = mpHelper->custChoiceFeatureDemandName(fullWitGeoPlannerDemandOperation );
d1396 8
a1403 5
	    
	int gpdIndex = mpHelper->witPartIndex(theWitRun, fullWitGeoPlannerDemandOperation);
	float * gpdDemVol =  allDemandsVols[gpdIndex][0];
	LgFrTimeVecFloat gpdExecVol ((size_t) nPeriods, globalExecSchedule[o]);
	//	LgFrTimeVecFloat subVol ((size_t) nPeriods, glbSubsProdVol[o][j][sj]);
d1405 3
a1407 2
	witGetBomEntryUsageRate(theWitRun, fullWitGeoPlannerDemandOperation, j, &usageRate);	      
	LgFrTimeVecFloat featRatio = mpHelper->custChoiceFeatureRatio(theWitRun, fullWitFeaturePart);
d1410 1
a1410 2
	    
#if 1  // THE NEW WAY
d1424 2
a1425 2
	// Compute tiedBackGpdExecVol ...
	LgFrTimeVecFloat tiedBackGpdExecVol(gpdExecVol);
a1451 1
	      
d1453 3
a1455 1
	    
d1457 2
a1458 1
	LgFrTimeVecFloat featureDemandPreUsageRate(featRatio);
d1460 28
a1487 2
	  featureDemandPreUsageRate[t] *= tiedBackGpdExecVol[t];
	//		featureDemandPreUsageRate[t] *= gpdDemVol[t];
d1489 48
d1538 11
d1553 50
a1602 4
	int ccSfpIndex = mpHelper->witPartIndex(theWitRun, fullWitFeaturePart);
	int ccSfoIndex = mpHelper->witOperationIndex(theWitRun, fullWitFeaturePart);
	LgFrTimeVecFloat supplyVolCCfeaturePart( (size_t) nPeriods, allSupplyVols[ccSfpIndex]);
	LgFrTimeVecFloat execVolCCfeaturePart((size_t) nPeriods, globalExecSchedule[ccSfoIndex]);
d1604 274
a1877 62
	  featuresShippedPreUsageRate[t] = supplyVolCCfeaturePart[t] + execVolCCfeaturePart[t];
	    
	    
	    // here's the straight net of what you need for the second pass (pre usageRate)
	LgFrTimeVecFloat secondPassFeatureDemandVol(featureDemandPreUsageRate);
	for ( t=0; t<nPeriods; t++)
	  secondPassFeatureDemandVol[t] -= featuresShippedPreUsageRate[t];
#endif
	    
#if 0
	// here's the amount of features supplied in first pass (pre usageRate)
	LgFrTimeVecFloat featuresShippedPreUsageRate((size_t) nPeriods, 0.0);
	for ( t=0; t<nPeriods; t++)
	  featuresShippedPreUsageRate[t] = gpdExecVol[t] - subVol[t];
	    
	    
	    // here's the straight net of what you need for the second pass (pre usageRate)
	LgFrTimeVecFloat secondPassFeatureDemandVol(featureDemandPreUsageRate);
	for ( t=0; t<nPeriods; t++)
	  secondPassFeatureDemandVol[t] -= featuresShippedPreUsageRate[t];
#endif
	    
	    
	// Roll negative (secondPassFeatureDemandVol) forward.  This could happen because:
	//   - Machine Feature Supply (ie, FEN5) 
	//   - wierd offsetting issues (??)
	for ( t=0; t<nPeriods-1; t++)
	  if (secondPassFeatureDemandVol[t] < 0) {
	    secondPassFeatureDemandVol[t+1] += secondPassFeatureDemandVol[t];
	    secondPassFeatureDemandVol[t] = 0;
	  }
	if (secondPassFeatureDemandVol[nPeriods - 1] < 0) 
	  secondPassFeatureDemandVol[nPeriods - 1] = 0;
	    
	    // now insure that the cum of secondPassFeatureDemandVol does not exceed the 
	    // cum of machines shipped!
	for ( t=0; t<nPeriods; t++) {
	  // add in what you rolled from last period
	  float delta = secondPassFeatureDemandVol[t] - gpdExecVol[t];
	  // do you need to roll?
	  if (delta > 0) {
	    secondPassFeatureDemandVol[t] = gpdExecVol[t];
	    if (t+1 < nPeriods)
	      secondPassFeatureDemandVol[t+1] += delta;
	  }
	  // or not roll?
	  else {
	    if (t+1 < nPeriods)
	      gpdExecVol[t+1] -= delta;
	  }
	}
	    
	    
	// now we apply the usageRate
	for ( t=0; t<nPeriods-1; t++)
	  secondPassFeatureDemandVol[t] *= usageRate;
	    
	    
	    // YEAH, we've computed the second pass demand vol!!
	    // set it
	witSetDemandDemandVol(theWitRun, fullWitFeaturePart, featureDemandName,
			      secondPassFeatureDemandVol.data());
a1878 3
	portableFree(fullWitFeaturePart);
	continue;
      }
d1880 3
a1884 6
      // + --------------------------------
      // + If its a STANDALONE FEATURE
      // + --------------------------------
      // Just for the sake of it ....
      assert (mpHelper->isPartSpecialStandaloneFeature(theWitRun, fullWitFeaturePart, 
						       gg, pp, ppdf, fp));
a1885 2
      // TRE: Just for assertion, sake ...
      assert(nSubsBom[o][j] == 1);
d1888 8
a1895 105
      // if there are substitutes, then the child might be a pure option
      // note that one must look at the NullSub part to determine which of the three
      // type of STANDALONE FEATUREs it is ...
      if (nSubsBom[o][j] > 0)   {
	// look at each of the substitues.
	// As of 5/31/96, the model should only allow ONE substitute, though.
	for (int sj=0; sj<nSubsBom[o][j]; sj++)  {
	  char * sub;
	  witGetSubsBomEntryConsumedPart(theWitRun, fullWitGeoPlannerDemandOperation, j, sj, &sub);
	  // the substitute should be a  special null subs

	  // the null sub will be one of:
	  //    globalNullSub (Purely optional standalone feature)
	  //    globalMaxWithoutNullsub (purely mandatory standalone feature)
	  //    maxWithoutNullsub  (standalone feature with 0<maxWithout <1)
	  
	  // ---------------------------------------------------
	  // if its a GLOBAL MAXWITHOUT (ie, Mandatory Feature)
	  // ---------------------------------------------------
	  //  then we can skip it because there  never be any pureOption demandVol
	  RWCString pppdf;
	  if (mpHelper->isPartSpecialGlobalMaxWithoutNullSubstitute(theWitRun, sub, pppdf)) {
	    portableFree(sub);
	    continue;
	  }
	  
	  
	  // -----------------------------------------------------------------------
	  // if its a PURE Option or a MWO (ie, purely optional or partly mandatory)
	  // -----------------------------------------------------------------------
	  // --------------------------------------------------------------------------------

	  // OK, if you've gotten to here then you've found a PURE OPTION!
	  // The child is the pure option.
	      
	  // First time you find the pure option add the build demand
	  // The default demand volume of a time vec of all 0.0
	  // There could be multiple arcs between the child and parent AND there could
	  // be multiple substitutes on each arc. We want at most one pureOptionBuildDemandName
	  // Zero out all the demands in theWitRun
	  // for every (special geo planner demand part)-(pure option) pair.
	  //
	  // Multiple BOM entries between the parent and the child could be used to implement
	  // different feature rates over time.
	  RWCString featureDemandName = mpHelper->pureOptionBuildDemandName(fullWitGeoPlannerDemandOperation );
	      
	  // Find out what the current demand vol is on the pure option
	  // and calculate how much you want to increment the demand by.
	  float * pureOptBldDemVol;
	  witGetDemandDemandVol( theWitRun, fullWitFeaturePart, featureDemandName, &pureOptBldDemVol);
	      
	  // --------------------------------------------------------------------------------
	  //
	  // This is the place where the rubber hits the road in feature modeling.
	  // This is where the demand for features is calculated.
	  // Implement you favorite algorithm for calculating the amount of a feature
	  // to be built in the second pass of the heuristic HERE.
	  //
	      
	  //
	  // This code says that amount of the null substituted used times the feature ratio
	  // (ie. subsProdVol * usageRate) is the amt of pure option to try and build
	  //
	  // The feature ratio used is the feature ratio in effect during the box
	  // ship period (which may have no similarity with the feature rate
	  // that was in effect in the period during which the demand originated from).
	  
	  // *****************************************************************************
	  // The amount of the produced part due to this substitute is given by
	  // subProdVol.
	  LgFrTimeVecFloat subProdVol ((size_t) nPeriods, glbSubsProdVol[o][j][sj]);
	  
	  if ( featureRatioPegMethod == "pegToMachineShipPeriod" ) {
	    
	    // But, we need the usageRatio...
	    float usageRatio;
	    witGetBomEntryUsageRate(theWitRun, fullWitGeoPlannerDemandOperation, j, &usageRatio);
		
	    //	      int * impactPeriod;
	    //	      witGetBomEntryImpactPeriod(theWitRun, fullWitGeoPlannerDemandOperation, j, &impactPeriod);
	    // FINISH_ME: this is not right yet
		
	    // ...to calculate the amount of the substitute that was consumed
	    // which is equal to the amount of the pure option we want to try and build.
		
	    for (int t=0; t<nPeriods; t++) {
	      if (subProdVol[t] > 0.0001) {
		//		  assert(impactPeriod[t] >= 0);
		//		  pureOptBldDemVol[impactPeriod[t]] += (usageRatio * subProdVol[t]);
		pureOptBldDemVol[t] += (usageRatio * subProdVol[t]);
	      }
	      //	      portableFree(impactPeriod);
	    }
	  }
	      
	      
	  // Set the new demandVol in theWitRun
	  // Note creating a timeVec for error checking purpose only
	  LgFrTimeVecFloat pureOptBldDemVolTV ( (size_t) nPeriods, pureOptBldDemVol);
	  assert (pureOptBldDemVolTV.min() >= 0.0);
	  witSetDemandDemandVol ( theWitRun, fullWitFeaturePart, featureDemandName,
				  pureOptBldDemVol);
	  portableFree( pureOptBldDemVol );
	  portableFree(sub);
	}  // loop over subs 
d1897 23
a1920 1
      portableFree(fullWitFeaturePart);
d1922 5
d1928 4
a1931 1
    
d1933 5
d1940 17
a1956 24
// Set demand vols
// Use this member function to clean-up the mucked demand vols
void
LgFrSceAllocationEngineMgr::setAllDemandVolsExceptFeatureDemands ( int nParts,
                                                             char ** partList,
                                                             int *  nDemandsList,
                                                             char *** allDemandsList,
                                                             float *** allDemandsVols )
{
  RWCString plannerTopLevelPart;
  RWCString geo;
  for (int i=0; i<nParts; i++) {
    for (int j=0; j<nDemandsList[i]; j++) {
      if (! this->mpHelper_->isDemandSpecialPureOptionBuildDemand( this->theWitRun_,
                                                                   partList[i],
                                                                   allDemandsList[i][j],
                                                                   plannerTopLevelPart,
                                                                   geo)) {
        witSetDemandDemandVol (this->theWitRun_, partList[i], allDemandsList[i][j],
                               allDemandsVols[i][j]) ;
      }
    }
  }
}  
d2157 1
a2157 68
/*******************************************************************************
* Set the demand vols in theWitRun equal to the minimum demands which are
* the uncummed cum ship lbs.
* Calclate the residual "above min" demand vol and store it in demand app data.
*
* Note: the calling program is responsible for deleting any demand app data 
*       ptrs that are "new-ed" in here.
********************************************************************************/
void
LgFrSceAllocationEngineMgr::setMinDemandsAndCalculateAboveMinDemands(
                                                      WitRun * theWitRun,
                                                      int      nPeriods,
                                                      int      nParts,
                                                      char **  partList,
                                                      int *    nDemandsList,
                                                      char *** allDemandsList,
                                                      float *** allDemandsVols )
{
  //get the cum ship soft lower bounds, which are the cummulated
  //minimum demand volumes
  for ( int i=0; i<nParts; i++ ) {
    for ( int j=0; j<nDemandsList[i]; j++ ) {
      float * cumShipBound, * hardLower, * hardUpper;
      witGetDemandCumShipBounds( theWitRun, partList[i], allDemandsList[i][j],
                                 &hardLower,
                                 &cumShipBound,
                                 &hardUpper);
      portableFree ( hardLower);
      portableFree ( hardUpper );
      
      // un-cum the lower bounds and use them as the demand vols for the first pass
      LgFrTimeVecFloat minDemandVol =
        LgFrTimeVecFloat(nPeriods,cumShipBound).undoCum();
      portableFree ( cumShipBound );
      // make sure the de-cummed demand vol is non-negative
      assert ( minDemandVol >= 0.0 );
      // FINISH_ME:  We can directly set the allocLets here instead of saving to demandVols
      //    check to see if these demandVols are used??
      witSetDemandDemandVol( theWitRun, partList[i],
                             allDemandsList[i][j],
                             minDemandVol.data() );

      //get the total demand
      LgFrTimeVecFloat demandVol = LgFrTimeVecFloat ( nPeriods, allDemandsVols[i][j] );

      // the amt of demand in excess of the minimum (i.e. "above the min demand")
      // is demand vol used in the second pass. Calculate it and store as appData
      // in the workingWitRun
      LgFrSceDemandAppData * demandAppDataPtr = NULL ;
      witGetDemandAppData( theWitRun, partList[i], allDemandsList[i][j],
                           (void **) &demandAppDataPtr );
      if ( demandAppDataPtr == NULL ) {
        demandAppDataPtr = new LgFrSceDemandAppData ((size_t) nPeriods, 1.0);
        assert ( demandAppDataPtr != 0 );
        witSetDemandAppData( theWitRun, partList[i], allDemandsList[i][j],  
                            (void *) demandAppDataPtr );
      }
      demandAppDataPtr->aboveMinDemandVol ( demandVol - minDemandVol );
      float mytemp;
      mytemp = demandAppDataPtr->aboveMinDemandVol().min();
      if (mytemp < 0)
         printf("HERE/n");
      assert ( demandAppDataPtr->aboveMinDemandVol().min() >= -0.01 );
      
    } // end j loop     
   } //end i loop
}

d2185 110
@

